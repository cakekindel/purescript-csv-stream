{
  "version": 3,
  "sources": ["output/Data.Functor/foreign.js", ".spago/p/prelude-6.0.1/src/Control/Semigroupoid.purs", ".spago/p/prelude-6.0.1/src/Control/Category.purs", ".spago/p/prelude-6.0.1/src/Data/Boolean.purs", ".spago/p/prelude-6.0.1/src/Data/Function.purs", "output/Data.Unit/foreign.js", ".spago/p/prelude-6.0.1/src/Type/Proxy.purs", ".spago/p/prelude-6.0.1/src/Data/Functor.purs", "output/Data.Semigroup/foreign.js", ".spago/p/prelude-6.0.1/src/Data/Symbol.purs", "output/Record.Unsafe/foreign.js", ".spago/p/prelude-6.0.1/src/Data/Semigroup.purs", ".spago/p/control-6.0.0/src/Control/Alt.purs", "output/Control.Apply/foreign.js", ".spago/p/prelude-6.0.1/src/Control/Apply.purs", ".spago/p/prelude-6.0.1/src/Control/Applicative.purs", "output/Data.Bounded/foreign.js", "output/Data.Ord/foreign.js", "output/Data.Eq/foreign.js", ".spago/p/prelude-6.0.1/src/Data/Eq.purs", ".spago/p/prelude-6.0.1/src/Data/Ordering.purs", "output/Data.Ring/foreign.js", "output/Data.Semiring/foreign.js", ".spago/p/prelude-6.0.1/src/Data/Semiring.purs", ".spago/p/prelude-6.0.1/src/Data/Ring.purs", ".spago/p/prelude-6.0.1/src/Data/Ord.purs", ".spago/p/prelude-6.0.1/src/Data/Bounded.purs", "output/Data.Show/foreign.js", ".spago/p/prelude-6.0.1/src/Data/Show.purs", ".spago/p/maybe-6.0.0/src/Data/Maybe.purs", "output/Effect.Aff/foreign.js", "output/Control.Bind/foreign.js", ".spago/p/prelude-6.0.1/src/Control/Bind.purs", ".spago/p/prelude-6.0.1/src/Control/Monad.purs", ".spago/p/either-6.1.0/src/Data/Either.purs", "output/Effect/foreign.js", ".spago/p/prelude-6.0.1/src/Data/Monoid.purs", ".spago/p/effect-4.0.0/src/Effect.purs", "output/Effect.Exception/foreign.js", ".spago/p/exceptions-6.0.0/src/Effect/Exception.purs", ".spago/p/transformers-6.0.0/src/Control/Monad/Error/Class.purs", ".spago/p/identity-6.0.0/src/Data/Identity.purs", "output/Effect.Ref/foreign.js", ".spago/p/refs-6.0.0/src/Effect/Ref.purs", ".spago/p/tailrec-6.1.0/src/Control/Monad/Rec/Class.purs", "output/Unsafe.Coerce/foreign.js", ".spago/p/st-6.2.0/src/Control/Monad/ST/Global.purs", "output/Control.Monad.ST.Internal/foreign.js", ".spago/p/st-6.2.0/src/Control/Monad/ST/Internal.purs", "output/Data.HeytingAlgebra/foreign.js", ".spago/p/prelude-6.0.1/src/Data/HeytingAlgebra.purs", ".spago/p/tuples-7.0.0/src/Data/Tuple.purs", ".spago/p/transformers-6.0.0/src/Control/Monad/State/Class.purs", ".spago/p/transformers-6.0.0/src/Control/Monad/Trans/Class.purs", ".spago/p/effect-4.0.0/src/Effect/Class.purs", ".spago/p/transformers-6.0.0/src/Control/Monad/Writer/Class.purs", ".spago/p/control-6.0.0/src/Control/Plus.purs", ".spago/p/safe-coerce-2.0.0/src/Safe/Coerce.purs", ".spago/p/newtype-5.0.0/src/Data/Newtype.purs", ".spago/p/transformers-6.0.0/src/Control/Monad/Writer/Trans.purs", ".spago/p/parallel-6.0.0/src/Control/Parallel/Class.purs", "output/Data.Foldable/foreign.js", ".spago/p/bifunctors-6.0.0/src/Data/Bifunctor.purs", ".spago/p/prelude-6.0.1/src/Data/Monoid/Conj.purs", ".spago/p/foldable-traversable-6.0.0/src/Data/Foldable.purs", "output/Data.Traversable/foreign.js", ".spago/p/foldable-traversable-6.0.0/src/Data/Traversable.purs", ".spago/p/parallel-6.0.0/src/Control/Parallel.purs", ".spago/p/datetime-6.1.0/src/Data/Time/Duration.purs", "output/Partial.Unsafe/foreign.js", "output/Partial/foreign.js", ".spago/p/partial-4.0.0/src/Partial.purs", ".spago/p/partial-4.0.0/src/Partial/Unsafe.purs", ".spago/p/aff-7.1.0/src/Effect/Aff.purs", ".spago/p/transformers-6.0.0/src/Control/Monad/State/Trans.purs", ".spago/p/aff-7.1.0/src/Effect/Aff/Class.purs", "output/Node.Stream.Object/foreign.js", "output/Control.Promise/foreign.js", "output/Data.FunctorWithIndex/foreign.js", ".spago/p/foldable-traversable-6.0.0/src/Data/FunctorWithIndex.purs", "output/Data.Unfoldable/foreign.js", "output/Data.Unfoldable1/foreign.js", ".spago/p/unfoldable-6.0.0/src/Data/Unfoldable1.purs", ".spago/p/unfoldable-6.0.0/src/Data/Unfoldable.purs", ".spago/p/nonempty-7.0.0/src/Data/NonEmpty.purs", ".spago/p/lists-7.0.0/src/Data/List/Types.purs", "output/Foreign/foreign.js", "output/Data.Int/foreign.js", "output/Data.Number/foreign.js", ".spago/p/integers-6.0.0/src/Data/Int.purs", ".spago/p/lists-7.0.0/src/Data/List.purs", ".spago/p/lists-7.0.0/src/Data/List/NonEmpty.purs", ".spago/p/aff-promise-4.0.0/src/Control/Promise.purs", "output/Data.Array/foreign.js", "output/Data.Array.ST/foreign.js", "output/Control.Monad.ST.Uncurried/foreign.js", ".spago/p/arrays-7.3.0/src/Data/Array/ST.purs", ".spago/p/arrays-7.3.0/src/Data/Array/ST/Iterator.purs", "output/Data.Function.Uncurried/foreign.js", ".spago/p/arrays-7.3.0/src/Data/Array.purs", "output/Effect.Uncurried/foreign.js", "output/Node.EventEmitter/foreign.js", ".spago/p/node-event-emitter-3.0.0/src/Node/EventEmitter.purs", "src/Node.Stream.Object.purs", "output/Effect.AVar/foreign.js", ".spago/p/avar-5.0.0/src/Effect/AVar.purs", ".spago/p/avar-5.0.0/src/Effect/Aff/AVar.purs", ".spago/p/transformers-6.0.0/src/Control/Monad/State.purs", "output/Data.Array.NonEmpty.Internal/foreign.js", ".spago/p/arrays-7.3.0/src/Data/Array/NonEmpty.purs", ".spago/p/spec-7.6.0/src/Test/Spec/Tree.purs", ".spago/p/spec-7.6.0/src/Test/Spec.purs", ".spago/p/spec-7.6.0/src/Test/Spec/Assertions.purs", "test/Test/Node.Stream.Object.purs", ".spago/p/spec-7.6.0/src/Test/Spec/Config.purs", ".spago/p/ordered-collections-3.2.0/src/Data/Map/Internal.purs", "output/Test.Spec.Console/foreign.js", ".spago/p/spec-7.6.0/src/Test/Spec/Console.purs", ".spago/p/transformers-6.0.0/src/Control/Monad/Writer.purs", ".spago/p/pipes-8.0.0/src/Pipes/Internal.purs", ".spago/p/pipes-8.0.0/src/Pipes/Core.purs", ".spago/p/pipes-8.0.0/src/Pipes.purs", ".spago/p/ansi-7.0.0/src/Ansi/Codes.purs", ".spago/p/spec-7.6.0/src/Test/Spec/Style.purs", ".spago/p/spec-7.6.0/src/Test/Spec/Speed.purs", ".spago/p/spec-7.6.0/src/Test/Spec/Result.purs", ".spago/p/spec-7.6.0/src/Test/Spec/Runner/Event.purs", ".spago/p/spec-7.6.0/src/Test/Spec/Summary.purs", ".spago/p/spec-7.6.0/src/Test/Spec/Reporter/Base.purs", ".spago/p/spec-7.6.0/src/Test/Spec/Reporter/Console.purs", "output/Test.Spec.Runner/foreign.js", ".spago/p/datetime-6.1.0/src/Data/DateTime/Instant.purs", "output/Effect.Now/foreign.js", ".spago/p/spec-7.6.0/src/Test/Spec/Runner.purs", "test/Test/Main.purs", "<stdin>"],
  "sourcesContent": ["export const arrayMap = function (f) {\n  return function (arr) {\n    var l = arr.length;\n    var result = new Array(l);\n    for (var i = 0; i < l; i++) {\n      result[i] = f(arr[i]);\n    }\n    return result;\n  };\n};\n", "module Control.Semigroupoid where\n\n-- | A `Semigroupoid` is similar to a [`Category`](#category) but does not\n-- | require an identity element `identity`, just composable morphisms.\n-- |\n-- | `Semigroupoid`s must satisfy the following law:\n-- |\n-- | - Associativity: `p <<< (q <<< r) = (p <<< q) <<< r`\n-- |\n-- | One example of a `Semigroupoid` is the function type constructor `(->)`,\n-- | with `(<<<)` defined as function composition.\nclass Semigroupoid :: forall k. (k -> k -> Type) -> Constraint\nclass Semigroupoid a where\n  compose :: forall b c d. a c d -> a b c -> a b d\n\ninstance semigroupoidFn :: Semigroupoid (->) where\n  compose f g x = f (g x)\n\ninfixr 9 compose as <<<\n\n-- | Forwards composition, or `compose` with its arguments reversed.\ncomposeFlipped :: forall a b c d. Semigroupoid a => a b c -> a c d -> a b d\ncomposeFlipped f g = compose g f\n\ninfixr 9 composeFlipped as >>>\n", "module Control.Category\n  ( class Category\n  , identity\n  , module Control.Semigroupoid\n  ) where\n\nimport Control.Semigroupoid (class Semigroupoid, compose, (<<<), (>>>))\n\n-- | `Category`s consist of objects and composable morphisms between them, and\n-- | as such are [`Semigroupoids`](#semigroupoid), but unlike `semigroupoids`\n-- | must have an identity element.\n-- |\n-- | Instances must satisfy the following law in addition to the\n-- | `Semigroupoid` law:\n-- |\n-- | - Identity: `identity <<< p = p <<< identity = p`\nclass Category :: forall k. (k -> k -> Type) -> Constraint\nclass Semigroupoid a <= Category a where\n  identity :: forall t. a t t\n\ninstance categoryFn :: Category (->) where\n  identity x = x\n", "module Data.Boolean where\n\n-- | An alias for `true`, which can be useful in guard clauses:\n-- |\n-- | ```purescript\n-- | max x y | x >= y    = x\n-- |         | otherwise = y\n-- | ```\notherwise :: Boolean\notherwise = true\n", "module Data.Function\n  ( flip\n  , const\n  , apply\n  , ($)\n  , applyFlipped\n  , (#)\n  , applyN\n  , on\n  , module Control.Category\n  ) where\n\nimport Control.Category (identity, compose, (<<<), (>>>))\nimport Data.Boolean (otherwise)\nimport Data.Ord ((<=))\nimport Data.Ring ((-))\n\n-- | Given a function that takes two arguments, applies the arguments\n-- | to the function in a swapped order.\n-- |\n-- | ```purescript\n-- | flip append \"1\" \"2\" == append \"2\" \"1\" == \"21\"\n-- |\n-- | const 1 \"two\" == 1\n-- |\n-- | flip const 1 \"two\" == const \"two\" 1 == \"two\"\n-- | ```\nflip :: forall a b c. (a -> b -> c) -> b -> a -> c\nflip f b a = f a b\n\n-- | Returns its first argument and ignores its second.\n-- |\n-- | ```purescript\n-- | const 1 \"hello\" = 1\n-- | ```\n-- |\n-- | It can also be thought of as creating a function that ignores its argument:\n-- |\n-- | ```purescript\n-- | const 1 = \\_ -> 1\n-- | ```\nconst :: forall a b. a -> b -> a\nconst a _ = a\n\n-- | Applies a function to an argument. This is primarily used as the operator\n-- | `($)` which allows parentheses to be omitted in some cases, or as a\n-- | natural way to apply a chain of composed functions to a value.\napply :: forall a b. (a -> b) -> a -> b\napply f x = f x\n\n-- | Applies a function to an argument: the reverse of `(#)`.\n-- |\n-- | ```purescript\n-- | length $ groupBy productCategory $ filter isInStock $ products\n-- | ```\n-- |\n-- | is equivalent to:\n-- |\n-- | ```purescript\n-- | length (groupBy productCategory (filter isInStock products))\n-- | ```\n-- |\n-- | Or another alternative equivalent, applying chain of composed functions to\n-- | a value:\n-- |\n-- | ```purescript\n-- | length <<< groupBy productCategory <<< filter isInStock $ products\n-- | ```\ninfixr 0 apply as $\n\n-- | Applies an argument to a function. This is primarily used as the `(#)`\n-- | operator, which allows parentheses to be omitted in some cases, or as a\n-- | natural way to apply a value to a chain of composed functions.\napplyFlipped :: forall a b. a -> (a -> b) -> b\napplyFlipped x f = f x\n\n-- | Applies an argument to a function: the reverse of `($)`.\n-- |\n-- | ```purescript\n-- | products # filter isInStock # groupBy productCategory # length\n-- | ```\n-- |\n-- | is equivalent to:\n-- |\n-- | ```purescript\n-- | length (groupBy productCategory (filter isInStock products))\n-- | ```\n-- |\n-- | Or another alternative equivalent, applying a value to a chain of composed\n-- | functions:\n-- |\n-- | ```purescript\n-- | products # filter isInStock >>> groupBy productCategory >>> length\n-- | ```\ninfixl 1 applyFlipped as #\n\n-- | `applyN f n` applies the function `f` to its argument `n` times.\n-- |\n-- | If n is less than or equal to 0, the function is not applied.\n-- |\n-- | ```purescript\n-- | applyN (_ + 1) 10 0 == 10\n-- | ```\napplyN :: forall a. (a -> a) -> Int -> a -> a\napplyN f = go\n  where\n  go n acc\n    | n <= 0 = acc\n    | otherwise = go (n - 1) (f acc)\n\n-- | The `on` function is used to change the domain of a binary operator.\n-- |\n-- | For example, we can create a function which compares two records based on the values of their `x` properties:\n-- |\n-- | ```purescript\n-- | compareX :: forall r. { x :: Number | r } -> { x :: Number | r } -> Ordering\n-- | compareX = compare `on` _.x\n-- | ```\non :: forall a b c. (b -> b -> c) -> (a -> b) -> a -> a -> c\non f g x y = g x `f` g y\n", "export const unit = undefined;\n", "-- | The `Proxy` type and values are for situations where type information is\n-- | required for an input to determine the type of an output, but where it is\n-- | not possible or convenient to provide a _value_ for the input.\n-- |\n-- | A hypothetical example: if you have a class that is used to handle the\n-- | result of an AJAX request, you may want to use this information to set the\n-- | expected content type of the request, so you might have a class something\n-- | like this:\n-- |\n-- | ``` purescript\n-- | class AjaxResponse a where\n-- |   responseType :: a -> ResponseType\n-- |   fromResponse :: Foreign -> a\n-- | ```\n-- |\n-- | The problem here is `responseType` requires a value of type `a`, but we\n-- | won't have a value of that type until the request has been completed. The\n-- | solution is to use a `Proxy` type instead:\n-- |\n-- | ``` purescript\n-- | class AjaxResponse a where\n-- |   responseType :: Proxy a -> ResponseType\n-- |   fromResponse :: Foreign -> a\n-- | ```\n-- |\n-- | We can now call `responseType (Proxy :: Proxy SomeContentType)` to produce\n-- | a `ResponseType` for `SomeContentType` without having to construct some\n-- | empty version of `SomeContentType` first. In situations like this where\n-- | the `Proxy` type can be statically determined, it is recommended to pull\n-- | out the definition to the top level and make a declaration like:\n-- |\n-- | ``` purescript\n-- | _SomeContentType :: Proxy SomeContentType\n-- | _SomeContentType = Proxy\n-- | ```\n-- |\n-- | That way the proxy value can be used as `responseType _SomeContentType`\n-- | for improved readability. However, this is not always possible, sometimes\n-- | the type required will be determined by a type variable. As PureScript has\n-- | scoped type variables, we can do things like this:\n-- |\n-- | ``` purescript\n-- | makeRequest :: URL -> ResponseType -> Aff _ Foreign\n-- | makeRequest = ...\n-- |\n-- | fetchData :: forall a. (AjaxResponse a) => URL -> Aff _ a\n-- | fetchData url = fromResponse <$> makeRequest url (responseType (Proxy :: Proxy a))\n-- | ```\nmodule Type.Proxy where\n\n-- | Proxy type for all `kind`s.\ndata Proxy :: forall k. k -> Type\ndata Proxy a = Proxy\n", "module Data.Functor\n  ( class Functor\n  , map\n  , (<$>)\n  , mapFlipped\n  , (<#>)\n  , void\n  , voidRight\n  , (<$)\n  , voidLeft\n  , ($>)\n  , flap\n  , (<@>)\n  ) where\n\nimport Data.Function (const, compose)\nimport Data.Unit (Unit, unit)\nimport Type.Proxy (Proxy(..))\n\n-- | A `Functor` is a type constructor which supports a mapping operation\n-- | `map`.\n-- |\n-- | `map` can be used to turn functions `a -> b` into functions\n-- | `f a -> f b` whose argument and return types use the type constructor `f`\n-- | to represent some computational context.\n-- |\n-- | Instances must satisfy the following laws:\n-- |\n-- | - Identity: `map identity = identity`\n-- | - Composition: `map (f <<< g) = map f <<< map g`\nclass Functor f where\n  map :: forall a b. (a -> b) -> f a -> f b\n\ninfixl 4 map as <$>\n\n-- | `mapFlipped` is `map` with its arguments reversed. For example:\n-- |\n-- | ```purescript\n-- | [1, 2, 3] <#> \\n -> n * n\n-- | ```\nmapFlipped :: forall f a b. Functor f => f a -> (a -> b) -> f b\nmapFlipped fa f = f <$> fa\n\ninfixl 1 mapFlipped as <#>\n\ninstance functorFn :: Functor ((->) r) where\n  map = compose\n\ninstance functorArray :: Functor Array where\n  map = arrayMap\n\ninstance functorProxy :: Functor Proxy where\n  map _ _ = Proxy\n\nforeign import arrayMap :: forall a b. (a -> b) -> Array a -> Array b\n\n-- | The `void` function is used to ignore the type wrapped by a\n-- | [`Functor`](#functor), replacing it with `Unit` and keeping only the type\n-- | information provided by the type constructor itself.\n-- |\n-- | `void` is often useful when using `do` notation to change the return type\n-- | of a monadic computation:\n-- |\n-- | ```purescript\n-- | main = forE 1 10 \\n -> void do\n-- |   print n\n-- |   print (n * n)\n-- | ```\nvoid :: forall f a. Functor f => f a -> f Unit\nvoid = map (const unit)\n\n-- | Ignore the return value of a computation, using the specified return value\n-- | instead.\nvoidRight :: forall f a b. Functor f => a -> f b -> f a\nvoidRight x = map (const x)\n\ninfixl 4 voidRight as <$\n\n-- | A version of `voidRight` with its arguments flipped.\nvoidLeft :: forall f a b. Functor f => f a -> b -> f b\nvoidLeft f x = const x <$> f\n\ninfixl 4 voidLeft as $>\n\n-- | Apply a value in a computational context to a value in no context.\n-- |\n-- | Generalizes `flip`.\n-- |\n-- | ```purescript\n-- | longEnough :: String -> Bool\n-- | hasSymbol :: String -> Bool\n-- | hasDigit :: String -> Bool\n-- | password :: String\n-- |\n-- | validate :: String -> Array Bool\n-- | validate = flap [longEnough, hasSymbol, hasDigit]\n-- | ```\n-- |\n-- | ```purescript\n-- | flap (-) 3 4 == 1\n-- | threeve <$> Just 1 <@> 'a' <*> Just true == Just (threeve 1 'a' true)\n-- | ```\nflap :: forall f a b. Functor f => f (a -> b) -> a -> f b\nflap ff x = map (\\f -> f x) ff\n\ninfixl 4 flap as <@>\n", "export const concatString = function (s1) {\n  return function (s2) {\n    return s1 + s2;\n  };\n};\n\nexport const concatArray = function (xs) {\n  return function (ys) {\n    if (xs.length === 0) return ys;\n    if (ys.length === 0) return xs;\n    return xs.concat(ys);\n  };\n};\n", "module Data.Symbol\n  ( class IsSymbol\n  , reflectSymbol\n  , reifySymbol\n  ) where\n\nimport Type.Proxy (Proxy(..))\n\n-- | A class for known symbols\nclass IsSymbol (sym :: Symbol) where\n  reflectSymbol :: Proxy sym -> String\n\n-- local definition for use in `reifySymbol`\nforeign import unsafeCoerce :: forall a b. a -> b\n\nreifySymbol :: forall r. String -> (forall sym. IsSymbol sym => Proxy sym -> r) -> r\nreifySymbol s f = coerce f { reflectSymbol: \\_ -> s } Proxy\n  where\n  coerce\n    :: (forall sym1. IsSymbol sym1 => Proxy sym1 -> r)\n    -> { reflectSymbol :: Proxy \"\" -> String }\n    -> Proxy \"\"\n    -> r\n  coerce = unsafeCoerce\n", "export const unsafeHas = function (label) {\n  return function (rec) {\n    return {}.hasOwnProperty.call(rec, label);\n  };\n};\n\nexport const unsafeGet = function (label) {\n  return function (rec) {\n    return rec[label];\n  };\n};\n\nexport const unsafeSet = function (label) {\n  return function (value) {\n    return function (rec) {\n      var copy = {};\n      for (var key in rec) {\n        if ({}.hasOwnProperty.call(rec, key)) {\n          copy[key] = rec[key];\n        }\n      }\n      copy[label] = value;\n      return copy;\n    };\n  };\n};\n\nexport const unsafeDelete = function (label) {\n  return function (rec) {\n    var copy = {};\n    for (var key in rec) {\n      if (key !== label && {}.hasOwnProperty.call(rec, key)) {\n        copy[key] = rec[key];\n      }\n    }\n    return copy;\n  };\n};\n", "module Data.Semigroup\n  ( class Semigroup\n  , append\n  , (<>)\n  , class SemigroupRecord\n  , appendRecord\n  ) where\n\nimport Data.Symbol (class IsSymbol, reflectSymbol)\nimport Data.Unit (Unit, unit)\nimport Data.Void (Void, absurd)\nimport Prim.Row as Row\nimport Prim.RowList as RL\nimport Record.Unsafe (unsafeGet, unsafeSet)\nimport Type.Proxy (Proxy(..))\n\n-- | The `Semigroup` type class identifies an associative operation on a type.\n-- |\n-- | Instances are required to satisfy the following law:\n-- |\n-- | - Associativity: `(x <> y) <> z = x <> (y <> z)`\n-- |\n-- | One example of a `Semigroup` is `String`, with `(<>)` defined as string\n-- | concatenation. Another example is `List a`, with `(<>)` defined as\n-- | list concatenation.\n-- |\n-- | ### Newtypes for Semigroup\n-- |\n-- | There are two other ways to implement an instance for this type class\n-- | regardless of which type is used. These instances can be used by\n-- | wrapping the values in one of the two newtypes below:\n-- | 1. `First` - Use the first argument every time: `append first _ = first`.\n-- | 2. `Last` - Use the last argument every time: `append _ last = last`.\nclass Semigroup a where\n  append :: a -> a -> a\n\ninfixr 5 append as <>\n\ninstance semigroupString :: Semigroup String where\n  append = concatString\n\ninstance semigroupUnit :: Semigroup Unit where\n  append _ _ = unit\n\ninstance semigroupVoid :: Semigroup Void where\n  append _ = absurd\n\ninstance semigroupFn :: Semigroup s' => Semigroup (s -> s') where\n  append f g x = f x <> g x\n\ninstance semigroupArray :: Semigroup (Array a) where\n  append = concatArray\n\ninstance semigroupProxy :: Semigroup (Proxy a) where\n  append _ _ = Proxy\n\ninstance semigroupRecord :: (RL.RowToList row list, SemigroupRecord list row row) => Semigroup (Record row) where\n  append = appendRecord (Proxy :: Proxy list)\n\nforeign import concatString :: String -> String -> String\nforeign import concatArray :: forall a. Array a -> Array a -> Array a\n\n-- | A class for records where all fields have `Semigroup` instances, used to\n-- | implement the `Semigroup` instance for records.\nclass SemigroupRecord :: RL.RowList Type -> Row Type -> Row Type -> Constraint\nclass SemigroupRecord rowlist row subrow | rowlist -> subrow where\n  appendRecord :: Proxy rowlist -> Record row -> Record row -> Record subrow\n\ninstance semigroupRecordNil :: SemigroupRecord RL.Nil row () where\n  appendRecord _ _ _ = {}\n\ninstance semigroupRecordCons ::\n  ( IsSymbol key\n  , Row.Cons key focus subrowTail subrow\n  , SemigroupRecord rowlistTail row subrowTail\n  , Semigroup focus\n  ) =>\n  SemigroupRecord (RL.Cons key focus rowlistTail) row subrow where\n  appendRecord _ ra rb = insert (get ra <> get rb) tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    get = unsafeGet key :: Record row -> focus\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n    tail = appendRecord (Proxy :: Proxy rowlistTail) ra rb\n", "module Control.Alt\n  ( class Alt, alt, (<|>)\n  , module Data.Functor\n  ) where\n\nimport Data.Functor (class Functor, map, void, ($>), (<#>), (<$), (<$>))\nimport Data.Semigroup (append)\n\n-- | The `Alt` type class identifies an associative operation on a type\n-- | constructor.  It is similar to `Semigroup`, except that it applies to\n-- | types of kind `* -> *`, like `Array` or `List`, rather than concrete types\n-- | `String` or `Number`.\n-- |\n-- | `Alt` instances are required to satisfy the following laws:\n-- |\n-- | - Associativity: `(x <|> y) <|> z == x <|> (y <|> z)`\n-- | - Distributivity: `f <$> (x <|> y) == (f <$> x) <|> (f <$> y)`\n-- |\n-- | For example, the `Array` (`[]`) type is an instance of `Alt`, where\n-- | `(<|>)` is defined to be concatenation.\n-- |\n-- | A common use case is to select the first \"valid\" item, or, if all items\n-- | are \"invalid\", the last \"invalid\" item.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | import Control.Alt ((<|>))\n-- | import Data.Maybe (Maybe(..)\n-- | import Data.Either (Either(..))\n-- |\n-- | Nothing <|> Just 1 <|> Just 2 == Just 1\n-- | Left \"err\" <|> Right 1 <|> Right 2 == Right 1\n-- | Left \"err 1\" <|> Left \"err 2\" <|> Left \"err 3\" == Left \"err 3\"\n-- | ```\nclass Functor f <= Alt f where\n  alt :: forall a. f a -> f a -> f a\n\ninfixr 3 alt as <|>\n\ninstance altArray :: Alt Array where\n  alt = append\n", "export const arrayApply = function (fs) {\n  return function (xs) {\n    var l = fs.length;\n    var k = xs.length;\n    var result = new Array(l*k);\n    var n = 0;\n    for (var i = 0; i < l; i++) {\n      var f = fs[i];\n      for (var j = 0; j < k; j++) {\n        result[n++] = f(xs[j]);\n      }\n    }\n    return result;\n  };\n};\n", "module Control.Apply\n  ( class Apply\n  , apply\n  , (<*>)\n  , applyFirst\n  , (<*)\n  , applySecond\n  , (*>)\n  , lift2\n  , lift3\n  , lift4\n  , lift5\n  , module Data.Functor\n  ) where\n\nimport Data.Functor (class Functor, map, void, ($>), (<#>), (<$), (<$>))\nimport Data.Function (const)\nimport Control.Category (identity)\nimport Type.Proxy (Proxy(..))\n\n-- | The `Apply` class provides the `(<*>)` which is used to apply a function\n-- | to an argument under a type constructor.\n-- |\n-- | `Apply` can be used to lift functions of two or more arguments to work on\n-- | values wrapped with the type constructor `f`. It might also be understood\n-- | in terms of the `lift2` function:\n-- |\n-- | ```purescript\n-- | lift2 :: forall f a b c. Apply f => (a -> b -> c) -> f a -> f b -> f c\n-- | lift2 f a b = f <$> a <*> b\n-- | ```\n-- |\n-- | `(<*>)` is recovered from `lift2` as `lift2 ($)`. That is, `(<*>)` lifts\n-- | the function application operator `($)` to arguments wrapped with the\n-- | type constructor `f`.\n-- |\n-- | Put differently...\n-- | ```\n-- | foo =\n-- |   functionTakingNArguments <$> computationProducingArg1\n-- |                            <*> computationProducingArg2\n-- |                            <*> ...\n-- |                            <*> computationProducingArgN\n-- | ```\n-- |\n-- | Instances must satisfy the following law in addition to the `Functor`\n-- | laws:\n-- |\n-- | - Associative composition: `(<<<) <$> f <*> g <*> h = f <*> (g <*> h)`\n-- |\n-- | Formally, `Apply` represents a strong lax semi-monoidal endofunctor.\nclass Functor f <= Apply f where\n  apply :: forall a b. f (a -> b) -> f a -> f b\n\ninfixl 4 apply as <*>\n\ninstance applyFn :: Apply ((->) r) where\n  apply f g x = f x (g x)\n\ninstance applyArray :: Apply Array where\n  apply = arrayApply\n\nforeign import arrayApply :: forall a b. Array (a -> b) -> Array a -> Array b\n\ninstance applyProxy :: Apply Proxy where\n  apply _ _ = Proxy\n\n-- | Combine two effectful actions, keeping only the result of the first.\napplyFirst :: forall a b f. Apply f => f a -> f b -> f a\napplyFirst a b = const <$> a <*> b\n\ninfixl 4 applyFirst as <*\n\n-- | Combine two effectful actions, keeping only the result of the second.\napplySecond :: forall a b f. Apply f => f a -> f b -> f b\napplySecond a b = const identity <$> a <*> b\n\ninfixl 4 applySecond as *>\n\n-- | Lift a function of two arguments to a function which accepts and returns\n-- | values wrapped with the type constructor `f`.\n-- |\n-- | ```purescript\n-- | lift2 add (Just 1) (Just 2) == Just 3\n-- | lift2 add Nothing (Just 2) == Nothing\n-- |```\n-- |\nlift2 :: forall a b c f. Apply f => (a -> b -> c) -> f a -> f b -> f c\nlift2 f a b = f <$> a <*> b\n\n-- | Lift a function of three arguments to a function which accepts and returns\n-- | values wrapped with the type constructor `f`.\nlift3 :: forall a b c d f. Apply f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d\nlift3 f a b c = f <$> a <*> b <*> c\n\n-- | Lift a function of four arguments to a function which accepts and returns\n-- | values wrapped with the type constructor `f`.\nlift4 :: forall a b c d e f. Apply f => (a -> b -> c -> d -> e) -> f a -> f b -> f c -> f d -> f e\nlift4 f a b c d = f <$> a <*> b <*> c <*> d\n\n-- | Lift a function of five arguments to a function which accepts and returns\n-- | values wrapped with the type constructor `f`.\nlift5 :: forall a b c d e f g. Apply f => (a -> b -> c -> d -> e -> g) -> f a -> f b -> f c -> f d -> f e -> f g\nlift5 f a b c d e = f <$> a <*> b <*> c <*> d <*> e\n", "module Control.Applicative\n  ( class Applicative\n  , pure\n  , liftA1\n  , unless\n  , when\n  , module Control.Apply\n  , module Data.Functor\n  ) where\n\nimport Control.Apply (class Apply, apply, (*>), (<*), (<*>))\n\nimport Data.Functor (class Functor, map, void, ($>), (<#>), (<$), (<$>))\nimport Data.Unit (Unit, unit)\nimport Type.Proxy (Proxy(..))\n\n-- | The `Applicative` type class extends the [`Apply`](#apply) type class\n-- | with a `pure` function, which can be used to create values of type `f a`\n-- | from values of type `a`.\n-- |\n-- | Where [`Apply`](#apply) provides the ability to lift functions of two or\n-- | more arguments to functions whose arguments are wrapped using `f`, and\n-- | [`Functor`](#functor) provides the ability to lift functions of one\n-- | argument, `pure` can be seen as the function which lifts functions of\n-- | _zero_ arguments. That is, `Applicative` functors support a lifting\n-- | operation for any number of function arguments.\n-- |\n-- | Instances must satisfy the following laws in addition to the `Apply`\n-- | laws:\n-- |\n-- | - Identity: `(pure identity) <*> v = v`\n-- | - Composition: `pure (<<<) <*> f <*> g <*> h = f <*> (g <*> h)`\n-- | - Homomorphism: `(pure f) <*> (pure x) = pure (f x)`\n-- | - Interchange: `u <*> (pure y) = (pure (_ $ y)) <*> u`\nclass Apply f <= Applicative f where\n  pure :: forall a. a -> f a\n\ninstance applicativeFn :: Applicative ((->) r) where\n  pure x _ = x\n\ninstance applicativeArray :: Applicative Array where\n  pure x = [ x ]\n\ninstance applicativeProxy :: Applicative Proxy where\n  pure _ = Proxy\n\n-- | `liftA1` provides a default implementation of `(<$>)` for any\n-- | [`Applicative`](#applicative) functor, without using `(<$>)` as provided\n-- | by the [`Functor`](#functor)-[`Applicative`](#applicative) superclass\n-- | relationship.\n-- |\n-- | `liftA1` can therefore be used to write [`Functor`](#functor) instances\n-- | as follows:\n-- |\n-- | ```purescript\n-- | instance functorF :: Functor F where\n-- |   map = liftA1\n-- | ```\nliftA1 :: forall f a b. Applicative f => (a -> b) -> f a -> f b\nliftA1 f a = pure f <*> a\n\n-- | Perform an applicative action when a condition is true.\nwhen :: forall m. Applicative m => Boolean -> m Unit -> m Unit\nwhen true m = m\nwhen false _ = pure unit\n\n-- | Perform an applicative action unless a condition is true.\nunless :: forall m. Applicative m => Boolean -> m Unit -> m Unit\nunless false m = m\nunless true _ = pure unit\n", "export const topInt = 2147483647;\nexport const bottomInt = -2147483648;\n\nexport const topChar = String.fromCharCode(65535);\nexport const bottomChar = String.fromCharCode(0);\n\nexport const topNumber = Number.POSITIVE_INFINITY;\nexport const bottomNumber = Number.NEGATIVE_INFINITY;\n", "var unsafeCompareImpl = function (lt) {\n  return function (eq) {\n    return function (gt) {\n      return function (x) {\n        return function (y) {\n          return x < y ? lt : x === y ? eq : gt;\n        };\n      };\n    };\n  };\n};\n\nexport const ordBooleanImpl = unsafeCompareImpl;\nexport const ordIntImpl = unsafeCompareImpl;\nexport const ordNumberImpl = unsafeCompareImpl;\nexport const ordStringImpl = unsafeCompareImpl;\nexport const ordCharImpl = unsafeCompareImpl;\n\nexport const ordArrayImpl = function (f) {\n  return function (xs) {\n    return function (ys) {\n      var i = 0;\n      var xlen = xs.length;\n      var ylen = ys.length;\n      while (i < xlen && i < ylen) {\n        var x = xs[i];\n        var y = ys[i];\n        var o = f(x)(y);\n        if (o !== 0) {\n          return o;\n        }\n        i++;\n      }\n      if (xlen === ylen) {\n        return 0;\n      } else if (xlen > ylen) {\n        return -1;\n      } else {\n        return 1;\n      }\n    };\n  };\n};\n", "var refEq = function (r1) {\n  return function (r2) {\n    return r1 === r2;\n  };\n};\n\nexport const eqBooleanImpl = refEq;\nexport const eqIntImpl = refEq;\nexport const eqNumberImpl = refEq;\nexport const eqCharImpl = refEq;\nexport const eqStringImpl = refEq;\n\nexport const eqArrayImpl = function (f) {\n  return function (xs) {\n    return function (ys) {\n      if (xs.length !== ys.length) return false;\n      for (var i = 0; i < xs.length; i++) {\n        if (!f(xs[i])(ys[i])) return false;\n      }\n      return true;\n    };\n  };\n};\n", "module Data.Eq\n  ( class Eq\n  , eq\n  , (==)\n  , notEq\n  , (/=)\n  , class Eq1\n  , eq1\n  , notEq1\n  , class EqRecord\n  , eqRecord\n  ) where\n\nimport Data.HeytingAlgebra ((&&))\nimport Data.Symbol (class IsSymbol, reflectSymbol)\nimport Data.Unit (Unit)\nimport Data.Void (Void)\nimport Prim.Row as Row\nimport Prim.RowList as RL\nimport Record.Unsafe (unsafeGet)\nimport Type.Proxy (Proxy(..))\n\n-- | The `Eq` type class represents types which support decidable equality.\n-- |\n-- | `Eq` instances should satisfy the following laws:\n-- |\n-- | - Reflexivity: `x == x = true`\n-- | - Symmetry: `x == y = y == x`\n-- | - Transitivity: if `x == y` and `y == z` then `x == z`\n-- |\n-- | **Note:** The `Number` type is not an entirely law abiding member of this\n-- | class due to the presence of `NaN`, since `NaN /= NaN`. Additionally,\n-- | computing with `Number` can result in a loss of precision, so sometimes\n-- | values that should be equivalent are not.\nclass Eq a where\n  eq :: a -> a -> Boolean\n\ninfix 4 eq as ==\n\n-- | `notEq` tests whether one value is _not equal_ to another. Shorthand for\n-- | `not (eq x y)`.\nnotEq :: forall a. Eq a => a -> a -> Boolean\nnotEq x y = (x == y) == false\n\ninfix 4 notEq as /=\n\ninstance eqBoolean :: Eq Boolean where\n  eq = eqBooleanImpl\n\ninstance eqInt :: Eq Int where\n  eq = eqIntImpl\n\ninstance eqNumber :: Eq Number where\n  eq = eqNumberImpl\n\ninstance eqChar :: Eq Char where\n  eq = eqCharImpl\n\ninstance eqString :: Eq String where\n  eq = eqStringImpl\n\ninstance eqUnit :: Eq Unit where\n  eq _ _ = true\n\ninstance eqVoid :: Eq Void where\n  eq _ _ = true\n\ninstance eqArray :: Eq a => Eq (Array a) where\n  eq = eqArrayImpl eq\n\ninstance eqRec :: (RL.RowToList row list, EqRecord list row) => Eq (Record row) where\n  eq = eqRecord (Proxy :: Proxy list)\n\ninstance eqProxy :: Eq (Proxy a) where\n  eq _ _ = true\n\nforeign import eqBooleanImpl :: Boolean -> Boolean -> Boolean\nforeign import eqIntImpl :: Int -> Int -> Boolean\nforeign import eqNumberImpl :: Number -> Number -> Boolean\nforeign import eqCharImpl :: Char -> Char -> Boolean\nforeign import eqStringImpl :: String -> String -> Boolean\n\nforeign import eqArrayImpl :: forall a. (a -> a -> Boolean) -> Array a -> Array a -> Boolean\n\n-- | The `Eq1` type class represents type constructors with decidable equality.\nclass Eq1 f where\n  eq1 :: forall a. Eq a => f a -> f a -> Boolean\n\ninstance eq1Array :: Eq1 Array where\n  eq1 = eq\n\nnotEq1 :: forall f a. Eq1 f => Eq a => f a -> f a -> Boolean\nnotEq1 x y = (x `eq1` y) == false\n\n-- | A class for records where all fields have `Eq` instances, used to implement\n-- | the `Eq` instance for records.\nclass EqRecord :: RL.RowList Type -> Row Type -> Constraint\nclass EqRecord rowlist row where\n  eqRecord :: Proxy rowlist -> Record row -> Record row -> Boolean\n\ninstance eqRowNil :: EqRecord RL.Nil row where\n  eqRecord _ _ _ = true\n\ninstance eqRowCons ::\n  ( EqRecord rowlistTail row\n  , Row.Cons key focus rowTail row\n  , IsSymbol key\n  , Eq focus\n  ) =>\n  EqRecord (RL.Cons key focus rowlistTail) row where\n  eqRecord _ ra rb = (get ra == get rb) && tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    get = unsafeGet key :: Record row -> focus\n    tail = eqRecord (Proxy :: Proxy rowlistTail) ra rb\n", "module Data.Ordering (Ordering(..), invert) where\n\nimport Data.Eq (class Eq)\nimport Data.Semigroup (class Semigroup)\nimport Data.Show (class Show)\n\n-- | The `Ordering` data type represents the three possible outcomes of\n-- | comparing two values:\n-- |\n-- | `LT` - The first value is _less than_ the second.\n-- | `GT` - The first value is _greater than_ the second.\n-- | `EQ` - The first value is _equal to_ the second.\ndata Ordering = LT | GT | EQ\n\ninstance eqOrdering :: Eq Ordering where\n  eq LT LT = true\n  eq GT GT = true\n  eq EQ EQ = true\n  eq _ _ = false\n\ninstance semigroupOrdering :: Semigroup Ordering where\n  append LT _ = LT\n  append GT _ = GT\n  append EQ y = y\n\ninstance showOrdering :: Show Ordering where\n  show LT = \"LT\"\n  show GT = \"GT\"\n  show EQ = \"EQ\"\n\n-- | Reverses an `Ordering` value, flipping greater than for less than while\n-- | preserving equality.\ninvert :: Ordering -> Ordering\ninvert GT = LT\ninvert EQ = EQ\ninvert LT = GT\n", "export const intSub = function (x) {\n  return function (y) {\n    /* jshint bitwise: false */\n    return x - y | 0;\n  };\n};\n\nexport const numSub = function (n1) {\n  return function (n2) {\n    return n1 - n2;\n  };\n};\n", "export const intAdd = function (x) {\n  return function (y) {\n    /* jshint bitwise: false */\n    return x + y | 0;\n  };\n};\n\nexport const intMul = function (x) {\n  return function (y) {\n    /* jshint bitwise: false */\n    return x * y | 0;\n  };\n};\n\nexport const numAdd = function (n1) {\n  return function (n2) {\n    return n1 + n2;\n  };\n};\n\nexport const numMul = function (n1) {\n  return function (n2) {\n    return n1 * n2;\n  };\n};\n", "module Data.Semiring\n  ( class Semiring\n  , add\n  , (+)\n  , zero\n  , mul\n  , (*)\n  , one\n  , class SemiringRecord\n  , addRecord\n  , mulRecord\n  , oneRecord\n  , zeroRecord\n  ) where\n\nimport Data.Symbol (class IsSymbol, reflectSymbol)\nimport Data.Unit (Unit, unit)\nimport Prim.Row as Row\nimport Prim.RowList as RL\nimport Record.Unsafe (unsafeGet, unsafeSet)\nimport Type.Proxy (Proxy(..))\n\n-- | The `Semiring` class is for types that support an addition and\n-- | multiplication operation.\n-- |\n-- | Instances must satisfy the following laws:\n-- |\n-- | - Commutative monoid under addition:\n-- |   - Associativity: `(a + b) + c = a + (b + c)`\n-- |   - Identity: `zero + a = a + zero = a`\n-- |   - Commutative: `a + b = b + a`\n-- | - Monoid under multiplication:\n-- |   - Associativity: `(a * b) * c = a * (b * c)`\n-- |   - Identity: `one * a = a * one = a`\n-- | - Multiplication distributes over addition:\n-- |   - Left distributivity: `a * (b + c) = (a * b) + (a * c)`\n-- |   - Right distributivity: `(a + b) * c = (a * c) + (b * c)`\n-- | - Annihilation: `zero * a = a * zero = zero`\n-- |\n-- | **Note:** The `Number` and `Int` types are not fully law abiding\n-- | members of this class hierarchy due to the potential for arithmetic\n-- | overflows, and in the case of `Number`, the presence of `NaN` and\n-- | `Infinity` values. The behaviour is unspecified in these cases.\nclass Semiring a where\n  add :: a -> a -> a\n  zero :: a\n  mul :: a -> a -> a\n  one :: a\n\ninfixl 6 add as +\ninfixl 7 mul as *\n\ninstance semiringInt :: Semiring Int where\n  add = intAdd\n  zero = 0\n  mul = intMul\n  one = 1\n\ninstance semiringNumber :: Semiring Number where\n  add = numAdd\n  zero = 0.0\n  mul = numMul\n  one = 1.0\n\ninstance semiringFn :: Semiring b => Semiring (a -> b) where\n  add f g x = f x + g x\n  zero = \\_ -> zero\n  mul f g x = f x * g x\n  one = \\_ -> one\n\ninstance semiringUnit :: Semiring Unit where\n  add _ _ = unit\n  zero = unit\n  mul _ _ = unit\n  one = unit\n\ninstance semiringProxy :: Semiring (Proxy a) where\n  add _ _ = Proxy\n  mul _ _ = Proxy\n  one = Proxy\n  zero = Proxy\n\ninstance semiringRecord :: (RL.RowToList row list, SemiringRecord list row row) => Semiring (Record row) where\n  add = addRecord (Proxy :: Proxy list)\n  mul = mulRecord (Proxy :: Proxy list)\n  one = oneRecord (Proxy :: Proxy list) (Proxy :: Proxy row)\n  zero = zeroRecord (Proxy :: Proxy list) (Proxy :: Proxy row)\n\nforeign import intAdd :: Int -> Int -> Int\nforeign import intMul :: Int -> Int -> Int\nforeign import numAdd :: Number -> Number -> Number\nforeign import numMul :: Number -> Number -> Number\n\n-- | A class for records where all fields have `Semiring` instances, used to\n-- | implement the `Semiring` instance for records.\nclass SemiringRecord :: RL.RowList Type -> Row Type -> Row Type -> Constraint\nclass SemiringRecord rowlist row subrow | rowlist -> subrow where\n  addRecord :: Proxy rowlist -> Record row -> Record row -> Record subrow\n  mulRecord :: Proxy rowlist -> Record row -> Record row -> Record subrow\n  oneRecord :: Proxy rowlist -> Proxy row -> Record subrow\n  zeroRecord :: Proxy rowlist -> Proxy row -> Record subrow\n\ninstance semiringRecordNil :: SemiringRecord RL.Nil row () where\n  addRecord _ _ _ = {}\n  mulRecord _ _ _ = {}\n  oneRecord _ _ = {}\n  zeroRecord _ _ = {}\n\ninstance semiringRecordCons ::\n  ( IsSymbol key\n  , Row.Cons key focus subrowTail subrow\n  , SemiringRecord rowlistTail row subrowTail\n  , Semiring focus\n  ) =>\n  SemiringRecord (RL.Cons key focus rowlistTail) row subrow where\n  addRecord _ ra rb = insert (get ra + get rb) tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    get = unsafeGet key :: Record row -> focus\n    tail = addRecord (Proxy :: Proxy rowlistTail) ra rb\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n\n  mulRecord _ ra rb = insert (get ra * get rb) tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    get = unsafeGet key :: Record row -> focus\n    tail = mulRecord (Proxy :: Proxy rowlistTail) ra rb\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n\n  oneRecord _ _ = insert one tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    tail = oneRecord (Proxy :: Proxy rowlistTail) (Proxy :: Proxy row)\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n\n  zeroRecord _ _ = insert zero tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    tail = zeroRecord (Proxy :: Proxy rowlistTail) (Proxy :: Proxy row)\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n", "module Data.Ring\n  ( class Ring\n  , sub\n  , negate\n  , (-)\n  , module Data.Semiring\n  , class RingRecord\n  , subRecord\n  ) where\n\nimport Data.Semiring (class Semiring, class SemiringRecord, add, mul, one, zero, (*), (+))\nimport Data.Symbol (class IsSymbol, reflectSymbol)\nimport Data.Unit (Unit, unit)\nimport Prim.Row as Row\nimport Prim.RowList as RL\nimport Record.Unsafe (unsafeGet, unsafeSet)\nimport Type.Proxy (Proxy(..))\n\n-- | The `Ring` class is for types that support addition, multiplication,\n-- | and subtraction operations.\n-- |\n-- | Instances must satisfy the following laws in addition to the `Semiring`\n-- | laws:\n-- |\n-- | - Additive inverse: `a - a = zero`\n-- | - Compatibility of `sub` and `negate`: `a - b = a + (zero - b)`\nclass Semiring a <= Ring a where\n  sub :: a -> a -> a\n\ninfixl 6 sub as -\n\ninstance ringInt :: Ring Int where\n  sub = intSub\n\ninstance ringNumber :: Ring Number where\n  sub = numSub\n\ninstance ringUnit :: Ring Unit where\n  sub _ _ = unit\n\ninstance ringFn :: Ring b => Ring (a -> b) where\n  sub f g x = f x - g x\n\ninstance ringProxy :: Ring (Proxy a) where\n  sub _ _ = Proxy\n\ninstance ringRecord :: (RL.RowToList row list, RingRecord list row row) => Ring (Record row) where\n  sub = subRecord (Proxy :: Proxy list)\n\n-- | `negate x` can be used as a shorthand for `zero - x`.\nnegate :: forall a. Ring a => a -> a\nnegate a = zero - a\n\nforeign import intSub :: Int -> Int -> Int\nforeign import numSub :: Number -> Number -> Number\n\n-- | A class for records where all fields have `Ring` instances, used to\n-- | implement the `Ring` instance for records.\nclass RingRecord :: RL.RowList Type -> Row Type -> Row Type -> Constraint\nclass SemiringRecord rowlist row subrow <= RingRecord rowlist row subrow | rowlist -> subrow where\n  subRecord :: Proxy rowlist -> Record row -> Record row -> Record subrow\n\ninstance ringRecordNil :: RingRecord RL.Nil row () where\n  subRecord _ _ _ = {}\n\ninstance ringRecordCons ::\n  ( IsSymbol key\n  , Row.Cons key focus subrowTail subrow\n  , RingRecord rowlistTail row subrowTail\n  , Ring focus\n  ) =>\n  RingRecord (RL.Cons key focus rowlistTail) row subrow where\n  subRecord _ ra rb = insert (get ra - get rb) tail\n    where\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n    key = reflectSymbol (Proxy :: Proxy key)\n    get = unsafeGet key :: Record row -> focus\n    tail = subRecord (Proxy :: Proxy rowlistTail) ra rb\n", "module Data.Ord\n  ( class Ord\n  , compare\n  , class Ord1\n  , compare1\n  , lessThan\n  , (<)\n  , lessThanOrEq\n  , (<=)\n  , greaterThan\n  , (>)\n  , greaterThanOrEq\n  , (>=)\n  , comparing\n  , min\n  , max\n  , clamp\n  , between\n  , abs\n  , signum\n  , module Data.Ordering\n  , class OrdRecord\n  , compareRecord\n  ) where\n\nimport Data.Eq (class Eq, class Eq1, class EqRecord, (/=))\nimport Data.Symbol (class IsSymbol, reflectSymbol)\nimport Data.Ordering (Ordering(..))\nimport Data.Ring (class Ring, zero, one, negate)\nimport Data.Unit (Unit)\nimport Data.Void (Void)\nimport Prim.Row as Row\nimport Prim.RowList as RL\nimport Record.Unsafe (unsafeGet)\nimport Type.Proxy (Proxy(..))\n\n-- | The `Ord` type class represents types which support comparisons with a\n-- | _total order_.\n-- |\n-- | `Ord` instances should satisfy the laws of total orderings:\n-- |\n-- | - Reflexivity: `a <= a`\n-- | - Antisymmetry: if `a <= b` and `b <= a` then `a == b`\n-- | - Transitivity: if `a <= b` and `b <= c` then `a <= c`\n-- |\n-- | **Note:** The `Number` type is not an entirely law abiding member of this\n-- | class due to the presence of `NaN`, since `NaN <= NaN` evaluates to `false`\nclass Eq a <= Ord a where\n  compare :: a -> a -> Ordering\n\ninstance ordBoolean :: Ord Boolean where\n  compare = ordBooleanImpl LT EQ GT\n\ninstance ordInt :: Ord Int where\n  compare = ordIntImpl LT EQ GT\n\ninstance ordNumber :: Ord Number where\n  compare = ordNumberImpl LT EQ GT\n\ninstance ordString :: Ord String where\n  compare = ordStringImpl LT EQ GT\n\ninstance ordChar :: Ord Char where\n  compare = ordCharImpl LT EQ GT\n\ninstance ordUnit :: Ord Unit where\n  compare _ _ = EQ\n\ninstance ordVoid :: Ord Void where\n  compare _ _ = EQ\n\ninstance ordProxy :: Ord (Proxy a) where\n  compare _ _ = EQ\n\ninstance ordArray :: Ord a => Ord (Array a) where\n  compare = \\xs ys -> compare 0 (ordArrayImpl toDelta xs ys)\n    where\n    toDelta x y =\n      case compare x y of\n        EQ -> 0\n        LT -> 1\n        GT -> -1\n\nforeign import ordBooleanImpl\n  :: Ordering\n  -> Ordering\n  -> Ordering\n  -> Boolean\n  -> Boolean\n  -> Ordering\n\nforeign import ordIntImpl\n  :: Ordering\n  -> Ordering\n  -> Ordering\n  -> Int\n  -> Int\n  -> Ordering\n\nforeign import ordNumberImpl\n  :: Ordering\n  -> Ordering\n  -> Ordering\n  -> Number\n  -> Number\n  -> Ordering\n\nforeign import ordStringImpl\n  :: Ordering\n  -> Ordering\n  -> Ordering\n  -> String\n  -> String\n  -> Ordering\n\nforeign import ordCharImpl\n  :: Ordering\n  -> Ordering\n  -> Ordering\n  -> Char\n  -> Char\n  -> Ordering\n\nforeign import ordArrayImpl :: forall a. (a -> a -> Int) -> Array a -> Array a -> Int\n\ninstance ordOrdering :: Ord Ordering where\n  compare LT LT = EQ\n  compare EQ EQ = EQ\n  compare GT GT = EQ\n  compare LT _ = LT\n  compare EQ LT = GT\n  compare EQ GT = LT\n  compare GT _ = GT\n\n-- | Test whether one value is _strictly less than_ another.\nlessThan :: forall a. Ord a => a -> a -> Boolean\nlessThan a1 a2 = case a1 `compare` a2 of\n  LT -> true\n  _ -> false\n\n-- | Test whether one value is _strictly greater than_ another.\ngreaterThan :: forall a. Ord a => a -> a -> Boolean\ngreaterThan a1 a2 = case a1 `compare` a2 of\n  GT -> true\n  _ -> false\n\n-- | Test whether one value is _non-strictly less than_ another.\nlessThanOrEq :: forall a. Ord a => a -> a -> Boolean\nlessThanOrEq a1 a2 = case a1 `compare` a2 of\n  GT -> false\n  _ -> true\n\n-- | Test whether one value is _non-strictly greater than_ another.\ngreaterThanOrEq :: forall a. Ord a => a -> a -> Boolean\ngreaterThanOrEq a1 a2 = case a1 `compare` a2 of\n  LT -> false\n  _ -> true\n\ninfixl 4 lessThan as <\ninfixl 4 lessThanOrEq as <=\ninfixl 4 greaterThan as >\ninfixl 4 greaterThanOrEq as >=\n\n-- | Compares two values by mapping them to a type with an `Ord` instance.\ncomparing :: forall a b. Ord b => (a -> b) -> (a -> a -> Ordering)\ncomparing f x y = compare (f x) (f y)\n\n-- | Take the minimum of two values. If they are considered equal, the first\n-- | argument is chosen.\nmin :: forall a. Ord a => a -> a -> a\nmin x y =\n  case compare x y of\n    LT -> x\n    EQ -> x\n    GT -> y\n\n-- | Take the maximum of two values. If they are considered equal, the first\n-- | argument is chosen.\nmax :: forall a. Ord a => a -> a -> a\nmax x y =\n  case compare x y of\n    LT -> y\n    EQ -> x\n    GT -> x\n\n-- | Clamp a value between a minimum and a maximum. For example:\n-- |\n-- | ``` purescript\n-- | let f = clamp 0 10\n-- | f (-5) == 0\n-- | f 5    == 5\n-- | f 15   == 10\n-- | ```\nclamp :: forall a. Ord a => a -> a -> a -> a\nclamp low hi x = min hi (max low x)\n\n-- | Test whether a value is between a minimum and a maximum (inclusive).\n-- | For example:\n-- |\n-- | ``` purescript\n-- | let f = between 0 10\n-- | f 0    == true\n-- | f (-5) == false\n-- | f 5    == true\n-- | f 10   == true\n-- | f 15   == false\n-- | ```\nbetween :: forall a. Ord a => a -> a -> a -> Boolean\nbetween low hi x\n  | x < low = false\n  | x > hi = false\n  | true = true\n\n-- | The absolute value function. `abs x` is defined as `if x >= zero then x\n-- | else negate x`.\nabs :: forall a. Ord a => Ring a => a -> a\nabs x = if x >= zero then x else negate x\n\n-- | The sign function; returns `one` if the argument is positive,\n-- | `negate one` if the argument is negative, or `zero` if the argument is `zero`.\n-- | For floating point numbers with signed zeroes, when called with a zero,\n-- | this function returns the argument in order to preserve the sign.\n-- | For any `x`, we should have `signum x * abs x == x`.\nsignum :: forall a. Ord a => Ring a => a -> a\nsignum x =\n  if x < zero then negate one\n  else if x > zero then one\n  else x\n\n-- | The `Ord1` type class represents totally ordered type constructors.\nclass Eq1 f <= Ord1 f where\n  compare1 :: forall a. Ord a => f a -> f a -> Ordering\n\ninstance ord1Array :: Ord1 Array where\n  compare1 = compare\n\nclass OrdRecord :: RL.RowList Type -> Row Type -> Constraint\nclass EqRecord rowlist row <= OrdRecord rowlist row where\n  compareRecord :: Proxy rowlist -> Record row -> Record row -> Ordering\n\ninstance ordRecordNil :: OrdRecord RL.Nil row where\n  compareRecord _ _ _ = EQ\n\ninstance ordRecordCons ::\n  ( OrdRecord rowlistTail row\n  , Row.Cons key focus rowTail row\n  , IsSymbol key\n  , Ord focus\n  ) =>\n  OrdRecord (RL.Cons key focus rowlistTail) row where\n  compareRecord _ ra rb =\n    if left /= EQ then left\n    else compareRecord (Proxy :: Proxy rowlistTail) ra rb\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    unsafeGet' = unsafeGet :: String -> Record row -> focus\n    left = unsafeGet' key ra `compare` unsafeGet' key rb\n\ninstance ordRecord ::\n  ( RL.RowToList row list\n  , OrdRecord list row\n  ) =>\n  Ord (Record row) where\n  compare = compareRecord (Proxy :: Proxy list)\n", "module Data.Bounded\n  ( class Bounded\n  , bottom\n  , top\n  , module Data.Ord\n  , class BoundedRecord\n  , bottomRecord\n  , topRecord\n  ) where\n\nimport Data.Ord (class Ord, class OrdRecord, Ordering(..), compare, (<), (<=), (>), (>=))\nimport Data.Symbol (class IsSymbol, reflectSymbol)\nimport Data.Unit (Unit, unit)\nimport Prim.Row as Row\nimport Prim.RowList as RL\nimport Record.Unsafe (unsafeSet)\nimport Type.Proxy (Proxy(..))\n\n-- | The `Bounded` type class represents totally ordered types that have an\n-- | upper and lower boundary.\n-- |\n-- | Instances should satisfy the following law in addition to the `Ord` laws:\n-- |\n-- | - Bounded: `bottom <= a <= top`\nclass Ord a <= Bounded a where\n  top :: a\n  bottom :: a\n\ninstance boundedBoolean :: Bounded Boolean where\n  top = true\n  bottom = false\n\n-- | The `Bounded` `Int` instance has `top :: Int` equal to 2^31 - 1,\n-- | and `bottom :: Int` equal to -2^31, since these are the largest and smallest\n-- | integers representable by twos-complement 32-bit integers, respectively.\ninstance boundedInt :: Bounded Int where\n  top = topInt\n  bottom = bottomInt\n\nforeign import topInt :: Int\nforeign import bottomInt :: Int\n\n-- | Characters fall within the Unicode range.\ninstance boundedChar :: Bounded Char where\n  top = topChar\n  bottom = bottomChar\n\nforeign import topChar :: Char\nforeign import bottomChar :: Char\n\ninstance boundedOrdering :: Bounded Ordering where\n  top = GT\n  bottom = LT\n\ninstance boundedUnit :: Bounded Unit where\n  top = unit\n  bottom = unit\n\nforeign import topNumber :: Number\nforeign import bottomNumber :: Number\n\ninstance boundedNumber :: Bounded Number where\n  top = topNumber\n  bottom = bottomNumber\n\ninstance boundedProxy :: Bounded (Proxy a) where\n  bottom = Proxy\n  top = Proxy\n\nclass BoundedRecord :: RL.RowList Type -> Row Type -> Row Type -> Constraint\nclass OrdRecord rowlist row <= BoundedRecord rowlist row subrow | rowlist -> subrow where\n  topRecord :: Proxy rowlist -> Proxy row -> Record subrow\n  bottomRecord :: Proxy rowlist -> Proxy row -> Record subrow\n\ninstance boundedRecordNil :: BoundedRecord RL.Nil row () where\n  topRecord _ _ = {}\n  bottomRecord _ _ = {}\n\ninstance boundedRecordCons ::\n  ( IsSymbol key\n  , Bounded focus\n  , Row.Cons key focus rowTail row\n  , Row.Cons key focus subrowTail subrow\n  , BoundedRecord rowlistTail row subrowTail\n  ) =>\n  BoundedRecord (RL.Cons key focus rowlistTail) row subrow where\n  topRecord _ rowProxy = insert top tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n    tail = topRecord (Proxy :: Proxy rowlistTail) rowProxy\n\n  bottomRecord _ rowProxy = insert bottom tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n    tail = bottomRecord (Proxy :: Proxy rowlistTail) rowProxy\n\ninstance boundedRecord ::\n  ( RL.RowToList row list\n  , BoundedRecord list row row\n  ) =>\n  Bounded (Record row) where\n  top = topRecord (Proxy :: Proxy list) (Proxy :: Proxy row)\n  bottom = bottomRecord (Proxy :: Proxy list) (Proxy :: Proxy row)\n", "export const showIntImpl = function (n) {\n  return n.toString();\n};\n\nexport const showNumberImpl = function (n) {\n  var str = n.toString();\n  return isNaN(str + \".0\") ? str : str + \".0\";\n};\n\nexport const showCharImpl = function (c) {\n  var code = c.charCodeAt(0);\n  if (code < 0x20 || code === 0x7F) {\n    switch (c) {\n      case \"\\x07\": return \"'\\\\a'\";\n      case \"\\b\": return \"'\\\\b'\";\n      case \"\\f\": return \"'\\\\f'\";\n      case \"\\n\": return \"'\\\\n'\";\n      case \"\\r\": return \"'\\\\r'\";\n      case \"\\t\": return \"'\\\\t'\";\n      case \"\\v\": return \"'\\\\v'\";\n    }\n    return \"'\\\\\" + code.toString(10) + \"'\";\n  }\n  return c === \"'\" || c === \"\\\\\" ? \"'\\\\\" + c + \"'\" : \"'\" + c + \"'\";\n};\n\nexport const showStringImpl = function (s) {\n  var l = s.length;\n  return \"\\\"\" + s.replace(\n    /[\\0-\\x1F\\x7F\"\\\\]/g, // eslint-disable-line no-control-regex\n    function (c, i) {\n      switch (c) {\n        case \"\\\"\":\n        case \"\\\\\":\n          return \"\\\\\" + c;\n        case \"\\x07\": return \"\\\\a\";\n        case \"\\b\": return \"\\\\b\";\n        case \"\\f\": return \"\\\\f\";\n        case \"\\n\": return \"\\\\n\";\n        case \"\\r\": return \"\\\\r\";\n        case \"\\t\": return \"\\\\t\";\n        case \"\\v\": return \"\\\\v\";\n      }\n      var k = i + 1;\n      var empty = k < l && s[k] >= \"0\" && s[k] <= \"9\" ? \"\\\\&\" : \"\";\n      return \"\\\\\" + c.charCodeAt(0).toString(10) + empty;\n    }\n  ) + \"\\\"\";\n};\n\nexport const showArrayImpl = function (f) {\n  return function (xs) {\n    var ss = [];\n    for (var i = 0, l = xs.length; i < l; i++) {\n      ss[i] = f(xs[i]);\n    }\n    return \"[\" + ss.join(\",\") + \"]\";\n  };\n};\n", "module Data.Show\n  ( class Show\n  , show\n  , class ShowRecordFields\n  , showRecordFields\n  ) where\n\nimport Data.Semigroup ((<>))\nimport Data.Symbol (class IsSymbol, reflectSymbol)\nimport Data.Unit (Unit)\nimport Data.Void (Void, absurd)\nimport Prim.Row (class Nub)\nimport Prim.RowList as RL\nimport Record.Unsafe (unsafeGet)\nimport Type.Proxy (Proxy(..))\n\n-- | The `Show` type class represents those types which can be converted into\n-- | a human-readable `String` representation.\n-- |\n-- | While not required, it is recommended that for any expression `x`, the\n-- | string `show x` be executable PureScript code which evaluates to the same\n-- | value as the expression `x`.\nclass Show a where\n  show :: a -> String\n\ninstance showUnit :: Show Unit where\n  show _ = \"unit\"\n\ninstance showBoolean :: Show Boolean where\n  show true = \"true\"\n  show false = \"false\"\n\ninstance showInt :: Show Int where\n  show = showIntImpl\n\ninstance showNumber :: Show Number where\n  show = showNumberImpl\n\ninstance showChar :: Show Char where\n  show = showCharImpl\n\ninstance showString :: Show String where\n  show = showStringImpl\n\ninstance showArray :: Show a => Show (Array a) where\n  show = showArrayImpl show\n\ninstance showProxy :: Show (Proxy a) where\n  show _ = \"Proxy\"\n\ninstance showVoid :: Show Void where\n  show = absurd\n\ninstance showRecord ::\n  ( Nub rs rs\n  , RL.RowToList rs ls\n  , ShowRecordFields ls rs\n  ) =>\n  Show (Record rs) where\n  show record = \"{\" <> showRecordFields (Proxy :: Proxy ls) record <> \"}\"\n\n-- | A class for records where all fields have `Show` instances, used to\n-- | implement the `Show` instance for records.\nclass ShowRecordFields :: RL.RowList Type -> Row Type -> Constraint\nclass ShowRecordFields rowlist row where\n  showRecordFields :: Proxy rowlist -> Record row -> String\n\ninstance showRecordFieldsNil :: ShowRecordFields RL.Nil row where\n  showRecordFields _ _ = \"\"\nelse\ninstance showRecordFieldsConsNil ::\n  ( IsSymbol key\n  , Show focus\n  ) =>\n  ShowRecordFields (RL.Cons key focus RL.Nil) row where\n  showRecordFields _ record = \" \" <> key <> \": \" <> show focus <> \" \"\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    focus = unsafeGet key record :: focus\nelse\ninstance showRecordFieldsCons ::\n  ( IsSymbol key\n  , ShowRecordFields rowlistTail row\n  , Show focus\n  ) =>\n  ShowRecordFields (RL.Cons key focus rowlistTail) row where\n  showRecordFields _ record = \" \" <> key <> \": \" <> show focus <> \",\" <> tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    focus = unsafeGet key record :: focus\n    tail = showRecordFields (Proxy :: Proxy rowlistTail) record\n\nforeign import showIntImpl :: Int -> String\nforeign import showNumberImpl :: Number -> String\nforeign import showCharImpl :: Char -> String\nforeign import showStringImpl :: String -> String\nforeign import showArrayImpl :: forall a. (a -> String) -> Array a -> String\n", "module Data.Maybe where\n\nimport Prelude\n\nimport Control.Alt (class Alt, (<|>))\nimport Control.Alternative (class Alternative)\nimport Control.Extend (class Extend)\nimport Control.Plus (class Plus)\n\nimport Data.Eq (class Eq1)\nimport Data.Functor.Invariant (class Invariant, imapF)\nimport Data.Generic.Rep (class Generic)\nimport Data.Ord (class Ord1)\n\n-- | The `Maybe` type is used to represent optional values and can be seen as\n-- | something like a type-safe `null`, where `Nothing` is `null` and `Just x`\n-- | is the non-null value `x`.\ndata Maybe a = Nothing | Just a\n\n-- | The `Functor` instance allows functions to transform the contents of a\n-- | `Just` with the `<$>` operator:\n-- |\n-- | ``` purescript\n-- | f <$> Just x == Just (f x)\n-- | ```\n-- |\n-- | `Nothing` values are left untouched:\n-- |\n-- | ``` purescript\n-- | f <$> Nothing == Nothing\n-- | ```\ninstance functorMaybe :: Functor Maybe where\n  map fn (Just x) = Just (fn x)\n  map _  _        = Nothing\n\n-- | The `Apply` instance allows functions contained within a `Just` to\n-- | transform a value contained within a `Just` using the `apply` operator:\n-- |\n-- | ``` purescript\n-- | Just f <*> Just x == Just (f x)\n-- | ```\n-- |\n-- | `Nothing` values are left untouched:\n-- |\n-- | ``` purescript\n-- | Just f <*> Nothing == Nothing\n-- | Nothing <*> Just x == Nothing\n-- | ```\n-- |\n-- | Combining `Functor`'s `<$>` with `Apply`'s `<*>` can be used transform a\n-- | pure function to take `Maybe`-typed arguments so `f :: a -> b -> c`\n-- | becomes `f :: Maybe a -> Maybe b -> Maybe c`:\n-- |\n-- | ``` purescript\n-- | f <$> Just x <*> Just y == Just (f x y)\n-- | ```\n-- |\n-- | The `Nothing`-preserving behaviour of both operators means the result of\n-- | an expression like the above but where any one of the values is `Nothing`\n-- | means the whole result becomes `Nothing` also:\n-- |\n-- | ``` purescript\n-- | f <$> Nothing <*> Just y == Nothing\n-- | f <$> Just x <*> Nothing == Nothing\n-- | f <$> Nothing <*> Nothing == Nothing\n-- | ```\ninstance applyMaybe :: Apply Maybe where\n  apply (Just fn) x = fn <$> x\n  apply Nothing   _ = Nothing\n\n-- | The `Applicative` instance enables lifting of values into `Maybe` with the\n-- | `pure` function:\n-- |\n-- | ``` purescript\n-- | pure x :: Maybe _ == Just x\n-- | ```\n-- |\n-- | Combining `Functor`'s `<$>` with `Apply`'s `<*>` and `Applicative`'s\n-- | `pure` can be used to pass a mixture of `Maybe` and non-`Maybe` typed\n-- | values to a function that does not usually expect them, by using `pure`\n-- | for any value that is not already `Maybe` typed:\n-- |\n-- | ``` purescript\n-- | f <$> Just x <*> pure y == Just (f x y)\n-- | ```\n-- |\n-- | Even though `pure = Just` it is recommended to use `pure` in situations\n-- | like this as it allows the choice of `Applicative` to be changed later\n-- | without having to go through and replace `Just` with a new constructor.\ninstance applicativeMaybe :: Applicative Maybe where\n  pure = Just\n\n-- | The `Alt` instance allows for a choice to be made between two `Maybe`\n-- | values with the `<|>` operator, where the first `Just` encountered\n-- | is taken.\n-- |\n-- | ``` purescript\n-- | Just x <|> Just y == Just x\n-- | Nothing <|> Just y == Just y\n-- | Nothing <|> Nothing == Nothing\n-- | ```\ninstance altMaybe :: Alt Maybe where\n  alt Nothing r = r\n  alt l       _ = l\n\n-- | The `Plus` instance provides a default `Maybe` value:\n-- |\n-- | ``` purescript\n-- | empty :: Maybe _ == Nothing\n-- | ```\ninstance plusMaybe :: Plus Maybe where\n  empty = Nothing\n\n-- | The `Alternative` instance guarantees that there are both `Applicative` and\n-- | `Plus` instances for `Maybe`.\ninstance alternativeMaybe :: Alternative Maybe\n\n-- | The `Bind` instance allows sequencing of `Maybe` values and functions that\n-- | return a `Maybe` by using the `>>=` operator:\n-- |\n-- | ``` purescript\n-- | Just x >>= f = f x\n-- | Nothing >>= f = Nothing\n-- | ```\ninstance bindMaybe :: Bind Maybe where\n  bind (Just x) k = k x\n  bind Nothing  _ = Nothing\n\n-- | The `Monad` instance guarantees that there are both `Applicative` and\n-- | `Bind` instances for `Maybe`. This also enables the `do` syntactic sugar:\n-- |\n-- | ``` purescript\n-- | do\n-- |   x' <- x\n-- |   y' <- y\n-- |   pure (f x' y')\n-- | ```\n-- |\n-- | Which is equivalent to:\n-- |\n-- | ``` purescript\n-- | x >>= (\\x' -> y >>= (\\y' -> pure (f x' y')))\n-- | ```\n-- |\n-- | Which is equivalent to:\n-- |\n-- | ``` purescript\n-- | case x of\n-- |   Nothing -> Nothing\n-- |   Just x' -> case y of\n-- |     Nothing -> Nothing\n-- |     Just y' -> Just (f x' y')\n-- | ```\ninstance monadMaybe :: Monad Maybe\n\n-- | The `Extend` instance allows sequencing of `Maybe` values and functions\n-- | that accept a `Maybe a` and return a non-`Maybe` result using the\n-- | `<<=` operator.\n-- |\n-- | ``` purescript\n-- | f <<= Nothing = Nothing\n-- | f <<= x = Just (f x)\n-- | ```\ninstance extendMaybe :: Extend Maybe where\n  extend _ Nothing  = Nothing\n  extend f x        = Just (f x)\n\ninstance invariantMaybe :: Invariant Maybe where\n  imap = imapF\n\n-- | The `Semigroup` instance enables use of the operator `<>` on `Maybe` values\n-- | whenever there is a `Semigroup` instance for the type the `Maybe` contains.\n-- | The exact behaviour of `<>` depends on the \"inner\" `Semigroup` instance,\n-- | but generally captures the notion of appending or combining things.\n-- |\n-- | ``` purescript\n-- | Just x <> Just y = Just (x <> y)\n-- | Just x <> Nothing = Just x\n-- | Nothing <> Just y = Just y\n-- | Nothing <> Nothing = Nothing\n-- | ```\ninstance semigroupMaybe :: Semigroup a => Semigroup (Maybe a) where\n  append Nothing y = y\n  append x Nothing = x\n  append (Just x) (Just y) = Just (x <> y)\n\ninstance monoidMaybe :: Semigroup a => Monoid (Maybe a) where\n  mempty = Nothing\n\ninstance semiringMaybe :: Semiring a => Semiring (Maybe a) where\n  zero = Nothing\n  one = Just one\n\n  add Nothing y = y\n  add x Nothing = x\n  add (Just x) (Just y) = Just (add x y)\n\n  mul x y = mul <$> x <*> y\n\n-- | The `Eq` instance allows `Maybe` values to be checked for equality with\n-- | `==` and inequality with `/=` whenever there is an `Eq` instance for the\n-- | type the `Maybe` contains.\nderive instance eqMaybe :: Eq a => Eq (Maybe a)\n\ninstance eq1Maybe :: Eq1 Maybe where eq1 = eq\n\n-- | The `Ord` instance allows `Maybe` values to be compared with\n-- | `compare`, `>`, `>=`, `<` and `<=` whenever there is an `Ord` instance for\n-- | the type the `Maybe` contains.\n-- |\n-- | `Nothing` is considered to be less than any `Just` value.\nderive instance ordMaybe :: Ord a => Ord (Maybe a)\n\ninstance ord1Maybe :: Ord1 Maybe where compare1 = compare\n\ninstance boundedMaybe :: Bounded a => Bounded (Maybe a) where\n  top = Just top\n  bottom = Nothing\n\n-- | The `Show` instance allows `Maybe` values to be rendered as a string with\n-- | `show` whenever there is an `Show` instance for the type the `Maybe`\n-- | contains.\ninstance showMaybe :: Show a => Show (Maybe a) where\n  show (Just x) = \"(Just \" <> show x <> \")\"\n  show Nothing  = \"Nothing\"\n\nderive instance genericMaybe :: Generic (Maybe a) _\n\n-- | Takes a default value, a function, and a `Maybe` value. If the `Maybe`\n-- | value is `Nothing` the default value is returned, otherwise the function\n-- | is applied to the value inside the `Just` and the result is returned.\n-- |\n-- | ``` purescript\n-- | maybe x f Nothing == x\n-- | maybe x f (Just y) == f y\n-- | ```\nmaybe :: forall a b. b -> (a -> b) -> Maybe a -> b\nmaybe b _ Nothing = b\nmaybe _ f (Just a) = f a\n\n-- | Similar to `maybe` but for use in cases where the default value may be\n-- | expensive to compute. As PureScript is not lazy, the standard `maybe` has\n-- | to evaluate the default value before returning the result, whereas here\n-- | the value is only computed when the `Maybe` is known to be `Nothing`.\n-- |\n-- | ``` purescript\n-- | maybe' (\\_ -> x) f Nothing == x\n-- | maybe' (\\_ -> x) f (Just y) == f y\n-- | ```\nmaybe' :: forall a b. (Unit -> b) -> (a -> b) -> Maybe a -> b\nmaybe' g _ Nothing = g unit\nmaybe' _ f (Just a) = f a\n\n-- | Takes a default value, and a `Maybe` value. If the `Maybe` value is\n-- | `Nothing` the default value is returned, otherwise the value inside the\n-- | `Just` is returned.\n-- |\n-- | ``` purescript\n-- | fromMaybe x Nothing == x\n-- | fromMaybe x (Just y) == y\n-- | ```\nfromMaybe :: forall a. a -> Maybe a -> a\nfromMaybe a = maybe a identity\n\n-- | Similar to `fromMaybe` but for use in cases where the default value may be\n-- | expensive to compute. As PureScript is not lazy, the standard `fromMaybe`\n-- | has to evaluate the default value before returning the result, whereas here\n-- | the value is only computed when the `Maybe` is known to be `Nothing`.\n-- |\n-- | ``` purescript\n-- | fromMaybe' (\\_ -> x) Nothing == x\n-- | fromMaybe' (\\_ -> x) (Just y) == y\n-- | ```\nfromMaybe' :: forall a. (Unit -> a) -> Maybe a -> a\nfromMaybe' a = maybe' a identity\n\n-- | Returns `true` when the `Maybe` value was constructed with `Just`.\nisJust :: forall a. Maybe a -> Boolean\nisJust = maybe false (const true)\n\n-- | Returns `true` when the `Maybe` value is `Nothing`.\nisNothing :: forall a. Maybe a -> Boolean\nisNothing = maybe true (const false)\n\n-- | A partial function that extracts the value from the `Just` data\n-- | constructor. Passing `Nothing` to `fromJust` will throw an error at\n-- | runtime.\nfromJust :: forall a. Partial => Maybe a -> a\nfromJust (Just x) = x\n\n-- | One or none.\n-- |\n-- | ```purescript\n-- | optional empty = pure Nothing\n-- | ```\n-- |\n-- | The behaviour of `optional (pure x)` depends on whether the `Alt` instance\n-- | satisfy the left catch law (`pure a <|> b = pure a`).\n-- |\n-- | `Either e` does:\n-- |\n-- | ```purescript\n-- | optional (Right x) = Right (Just x)\n-- | ```\n-- |\n-- | But `Array` does not:\n-- |\n-- | ```purescript\n-- | optional [x] = [Just x, Nothing]\n-- | ```\noptional :: forall f a. Alt f => Applicative f => f a -> f (Maybe a)\noptional a = map Just a <|> pure Nothing\n", "/* globals setImmediate, clearImmediate, setTimeout, clearTimeout */\n/* eslint-disable no-unused-vars, no-prototype-builtins, no-use-before-define, no-unused-labels, no-param-reassign */\nvar Aff = function () {\n  // A unique value for empty.\n  var EMPTY = {};\n\n  /*\n\n  An awkward approximation. We elide evidence we would otherwise need in PS for\n  efficiency sake.\n\n  data Aff eff a\n    = Pure a\n    | Throw Error\n    | Catch (Aff eff a) (Error -> Aff eff a)\n    | Sync (Eff eff a)\n    | Async ((Either Error a -> Eff eff Unit) -> Eff eff (Canceler eff))\n    | forall b. Bind (Aff eff b) (b -> Aff eff a)\n    | forall b. Bracket (Aff eff b) (BracketConditions eff b) (b -> Aff eff a)\n    | forall b. Fork Boolean (Aff eff b) ?(Fiber eff b -> a)\n    | Sequential (ParAff aff a)\n\n  */\n  var PURE    = \"Pure\";\n  var THROW   = \"Throw\";\n  var CATCH   = \"Catch\";\n  var SYNC    = \"Sync\";\n  var ASYNC   = \"Async\";\n  var BIND    = \"Bind\";\n  var BRACKET = \"Bracket\";\n  var FORK    = \"Fork\";\n  var SEQ     = \"Sequential\";\n\n  /*\n\n  data ParAff eff a\n    = forall b. Map (b -> a) (ParAff eff b)\n    | forall b. Apply (ParAff eff (b -> a)) (ParAff eff b)\n    | Alt (ParAff eff a) (ParAff eff a)\n    | ?Par (Aff eff a)\n\n  */\n  var MAP   = \"Map\";\n  var APPLY = \"Apply\";\n  var ALT   = \"Alt\";\n\n  // Various constructors used in interpretation\n  var CONS      = \"Cons\";      // Cons-list, for stacks\n  var RESUME    = \"Resume\";    // Continue indiscriminately\n  var RELEASE   = \"Release\";   // Continue with bracket finalizers\n  var FINALIZER = \"Finalizer\"; // A non-interruptible effect\n  var FINALIZED = \"Finalized\"; // Marker for finalization\n  var FORKED    = \"Forked\";    // Reference to a forked fiber, with resumption stack\n  var FIBER     = \"Fiber\";     // Actual fiber reference\n  var THUNK     = \"Thunk\";     // Primed effect, ready to invoke\n\n  function Aff(tag, _1, _2, _3) {\n    this.tag = tag;\n    this._1  = _1;\n    this._2  = _2;\n    this._3  = _3;\n  }\n\n  function AffCtr(tag) {\n    var fn = function (_1, _2, _3) {\n      return new Aff(tag, _1, _2, _3);\n    };\n    fn.tag = tag;\n    return fn;\n  }\n\n  function nonCanceler(error) {\n    return new Aff(PURE, void 0);\n  }\n\n  function runEff(eff) {\n    try {\n      eff();\n    } catch (error) {\n      setTimeout(function () {\n        throw error;\n      }, 0);\n    }\n  }\n\n  function runSync(left, right, eff) {\n    try {\n      return right(eff());\n    } catch (error) {\n      return left(error);\n    }\n  }\n\n  function runAsync(left, eff, k) {\n    try {\n      return eff(k)();\n    } catch (error) {\n      k(left(error))();\n      return nonCanceler;\n    }\n  }\n\n  var Scheduler = function () {\n    var limit    = 1024;\n    var size     = 0;\n    var ix       = 0;\n    var queue    = new Array(limit);\n    var draining = false;\n\n    function drain() {\n      var thunk;\n      draining = true;\n      while (size !== 0) {\n        size--;\n        thunk     = queue[ix];\n        queue[ix] = void 0;\n        ix        = (ix + 1) % limit;\n        thunk();\n      }\n      draining = false;\n    }\n\n    return {\n      isDraining: function () {\n        return draining;\n      },\n      enqueue: function (cb) {\n        var i, tmp;\n        if (size === limit) {\n          tmp = draining;\n          drain();\n          draining = tmp;\n        }\n\n        queue[(ix + size) % limit] = cb;\n        size++;\n\n        if (!draining) {\n          drain();\n        }\n      }\n    };\n  }();\n\n  function Supervisor(util) {\n    var fibers  = {};\n    var fiberId = 0;\n    var count   = 0;\n\n    return {\n      register: function (fiber) {\n        var fid = fiberId++;\n        fiber.onComplete({\n          rethrow: true,\n          handler: function (result) {\n            return function () {\n              count--;\n              delete fibers[fid];\n            };\n          }\n        })();\n        fibers[fid] = fiber;\n        count++;\n      },\n      isEmpty: function () {\n        return count === 0;\n      },\n      killAll: function (killError, cb) {\n        return function () {\n          if (count === 0) {\n            return cb();\n          }\n\n          var killCount = 0;\n          var kills     = {};\n\n          function kill(fid) {\n            kills[fid] = fibers[fid].kill(killError, function (result) {\n              return function () {\n                delete kills[fid];\n                killCount--;\n                if (util.isLeft(result) && util.fromLeft(result)) {\n                  setTimeout(function () {\n                    throw util.fromLeft(result);\n                  }, 0);\n                }\n                if (killCount === 0) {\n                  cb();\n                }\n              };\n            })();\n          }\n\n          for (var k in fibers) {\n            if (fibers.hasOwnProperty(k)) {\n              killCount++;\n              kill(k);\n            }\n          }\n\n          fibers  = {};\n          fiberId = 0;\n          count   = 0;\n\n          return function (error) {\n            return new Aff(SYNC, function () {\n              for (var k in kills) {\n                if (kills.hasOwnProperty(k)) {\n                  kills[k]();\n                }\n              }\n            });\n          };\n        };\n      }\n    };\n  }\n\n  // Fiber state machine\n  var SUSPENDED   = 0; // Suspended, pending a join.\n  var CONTINUE    = 1; // Interpret the next instruction.\n  var STEP_BIND   = 2; // Apply the next bind.\n  var STEP_RESULT = 3; // Handle potential failure from a result.\n  var PENDING     = 4; // An async effect is running.\n  var RETURN      = 5; // The current stack has returned.\n  var COMPLETED   = 6; // The entire fiber has completed.\n\n  function Fiber(util, supervisor, aff) {\n    // Monotonically increasing tick, increased on each asynchronous turn.\n    var runTick = 0;\n\n    // The current branch of the state machine.\n    var status = SUSPENDED;\n\n    // The current point of interest for the state machine branch.\n    var step      = aff;  // Successful step\n    var fail      = null; // Failure step\n    var interrupt = null; // Asynchronous interrupt\n\n    // Stack of continuations for the current fiber.\n    var bhead = null;\n    var btail = null;\n\n    // Stack of attempts and finalizers for error recovery. Every `Cons` is also\n    // tagged with current `interrupt` state. We use this to track which items\n    // should be ignored or evaluated as a result of a kill.\n    var attempts = null;\n\n    // A special state is needed for Bracket, because it cannot be killed. When\n    // we enter a bracket acquisition or finalizer, we increment the counter,\n    // and then decrement once complete.\n    var bracketCount = 0;\n\n    // Each join gets a new id so they can be revoked.\n    var joinId  = 0;\n    var joins   = null;\n    var rethrow = true;\n\n    // Each invocation of `run` requires a tick. When an asynchronous effect is\n    // resolved, we must check that the local tick coincides with the fiber\n    // tick before resuming. This prevents multiple async continuations from\n    // accidentally resuming the same fiber. A common example may be invoking\n    // the provided callback in `makeAff` more than once, but it may also be an\n    // async effect resuming after the fiber was already cancelled.\n    function run(localRunTick) {\n      var tmp, result, attempt;\n      while (true) {\n        tmp       = null;\n        result    = null;\n        attempt   = null;\n\n        switch (status) {\n        case STEP_BIND:\n          status = CONTINUE;\n          try {\n            step   = bhead(step);\n            if (btail === null) {\n              bhead = null;\n            } else {\n              bhead = btail._1;\n              btail = btail._2;\n            }\n          } catch (e) {\n            status = RETURN;\n            fail   = util.left(e);\n            step   = null;\n          }\n          break;\n\n        case STEP_RESULT:\n          if (util.isLeft(step)) {\n            status = RETURN;\n            fail   = step;\n            step   = null;\n          } else if (bhead === null) {\n            status = RETURN;\n          } else {\n            status = STEP_BIND;\n            step   = util.fromRight(step);\n          }\n          break;\n\n        case CONTINUE:\n          switch (step.tag) {\n          case BIND:\n            if (bhead) {\n              btail = new Aff(CONS, bhead, btail);\n            }\n            bhead  = step._2;\n            status = CONTINUE;\n            step   = step._1;\n            break;\n\n          case PURE:\n            if (bhead === null) {\n              status = RETURN;\n              step   = util.right(step._1);\n            } else {\n              status = STEP_BIND;\n              step   = step._1;\n            }\n            break;\n\n          case SYNC:\n            status = STEP_RESULT;\n            step   = runSync(util.left, util.right, step._1);\n            break;\n\n          case ASYNC:\n            status = PENDING;\n            step   = runAsync(util.left, step._1, function (result) {\n              return function () {\n                if (runTick !== localRunTick) {\n                  return;\n                }\n                runTick++;\n                Scheduler.enqueue(function () {\n                  // It's possible to interrupt the fiber between enqueuing and\n                  // resuming, so we need to check that the runTick is still\n                  // valid.\n                  if (runTick !== localRunTick + 1) {\n                    return;\n                  }\n                  status = STEP_RESULT;\n                  step   = result;\n                  run(runTick);\n                });\n              };\n            });\n            return;\n\n          case THROW:\n            status = RETURN;\n            fail   = util.left(step._1);\n            step   = null;\n            break;\n\n          // Enqueue the Catch so that we can call the error handler later on\n          // in case of an exception.\n          case CATCH:\n            if (bhead === null) {\n              attempts = new Aff(CONS, step, attempts, interrupt);\n            } else {\n              attempts = new Aff(CONS, step, new Aff(CONS, new Aff(RESUME, bhead, btail), attempts, interrupt), interrupt);\n            }\n            bhead    = null;\n            btail    = null;\n            status   = CONTINUE;\n            step     = step._1;\n            break;\n\n          // Enqueue the Bracket so that we can call the appropriate handlers\n          // after resource acquisition.\n          case BRACKET:\n            bracketCount++;\n            if (bhead === null) {\n              attempts = new Aff(CONS, step, attempts, interrupt);\n            } else {\n              attempts = new Aff(CONS, step, new Aff(CONS, new Aff(RESUME, bhead, btail), attempts, interrupt), interrupt);\n            }\n            bhead  = null;\n            btail  = null;\n            status = CONTINUE;\n            step   = step._1;\n            break;\n\n          case FORK:\n            status = STEP_RESULT;\n            tmp    = Fiber(util, supervisor, step._2);\n            if (supervisor) {\n              supervisor.register(tmp);\n            }\n            if (step._1) {\n              tmp.run();\n            }\n            step = util.right(tmp);\n            break;\n\n          case SEQ:\n            status = CONTINUE;\n            step   = sequential(util, supervisor, step._1);\n            break;\n          }\n          break;\n\n        case RETURN:\n          bhead = null;\n          btail = null;\n          // If the current stack has returned, and we have no other stacks to\n          // resume or finalizers to run, the fiber has halted and we can\n          // invoke all join callbacks. Otherwise we need to resume.\n          if (attempts === null) {\n            status = COMPLETED;\n            step   = interrupt || fail || step;\n          } else {\n            // The interrupt status for the enqueued item.\n            tmp      = attempts._3;\n            attempt  = attempts._1;\n            attempts = attempts._2;\n\n            switch (attempt.tag) {\n            // We cannot recover from an unmasked interrupt. Otherwise we should\n            // continue stepping, or run the exception handler if an exception\n            // was raised.\n            case CATCH:\n              // We should compare the interrupt status as well because we\n              // only want it to apply if there has been an interrupt since\n              // enqueuing the catch.\n              if (interrupt && interrupt !== tmp && bracketCount === 0) {\n                status = RETURN;\n              } else if (fail) {\n                status = CONTINUE;\n                step   = attempt._2(util.fromLeft(fail));\n                fail   = null;\n              }\n              break;\n\n            // We cannot resume from an unmasked interrupt or exception.\n            case RESUME:\n              // As with Catch, we only want to ignore in the case of an\n              // interrupt since enqueing the item.\n              if (interrupt && interrupt !== tmp && bracketCount === 0 || fail) {\n                status = RETURN;\n              } else {\n                bhead  = attempt._1;\n                btail  = attempt._2;\n                status = STEP_BIND;\n                step   = util.fromRight(step);\n              }\n              break;\n\n            // If we have a bracket, we should enqueue the handlers,\n            // and continue with the success branch only if the fiber has\n            // not been interrupted. If the bracket acquisition failed, we\n            // should not run either.\n            case BRACKET:\n              bracketCount--;\n              if (fail === null) {\n                result   = util.fromRight(step);\n                // We need to enqueue the Release with the same interrupt\n                // status as the Bracket that is initiating it.\n                attempts = new Aff(CONS, new Aff(RELEASE, attempt._2, result), attempts, tmp);\n                // We should only coninue as long as the interrupt status has not changed or\n                // we are currently within a non-interruptable finalizer.\n                if (interrupt === tmp || bracketCount > 0) {\n                  status = CONTINUE;\n                  step   = attempt._3(result);\n                }\n              }\n              break;\n\n            // Enqueue the appropriate handler. We increase the bracket count\n            // because it should not be cancelled.\n            case RELEASE:\n              attempts = new Aff(CONS, new Aff(FINALIZED, step, fail), attempts, interrupt);\n              status   = CONTINUE;\n              // It has only been killed if the interrupt status has changed\n              // since we enqueued the item, and the bracket count is 0. If the\n              // bracket count is non-zero then we are in a masked state so it's\n              // impossible to be killed.\n              if (interrupt && interrupt !== tmp && bracketCount === 0) {\n                step = attempt._1.killed(util.fromLeft(interrupt))(attempt._2);\n              } else if (fail) {\n                step = attempt._1.failed(util.fromLeft(fail))(attempt._2);\n              } else {\n                step = attempt._1.completed(util.fromRight(step))(attempt._2);\n              }\n              fail = null;\n              bracketCount++;\n              break;\n\n            case FINALIZER:\n              bracketCount++;\n              attempts = new Aff(CONS, new Aff(FINALIZED, step, fail), attempts, interrupt);\n              status   = CONTINUE;\n              step     = attempt._1;\n              break;\n\n            case FINALIZED:\n              bracketCount--;\n              status = RETURN;\n              step   = attempt._1;\n              fail   = attempt._2;\n              break;\n            }\n          }\n          break;\n\n        case COMPLETED:\n          for (var k in joins) {\n            if (joins.hasOwnProperty(k)) {\n              rethrow = rethrow && joins[k].rethrow;\n              runEff(joins[k].handler(step));\n            }\n          }\n          joins = null;\n          // If we have an interrupt and a fail, then the thread threw while\n          // running finalizers. This should always rethrow in a fresh stack.\n          if (interrupt && fail) {\n            setTimeout(function () {\n              throw util.fromLeft(fail);\n            }, 0);\n          // If we have an unhandled exception, and no other fiber has joined\n          // then we need to throw the exception in a fresh stack.\n          } else if (util.isLeft(step) && rethrow) {\n            setTimeout(function () {\n              // Guard on reathrow because a completely synchronous fiber can\n              // still have an observer which was added after-the-fact.\n              if (rethrow) {\n                throw util.fromLeft(step);\n              }\n            }, 0);\n          }\n          return;\n        case SUSPENDED:\n          status = CONTINUE;\n          break;\n        case PENDING: return;\n        }\n      }\n    }\n\n    function onComplete(join) {\n      return function () {\n        if (status === COMPLETED) {\n          rethrow = rethrow && join.rethrow;\n          join.handler(step)();\n          return function () {};\n        }\n\n        var jid    = joinId++;\n        joins      = joins || {};\n        joins[jid] = join;\n\n        return function() {\n          if (joins !== null) {\n            delete joins[jid];\n          }\n        };\n      };\n    }\n\n    function kill(error, cb) {\n      return function () {\n        if (status === COMPLETED) {\n          cb(util.right(void 0))();\n          return function () {};\n        }\n\n        var canceler = onComplete({\n          rethrow: false,\n          handler: function (/* unused */) {\n            return cb(util.right(void 0));\n          }\n        })();\n\n        switch (status) {\n        case SUSPENDED:\n          interrupt = util.left(error);\n          status    = COMPLETED;\n          step      = interrupt;\n          run(runTick);\n          break;\n        case PENDING:\n          if (interrupt === null) {\n            interrupt = util.left(error);\n          }\n          if (bracketCount === 0) {\n            if (status === PENDING) {\n              attempts = new Aff(CONS, new Aff(FINALIZER, step(error)), attempts, interrupt);\n            }\n            status   = RETURN;\n            step     = null;\n            fail     = null;\n            run(++runTick);\n          }\n          break;\n        default:\n          if (interrupt === null) {\n            interrupt = util.left(error);\n          }\n          if (bracketCount === 0) {\n            status = RETURN;\n            step   = null;\n            fail   = null;\n          }\n        }\n\n        return canceler;\n      };\n    }\n\n    function join(cb) {\n      return function () {\n        var canceler = onComplete({\n          rethrow: false,\n          handler: cb\n        })();\n        if (status === SUSPENDED) {\n          run(runTick);\n        }\n        return canceler;\n      };\n    }\n\n    return {\n      kill: kill,\n      join: join,\n      onComplete: onComplete,\n      isSuspended: function () {\n        return status === SUSPENDED;\n      },\n      run: function () {\n        if (status === SUSPENDED) {\n          if (!Scheduler.isDraining()) {\n            Scheduler.enqueue(function () {\n              run(runTick);\n            });\n          } else {\n            run(runTick);\n          }\n        }\n      }\n    };\n  }\n\n  function runPar(util, supervisor, par, cb) {\n    // Table of all forked fibers.\n    var fiberId   = 0;\n    var fibers    = {};\n\n    // Table of currently running cancelers, as a product of `Alt` behavior.\n    var killId    = 0;\n    var kills     = {};\n\n    // Error used for early cancelation on Alt branches.\n    var early     = new Error(\"[ParAff] Early exit\");\n\n    // Error used to kill the entire tree.\n    var interrupt = null;\n\n    // The root pointer of the tree.\n    var root      = EMPTY;\n\n    // Walks a tree, invoking all the cancelers. Returns the table of pending\n    // cancellation fibers.\n    function kill(error, par, cb) {\n      var step  = par;\n      var head  = null;\n      var tail  = null;\n      var count = 0;\n      var kills = {};\n      var tmp, kid;\n\n      loop: while (true) {\n        tmp = null;\n\n        switch (step.tag) {\n        case FORKED:\n          if (step._3 === EMPTY) {\n            tmp = fibers[step._1];\n            kills[count++] = tmp.kill(error, function (result) {\n              return function () {\n                count--;\n                if (count === 0) {\n                  cb(result)();\n                }\n              };\n            });\n          }\n          // Terminal case.\n          if (head === null) {\n            break loop;\n          }\n          // Go down the right side of the tree.\n          step = head._2;\n          if (tail === null) {\n            head = null;\n          } else {\n            head = tail._1;\n            tail = tail._2;\n          }\n          break;\n        case MAP:\n          step = step._2;\n          break;\n        case APPLY:\n        case ALT:\n          if (head) {\n            tail = new Aff(CONS, head, tail);\n          }\n          head = step;\n          step = step._1;\n          break;\n        }\n      }\n\n      if (count === 0) {\n        cb(util.right(void 0))();\n      } else {\n        // Run the cancelation effects. We alias `count` because it's mutable.\n        kid = 0;\n        tmp = count;\n        for (; kid < tmp; kid++) {\n          kills[kid] = kills[kid]();\n        }\n      }\n\n      return kills;\n    }\n\n    // When a fiber resolves, we need to bubble back up the tree with the\n    // result, computing the applicative nodes.\n    function join(result, head, tail) {\n      var fail, step, lhs, rhs, tmp, kid;\n\n      if (util.isLeft(result)) {\n        fail = result;\n        step = null;\n      } else {\n        step = result;\n        fail = null;\n      }\n\n      loop: while (true) {\n        lhs = null;\n        rhs = null;\n        tmp = null;\n        kid = null;\n\n        // We should never continue if the entire tree has been interrupted.\n        if (interrupt !== null) {\n          return;\n        }\n\n        // We've made it all the way to the root of the tree, which means\n        // the tree has fully evaluated.\n        if (head === null) {\n          cb(fail || step)();\n          return;\n        }\n\n        // The tree has already been computed, so we shouldn't try to do it\n        // again. This should never happen.\n        // TODO: Remove this?\n        if (head._3 !== EMPTY) {\n          return;\n        }\n\n        switch (head.tag) {\n        case MAP:\n          if (fail === null) {\n            head._3 = util.right(head._1(util.fromRight(step)));\n            step    = head._3;\n          } else {\n            head._3 = fail;\n          }\n          break;\n        case APPLY:\n          lhs = head._1._3;\n          rhs = head._2._3;\n          // If we have a failure we should kill the other side because we\n          // can't possible yield a result anymore.\n          if (fail) {\n            head._3 = fail;\n            tmp     = true;\n            kid     = killId++;\n\n            kills[kid] = kill(early, fail === lhs ? head._2 : head._1, function (/* unused */) {\n              return function () {\n                delete kills[kid];\n                if (tmp) {\n                  tmp = false;\n                } else if (tail === null) {\n                  join(fail, null, null);\n                } else {\n                  join(fail, tail._1, tail._2);\n                }\n              };\n            });\n\n            if (tmp) {\n              tmp = false;\n              return;\n            }\n          } else if (lhs === EMPTY || rhs === EMPTY) {\n            // We can only proceed if both sides have resolved.\n            return;\n          } else {\n            step    = util.right(util.fromRight(lhs)(util.fromRight(rhs)));\n            head._3 = step;\n          }\n          break;\n        case ALT:\n          lhs = head._1._3;\n          rhs = head._2._3;\n          // We can only proceed if both have resolved or we have a success\n          if (lhs === EMPTY && util.isLeft(rhs) || rhs === EMPTY && util.isLeft(lhs)) {\n            return;\n          }\n          // If both sides resolve with an error, we should continue with the\n          // first error\n          if (lhs !== EMPTY && util.isLeft(lhs) && rhs !== EMPTY && util.isLeft(rhs)) {\n            fail    = step === lhs ? rhs : lhs;\n            step    = null;\n            head._3 = fail;\n          } else {\n            head._3 = step;\n            tmp     = true;\n            kid     = killId++;\n            // Once a side has resolved, we need to cancel the side that is still\n            // pending before we can continue.\n            kills[kid] = kill(early, step === lhs ? head._2 : head._1, function (/* unused */) {\n              return function () {\n                delete kills[kid];\n                if (tmp) {\n                  tmp = false;\n                } else if (tail === null) {\n                  join(step, null, null);\n                } else {\n                  join(step, tail._1, tail._2);\n                }\n              };\n            });\n\n            if (tmp) {\n              tmp = false;\n              return;\n            }\n          }\n          break;\n        }\n\n        if (tail === null) {\n          head = null;\n        } else {\n          head = tail._1;\n          tail = tail._2;\n        }\n      }\n    }\n\n    function resolve(fiber) {\n      return function (result) {\n        return function () {\n          delete fibers[fiber._1];\n          fiber._3 = result;\n          join(result, fiber._2._1, fiber._2._2);\n        };\n      };\n    }\n\n    // Walks the applicative tree, substituting non-applicative nodes with\n    // `FORKED` nodes. In this tree, all applicative nodes use the `_3` slot\n    // as a mutable slot for memoization. In an unresolved state, the `_3`\n    // slot is `EMPTY`. In the cases of `ALT` and `APPLY`, we always walk\n    // the left side first, because both operations are left-associative. As\n    // we `RETURN` from those branches, we then walk the right side.\n    function run() {\n      var status = CONTINUE;\n      var step   = par;\n      var head   = null;\n      var tail   = null;\n      var tmp, fid;\n\n      loop: while (true) {\n        tmp = null;\n        fid = null;\n\n        switch (status) {\n        case CONTINUE:\n          switch (step.tag) {\n          case MAP:\n            if (head) {\n              tail = new Aff(CONS, head, tail);\n            }\n            head = new Aff(MAP, step._1, EMPTY, EMPTY);\n            step = step._2;\n            break;\n          case APPLY:\n            if (head) {\n              tail = new Aff(CONS, head, tail);\n            }\n            head = new Aff(APPLY, EMPTY, step._2, EMPTY);\n            step = step._1;\n            break;\n          case ALT:\n            if (head) {\n              tail = new Aff(CONS, head, tail);\n            }\n            head = new Aff(ALT, EMPTY, step._2, EMPTY);\n            step = step._1;\n            break;\n          default:\n            // When we hit a leaf value, we suspend the stack in the `FORKED`.\n            // When the fiber resolves, it can bubble back up the tree.\n            fid    = fiberId++;\n            status = RETURN;\n            tmp    = step;\n            step   = new Aff(FORKED, fid, new Aff(CONS, head, tail), EMPTY);\n            tmp    = Fiber(util, supervisor, tmp);\n            tmp.onComplete({\n              rethrow: false,\n              handler: resolve(step)\n            })();\n            fibers[fid] = tmp;\n            if (supervisor) {\n              supervisor.register(tmp);\n            }\n          }\n          break;\n        case RETURN:\n          // Terminal case, we are back at the root.\n          if (head === null) {\n            break loop;\n          }\n          // If we are done with the right side, we need to continue down the\n          // left. Otherwise we should continue up the stack.\n          if (head._1 === EMPTY) {\n            head._1 = step;\n            status  = CONTINUE;\n            step    = head._2;\n            head._2 = EMPTY;\n          } else {\n            head._2 = step;\n            step    = head;\n            if (tail === null) {\n              head  = null;\n            } else {\n              head  = tail._1;\n              tail  = tail._2;\n            }\n          }\n        }\n      }\n\n      // Keep a reference to the tree root so it can be cancelled.\n      root = step;\n\n      for (fid = 0; fid < fiberId; fid++) {\n        fibers[fid].run();\n      }\n    }\n\n    // Cancels the entire tree. If there are already subtrees being canceled,\n    // we need to first cancel those joins. We will then add fresh joins for\n    // all pending branches including those that were in the process of being\n    // canceled.\n    function cancel(error, cb) {\n      interrupt = util.left(error);\n      var innerKills;\n      for (var kid in kills) {\n        if (kills.hasOwnProperty(kid)) {\n          innerKills = kills[kid];\n          for (kid in innerKills) {\n            if (innerKills.hasOwnProperty(kid)) {\n              innerKills[kid]();\n            }\n          }\n        }\n      }\n\n      kills = null;\n      var newKills = kill(error, root, cb);\n\n      return function (killError) {\n        return new Aff(ASYNC, function (killCb) {\n          return function () {\n            for (var kid in newKills) {\n              if (newKills.hasOwnProperty(kid)) {\n                newKills[kid]();\n              }\n            }\n            return nonCanceler;\n          };\n        });\n      };\n    }\n\n    run();\n\n    return function (killError) {\n      return new Aff(ASYNC, function (killCb) {\n        return function () {\n          return cancel(killError, killCb);\n        };\n      });\n    };\n  }\n\n  function sequential(util, supervisor, par) {\n    return new Aff(ASYNC, function (cb) {\n      return function () {\n        return runPar(util, supervisor, par, cb);\n      };\n    });\n  }\n\n  Aff.EMPTY       = EMPTY;\n  Aff.Pure        = AffCtr(PURE);\n  Aff.Throw       = AffCtr(THROW);\n  Aff.Catch       = AffCtr(CATCH);\n  Aff.Sync        = AffCtr(SYNC);\n  Aff.Async       = AffCtr(ASYNC);\n  Aff.Bind        = AffCtr(BIND);\n  Aff.Bracket     = AffCtr(BRACKET);\n  Aff.Fork        = AffCtr(FORK);\n  Aff.Seq         = AffCtr(SEQ);\n  Aff.ParMap      = AffCtr(MAP);\n  Aff.ParApply    = AffCtr(APPLY);\n  Aff.ParAlt      = AffCtr(ALT);\n  Aff.Fiber       = Fiber;\n  Aff.Supervisor  = Supervisor;\n  Aff.Scheduler   = Scheduler;\n  Aff.nonCanceler = nonCanceler;\n\n  return Aff;\n}();\n\nexport const _pure = Aff.Pure;\nexport const _throwError = Aff.Throw;\n\nexport function _catchError(aff) {\n  return function (k) {\n    return Aff.Catch(aff, k);\n  };\n}\n\nexport function _map(f) {\n  return function (aff) {\n    if (aff.tag === Aff.Pure.tag) {\n      return Aff.Pure(f(aff._1));\n    } else {\n      return Aff.Bind(aff, function (value) {\n        return Aff.Pure(f(value));\n      });\n    }\n  };\n}\n\nexport function _bind(aff) {\n  return function (k) {\n    return Aff.Bind(aff, k);\n  };\n}\n\nexport function _fork(immediate) {\n  return function (aff) {\n    return Aff.Fork(immediate, aff);\n  };\n}\n\nexport const _liftEffect = Aff.Sync;\n\nexport function _parAffMap(f) {\n  return function (aff) {\n    return Aff.ParMap(f, aff);\n  };\n}\n\nexport function _parAffApply(aff1) {\n  return function (aff2) {\n    return Aff.ParApply(aff1, aff2);\n  };\n}\n\nexport function _parAffAlt(aff1) {\n  return function (aff2) {\n    return Aff.ParAlt(aff1, aff2);\n  };\n}\n\nexport const makeAff = Aff.Async;\n\nexport function generalBracket(acquire) {\n  return function (options) {\n    return function (k) {\n      return Aff.Bracket(acquire, options, k);\n    };\n  };\n}\n\nexport function _makeFiber(util, aff) {\n  return function () {\n    return Aff.Fiber(util, null, aff);\n  };\n}\n\nexport function _makeSupervisedFiber(util, aff) {\n  return function () {\n    var supervisor = Aff.Supervisor(util);\n    return {\n      fiber: Aff.Fiber(util, supervisor, aff),\n      supervisor: supervisor\n    };\n  };\n}\n\nexport function _killAll(error, supervisor, cb) {\n  return supervisor.killAll(error, cb);\n}\n\nexport const _delay = function () {\n  function setDelay(n, k) {\n    if (n === 0 && typeof setImmediate !== \"undefined\") {\n      return setImmediate(k);\n    } else {\n      return setTimeout(k, n);\n    }\n  }\n\n  function clearDelay(n, t) {\n    if (n === 0 && typeof clearImmediate !== \"undefined\") {\n      return clearImmediate(t);\n    } else {\n      return clearTimeout(t);\n    }\n  }\n\n  return function (right, ms) {\n    return Aff.Async(function (cb) {\n      return function () {\n        var timer = setDelay(ms, cb(right()));\n        return function () {\n          return Aff.Sync(function () {\n            return right(clearDelay(ms, timer));\n          });\n        };\n      };\n    });\n  };\n}();\n\nexport const _sequential = Aff.Seq;\n", "export const arrayBind = function (arr) {\n  return function (f) {\n    var result = [];\n    for (var i = 0, l = arr.length; i < l; i++) {\n      Array.prototype.push.apply(result, f(arr[i]));\n    }\n    return result;\n  };\n};\n", "module Control.Bind\n  ( class Bind\n  , bind\n  , (>>=)\n  , bindFlipped\n  , (=<<)\n  , class Discard\n  , discard\n  , join\n  , composeKleisli\n  , (>=>)\n  , composeKleisliFlipped\n  , (<=<)\n  , ifM\n  , module Data.Functor\n  , module Control.Apply\n  , module Control.Applicative\n  ) where\n\nimport Control.Applicative (class Applicative, liftA1, pure, unless, when)\nimport Control.Apply (class Apply, apply, (*>), (<*), (<*>))\nimport Control.Category (identity)\n\nimport Data.Function (flip)\nimport Data.Functor (class Functor, map, void, ($>), (<#>), (<$), (<$>))\nimport Data.Unit (Unit)\nimport Type.Proxy (Proxy(..))\n\n-- | The `Bind` type class extends the [`Apply`](#apply) type class with a\n-- | \"bind\" operation `(>>=)` which composes computations in sequence, using\n-- | the return value of one computation to determine the next computation.\n-- |\n-- | The `>>=` operator can also be expressed using `do` notation, as follows:\n-- |\n-- | ```purescript\n-- | x >>= f = do y <- x\n-- |              f y\n-- | ```\n-- |\n-- | where the function argument of `f` is given the name `y`.\n-- |\n-- | Instances must satisfy the following laws in addition to the `Apply`\n-- | laws:\n-- |\n-- | - Associativity: `(x >>= f) >>= g = x >>= (\\k -> f k >>= g)`\n-- | - Apply Superclass: `apply f x = f >>= \\f\u2019 -> map f\u2019 x`\n-- |\n-- | Associativity tells us that we can regroup operations which use `do`\n-- | notation so that we can unambiguously write, for example:\n-- |\n-- | ```purescript\n-- | do x <- m1\n-- |    y <- m2 x\n-- |    m3 x y\n-- | ```\nclass Apply m <= Bind m where\n  bind :: forall a b. m a -> (a -> m b) -> m b\n\ninfixl 1 bind as >>=\n\n-- | `bindFlipped` is `bind` with its arguments reversed. For example:\n-- |\n-- | ```purescript\n-- | print =<< random\n-- | ```\nbindFlipped :: forall m a b. Bind m => (a -> m b) -> m a -> m b\nbindFlipped = flip bind\n\ninfixr 1 bindFlipped as =<<\n\ninstance bindFn :: Bind ((->) r) where\n  bind m f x = f (m x) x\n\n-- | The `bind`/`>>=` function for `Array` works by applying a function to\n-- | each element in the array, and flattening the results into a single,\n-- | new array.\n-- |\n-- | Array's `bind`/`>>=` works like a nested for loop. Each `bind` adds\n-- | another level of nesting in the loop. For example:\n-- | ```\n-- | foo :: Array String\n-- | foo =\n-- |   [\"a\", \"b\"] >>= \\eachElementInArray1 ->\n-- |     [\"c\", \"d\"] >>= \\eachElementInArray2\n-- |       pure (eachElementInArray1 <> eachElementInArray2)\n-- |\n-- | -- In other words...\n-- | foo\n-- | -- ... is the same as...\n-- | [ (\"a\" <> \"c\"), (\"a\" <> \"d\"), (\"b\" <> \"c\"), (\"b\" <> \"d\") ]\n-- | -- which simplifies to...\n-- | [ \"ac\", \"ad\", \"bc\", \"bd\" ]\n-- | ```\ninstance bindArray :: Bind Array where\n  bind = arrayBind\n\nforeign import arrayBind :: forall a b. Array a -> (a -> Array b) -> Array b\n\ninstance bindProxy :: Bind Proxy where\n  bind _ _ = Proxy\n\n-- | A class for types whose values can safely be discarded\n-- | in a `do` notation block.\n-- |\n-- | An example is the `Unit` type, since there is only one\n-- | possible value which can be returned.\nclass Discard a where\n  discard :: forall f b. Bind f => f a -> (a -> f b) -> f b\n\ninstance discardUnit :: Discard Unit where\n  discard = bind\n\ninstance discardProxy :: Discard (Proxy a) where\n  discard = bind\n\n-- | Collapse two applications of a monadic type constructor into one.\njoin :: forall a m. Bind m => m (m a) -> m a\njoin m = m >>= identity\n\n-- | Forwards Kleisli composition.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | import Data.Array (head, tail)\n-- |\n-- | third = tail >=> tail >=> head\n-- | ```\ncomposeKleisli :: forall a b c m. Bind m => (a -> m b) -> (b -> m c) -> a -> m c\ncomposeKleisli f g a = f a >>= g\n\ninfixr 1 composeKleisli as >=>\n\n-- | Backwards Kleisli composition.\ncomposeKleisliFlipped :: forall a b c m. Bind m => (b -> m c) -> (a -> m b) -> a -> m c\ncomposeKleisliFlipped f g a = f =<< g a\n\ninfixr 1 composeKleisliFlipped as <=<\n\n-- | Execute a monadic action if a condition holds.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | main = ifM ((< 0.5) <$> random)\n-- |          (trace \"Heads\")\n-- |          (trace \"Tails\")\n-- | ```\nifM :: forall a m. Bind m => m Boolean -> m a -> m a -> m a\nifM cond t f = cond >>= \\cond' -> if cond' then t else f\n", "module Control.Monad\n  ( class Monad\n  , liftM1\n  , whenM\n  , unlessM\n  , ap\n  , module Data.Functor\n  , module Control.Apply\n  , module Control.Applicative\n  , module Control.Bind\n  ) where\n\nimport Control.Applicative (class Applicative, liftA1, pure, unless, when)\nimport Control.Apply (class Apply, apply, (*>), (<*), (<*>))\nimport Control.Bind (class Bind, bind, ifM, join, (<=<), (=<<), (>=>), (>>=))\n\nimport Data.Functor (class Functor, map, void, ($>), (<#>), (<$), (<$>))\nimport Data.Unit (Unit)\nimport Type.Proxy (Proxy)\n\n-- | The `Monad` type class combines the operations of the `Bind` and\n-- | `Applicative` type classes. Therefore, `Monad` instances represent type\n-- | constructors which support sequential composition, and also lifting of\n-- | functions of arbitrary arity.\n-- |\n-- | Instances must satisfy the following laws in addition to the\n-- | `Applicative` and `Bind` laws:\n-- |\n-- | - Left Identity: `pure x >>= f = f x`\n-- | - Right Identity: `x >>= pure = x`\nclass (Applicative m, Bind m) <= Monad m\n\ninstance monadFn :: Monad ((->) r)\n\ninstance monadArray :: Monad Array\n\ninstance monadProxy :: Monad Proxy\n\n-- | `liftM1` provides a default implementation of `(<$>)` for any\n-- | [`Monad`](#monad), without using `(<$>)` as provided by the\n-- | [`Functor`](#functor)-[`Monad`](#monad) superclass relationship.\n-- |\n-- | `liftM1` can therefore be used to write [`Functor`](#functor) instances\n-- | as follows:\n-- |\n-- | ```purescript\n-- | instance functorF :: Functor F where\n-- |   map = liftM1\n-- | ```\nliftM1 :: forall m a b. Monad m => (a -> b) -> m a -> m b\nliftM1 f a = do\n  a' <- a\n  pure (f a')\n\n-- | Perform a monadic action when a condition is true, where the conditional\n-- | value is also in a monadic context.\nwhenM :: forall m. Monad m => m Boolean -> m Unit -> m Unit\nwhenM mb m = do\n  b <- mb\n  when b m\n\n-- | Perform a monadic action unless a condition is true, where the conditional\n-- | value is also in a monadic context.\nunlessM :: forall m. Monad m => m Boolean -> m Unit -> m Unit\nunlessM mb m = do\n  b <- mb\n  unless b m\n\n-- | `ap` provides a default implementation of `(<*>)` for any `Monad`, without\n-- | using `(<*>)` as provided by the `Apply`-`Monad` superclass relationship.\n-- |\n-- | `ap` can therefore be used to write `Apply` instances as follows:\n-- |\n-- | ```purescript\n-- | instance applyF :: Apply F where\n-- |   apply = ap\n-- | ```\n-- Note: Only a `Bind` constraint is needed, but this can\n-- produce loops when used with other default implementations\n-- (i.e. `liftA1`).\n-- See https://github.com/purescript/purescript-prelude/issues/232\nap :: forall m a b. Monad m => m (a -> b) -> m a -> m b\nap f a = do\n  f' <- f\n  a' <- a\n  pure (f' a')\n", "module Data.Either where\n\nimport Prelude\n\nimport Control.Alt (class Alt, (<|>))\nimport Control.Extend (class Extend)\nimport Data.Eq (class Eq1)\nimport Data.Functor.Invariant (class Invariant, imapF)\nimport Data.Generic.Rep (class Generic)\nimport Data.Maybe (Maybe(..), maybe, maybe')\nimport Data.Ord (class Ord1)\n\n-- | The `Either` type is used to represent a choice between two types of value.\n-- |\n-- | A common use case for `Either` is error handling, where `Left` is used to\n-- | carry an error value and `Right` is used to carry a success value.\ndata Either a b = Left a | Right b\n\n-- | The `Functor` instance allows functions to transform the contents of a\n-- | `Right` with the `<$>` operator:\n-- |\n-- | ``` purescript\n-- | f <$> Right x == Right (f x)\n-- | ```\n-- |\n-- | `Left` values are untouched:\n-- |\n-- | ``` purescript\n-- | f <$> Left y == Left y\n-- | ```\nderive instance functorEither :: Functor (Either a)\n\nderive instance genericEither :: Generic (Either a b) _\n\ninstance invariantEither :: Invariant (Either a) where\n  imap = imapF\n\n-- | The `Apply` instance allows functions contained within a `Right` to\n-- | transform a value contained within a `Right` using the `(<*>)` operator:\n-- |\n-- | ``` purescript\n-- | Right f <*> Right x == Right (f x)\n-- | ```\n-- |\n-- | `Left` values are left untouched:\n-- |\n-- | ``` purescript\n-- | Left f <*> Right x == Left f\n-- | Right f <*> Left y == Left y\n-- | ```\n-- |\n-- | Combining `Functor`'s `<$>` with `Apply`'s `<*>` can be used to transform a\n-- | pure function to take `Either`-typed arguments so `f :: a -> b -> c`\n-- | becomes `f :: Either l a -> Either l b -> Either l c`:\n-- |\n-- | ``` purescript\n-- | f <$> Right x <*> Right y == Right (f x y)\n-- | ```\n-- |\n-- | The `Left`-preserving behaviour of both operators means the result of\n-- | an expression like the above but where any one of the values is `Left`\n-- | means the whole result becomes `Left` also, taking the first `Left` value\n-- | found:\n-- |\n-- | ``` purescript\n-- | f <$> Left x <*> Right y == Left x\n-- | f <$> Right x <*> Left y == Left y\n-- | f <$> Left x <*> Left y == Left x\n-- | ```\ninstance applyEither :: Apply (Either e) where\n  apply (Left e) _ = Left e\n  apply (Right f) r = f <$> r\n\n-- | The `Applicative` instance enables lifting of values into `Either` with the\n-- | `pure` function:\n-- |\n-- | ``` purescript\n-- | pure x :: Either _ _ == Right x\n-- | ```\n-- |\n-- | Combining `Functor`'s `<$>` with `Apply`'s `<*>` and `Applicative`'s\n-- | `pure` can be used to pass a mixture of `Either` and non-`Either` typed\n-- | values to a function that does not usually expect them, by using `pure`\n-- | for any value that is not already `Either` typed:\n-- |\n-- | ``` purescript\n-- | f <$> Right x <*> pure y == Right (f x y)\n-- | ```\n-- |\n-- | Even though `pure = Right` it is recommended to use `pure` in situations\n-- | like this as it allows the choice of `Applicative` to be changed later\n-- | without having to go through and replace `Right` with a new constructor.\ninstance applicativeEither :: Applicative (Either e) where\n  pure = Right\n\n-- | The `Alt` instance allows for a choice to be made between two `Either`\n-- | values with the `<|>` operator, where the first `Right` encountered\n-- | is taken.\n-- |\n-- | ``` purescript\n-- | Right x <|> Right y == Right x\n-- | Left x <|> Right y == Right y\n-- | Left x <|> Left y == Left y\n-- | ```\ninstance altEither :: Alt (Either e) where\n  alt (Left _) r = r\n  alt l        _ = l\n\n-- | The `Bind` instance allows sequencing of `Either` values and functions that\n-- | return an `Either` by using the `>>=` operator:\n-- |\n-- | ``` purescript\n-- | Left x >>= f = Left x\n-- | Right x >>= f = f x\n-- | ```\n-- |\n-- | `Either`'s \"do notation\" can be understood to work like this:\n-- | ``` purescript\n-- | x :: forall e a. Either e a\n-- | x = --\n-- |\n-- | y :: forall e b. Either e b\n-- | y = --\n-- |\n-- | foo :: forall e a. (a -> b -> c) -> Either e c\n-- | foo f = do\n-- |   x' <- x\n-- |   y' <- y\n-- |   pure (f x' y')\n-- | ```\n-- |\n-- | ...which is equivalent to...\n-- |\n-- | ``` purescript\n-- | x >>= (\\x' -> y >>= (\\y' -> pure (f x' y')))\n-- | ```\n-- |\n-- | ...and is the same as writing...\n-- |\n-- | ```\n-- | foo :: forall e a. (a -> b -> c) -> Either e c\n-- | foo f = case x of\n-- |   Left e ->\n-- |     Left e\n-- |   Right x -> case y of\n-- |     Left e ->\n-- |       Left e\n-- |     Right y ->\n-- |       Right (f x y)\n-- | ```\ninstance bindEither :: Bind (Either e) where\n  bind = either (\\e _ -> Left e) (\\a f -> f a)\n\n-- | The `Monad` instance guarantees that there are both `Applicative` and\n-- | `Bind` instances for `Either`.\ninstance monadEither :: Monad (Either e)\n\n-- | The `Extend` instance allows sequencing of `Either` values and functions\n-- | that accept an `Either` and return a non-`Either` result using the\n-- | `<<=` operator.\n-- |\n-- | ``` purescript\n-- | f <<= Left x = Left x\n-- | f <<= Right x = Right (f (Right x))\n-- | ```\ninstance extendEither :: Extend (Either e) where\n  extend _ (Left y)  = Left y\n  extend f x         = Right (f x)\n\n-- | The `Show` instance allows `Either` values to be rendered as a string with\n-- | `show` whenever there is an `Show` instance for both type the `Either` can\n-- | contain.\ninstance showEither :: (Show a, Show b) => Show (Either a b) where\n  show (Left x) = \"(Left \" <> show x <> \")\"\n  show (Right y) = \"(Right \" <> show y <> \")\"\n\n-- | The `Eq` instance allows `Either` values to be checked for equality with\n-- | `==` and inequality with `/=` whenever there is an `Eq` instance for both\n-- | types the `Either` can contain.\nderive instance eqEither :: (Eq a, Eq b) => Eq (Either a b)\n\nderive instance eq1Either :: Eq a => Eq1 (Either a)\n\n-- | The `Ord` instance allows `Either` values to be compared with\n-- | `compare`, `>`, `>=`, `<` and `<=` whenever there is an `Ord` instance for\n-- | both types the `Either` can contain.\n-- |\n-- | Any `Left` value is considered to be less than a `Right` value.\nderive instance ordEither :: (Ord a, Ord b) => Ord (Either a b)\n\nderive instance ord1Either :: Ord a => Ord1 (Either a)\n\ninstance boundedEither :: (Bounded a, Bounded b) => Bounded (Either a b) where\n  top = Right top\n  bottom = Left bottom\n\ninstance semigroupEither :: (Semigroup b) => Semigroup (Either a b) where\n  append x y = append <$> x <*> y\n\n-- | Takes two functions and an `Either` value, if the value is a `Left` the\n-- | inner value is applied to the first function, if the value is a `Right`\n-- | the inner value is applied to the second function.\n-- |\n-- | ``` purescript\n-- | either f g (Left x) == f x\n-- | either f g (Right y) == g y\n-- | ```\neither :: forall a b c. (a -> c) -> (b -> c) -> Either a b -> c\neither f _ (Left a) = f a\neither _ g (Right b) = g b\n\n-- | Combine two alternatives.\nchoose :: forall m a b. Alt m => m a -> m b -> m (Either a b)\nchoose a b = Left <$> a <|> Right <$> b\n\n-- | Returns `true` when the `Either` value was constructed with `Left`.\nisLeft :: forall a b. Either a b -> Boolean\nisLeft = either (const true) (const false)\n\n-- | Returns `true` when the `Either` value was constructed with `Right`.\nisRight :: forall a b. Either a b -> Boolean\nisRight = either (const false) (const true)\n\n-- | A function that extracts the value from the `Left` data constructor.\n-- | The first argument is a default value, which will be returned in the\n-- | case where a `Right` is passed to `fromLeft`.\nfromLeft :: forall a b. a -> Either a b -> a\nfromLeft _ (Left a) = a\nfromLeft default _ = default\n\n-- | Similar to `fromLeft` but for use in cases where the default value may be\n-- | expensive to compute. As PureScript is not lazy, the standard `fromLeft`\n-- | has to evaluate the default value before returning the result,\n-- | whereas here the value is only computed when the `Either` is known\n-- | to be `Right`.\nfromLeft' :: forall a b. (Unit -> a) -> Either a b -> a\nfromLeft' _ (Left a) = a\nfromLeft' default _ = default unit\n\n-- | A function that extracts the value from the `Right` data constructor.\n-- | The first argument is a default value, which will be returned in the\n-- | case where a `Left` is passed to `fromRight`.\nfromRight :: forall a b. b -> Either a b -> b\nfromRight _ (Right b) = b\nfromRight default _ = default\n\n-- | Similar to `fromRight` but for use in cases where the default value may be\n-- | expensive to compute. As PureScript is not lazy, the standard `fromRight`\n-- | has to evaluate the default value before returning the result,\n-- | whereas here the value is only computed when the `Either` is known\n-- | to be `Left`.\nfromRight' :: forall a b. (Unit -> b) -> Either a b -> b\nfromRight' _ (Right b) = b\nfromRight' default _ = default unit\n\n-- | Takes a default and a `Maybe` value, if the value is a `Just`, turn it into\n-- | a `Right`, if the value is a `Nothing` use the provided default as a `Left`\n-- |\n-- | ```purescript\n-- | note \"default\" Nothing = Left \"default\"\n-- | note \"default\" (Just 1) = Right 1\n-- | ```\nnote :: forall a b. a -> Maybe b -> Either a b\nnote a = maybe (Left a) Right\n\n-- | Similar to `note`, but for use in cases where the default value may be\n-- | expensive to compute.\n-- |\n-- | ```purescript\n-- | note' (\\_ -> \"default\") Nothing = Left \"default\"\n-- | note' (\\_ -> \"default\") (Just 1) = Right 1\n-- | ```\nnote' :: forall a b. (Unit -> a) -> Maybe b -> Either a b\nnote' f = maybe' (Left <<< f) Right\n\n-- | Turns an `Either` into a `Maybe`, by throwing potential `Left` values away and converting\n-- | them into `Nothing`. `Right` values get turned into `Just`s.\n-- |\n-- | ```purescript\n-- | hush (Left \"ParseError\") = Nothing\n-- | hush (Right 42) = Just 42\n-- | ```\nhush :: forall a b. Either a b -> Maybe b\nhush = either (const Nothing) Just\n\n-- | Turns an `Either` into a `Maybe`, by throwing potential `Right` values away and converting\n-- | them into `Nothing`. `Left` values get turned into `Just`s.\n-- |\n-- | ```purescript\n-- | blush (Left \"ParseError\") = Just \"Parse Error\"\n-- | blush (Right 42) = Nothing\n-- | ```\nblush :: forall a b. Either a b -> Maybe a\nblush = either Just (const Nothing)\n", "export const pureE = function (a) {\n  return function () {\n    return a;\n  };\n};\n\nexport const bindE = function (a) {\n  return function (f) {\n    return function () {\n      return f(a())();\n    };\n  };\n};\n\nexport const untilE = function (f) {\n  return function () {\n    while (!f());\n  };\n};\n\nexport const whileE = function (f) {\n  return function (a) {\n    return function () {\n      while (f()) {\n        a();\n      }\n    };\n  };\n};\n\nexport const forE = function (lo) {\n  return function (hi) {\n    return function (f) {\n      return function () {\n        for (var i = lo; i < hi; i++) {\n          f(i)();\n        }\n      };\n    };\n  };\n};\n\nexport const foreachE = function (as) {\n  return function (f) {\n    return function () {\n      for (var i = 0, l = as.length; i < l; i++) {\n        f(as[i])();\n      }\n    };\n  };\n};\n", "module Data.Monoid\n  ( class Monoid\n  , mempty\n  , power\n  , guard\n  , module Data.Semigroup\n  , class MonoidRecord\n  , memptyRecord\n  ) where\n\nimport Data.Boolean (otherwise)\nimport Data.Eq ((==))\nimport Data.EuclideanRing (mod, (/))\nimport Data.Ord ((<=))\nimport Data.Ordering (Ordering(..))\nimport Data.Semigroup (class Semigroup, class SemigroupRecord, (<>))\nimport Data.Symbol (class IsSymbol, reflectSymbol)\nimport Data.Unit (Unit, unit)\nimport Prim.Row as Row\nimport Prim.RowList as RL\nimport Record.Unsafe (unsafeSet)\nimport Type.Proxy (Proxy(..))\n\n-- | A `Monoid` is a `Semigroup` with a value `mempty`, which is both a\n-- | left and right unit for the associative operation `<>`:\n-- |\n-- | - Left unit: `(mempty <> x) = x`\n-- | - Right unit: `(x <> mempty) = x`\n-- |\n-- | `Monoid`s are commonly used as the result of fold operations, where\n-- | `<>` is used to combine individual results, and `mempty` gives the result\n-- | of folding an empty collection of elements.\n-- |\n-- | ### Newtypes for Monoid\n-- |\n-- | Some types (e.g. `Int`, `Boolean`) can implement multiple law-abiding\n-- | instances for `Monoid`. Let's use `Int` as an example\n-- | 1. `<>` could be `+` and `mempty` could be `0`\n-- | 2. `<>` could be `*` and `mempty` could be `1`.\n-- |\n-- | To clarify these ambiguous situations, one should use the newtypes\n-- | defined in `Data.Monoid.<NewtypeName>` modules.\n-- |\n-- | In the above ambiguous situation, we could use `Additive`\n-- | for the first situation or `Multiplicative` for the second one.\nclass Semigroup m <= Monoid m where\n  mempty :: m\n\ninstance monoidUnit :: Monoid Unit where\n  mempty = unit\n\ninstance monoidOrdering :: Monoid Ordering where\n  mempty = EQ\n\ninstance monoidFn :: Monoid b => Monoid (a -> b) where\n  mempty _ = mempty\n\ninstance monoidString :: Monoid String where\n  mempty = \"\"\n\ninstance monoidArray :: Monoid (Array a) where\n  mempty = []\n\ninstance monoidRecord :: (RL.RowToList row list, MonoidRecord list row row) => Monoid (Record row) where\n  mempty = memptyRecord (Proxy :: Proxy list)\n\n-- | Append a value to itself a certain number of times. For the\n-- | `Multiplicative` type, and for a non-negative power, this is the same as\n-- | normal number exponentiation.\n-- |\n-- | If the second argument is negative this function will return `mempty`\n-- | (*unlike* normal number exponentiation). The `Monoid` constraint alone\n-- | is not enough to write a `power` function with the property that `power x\n-- | n` cancels with `power x (-n)`, i.e. `power x n <> power x (-n) = mempty`.\n-- | For that, we would additionally need the ability to invert elements, i.e.\n-- | a Group.\n-- |\n-- | ```purescript\n-- | power [1,2] 3    == [1,2,1,2,1,2]\n-- | power [1,2] 1    == [1,2]\n-- | power [1,2] 0    == []\n-- | power [1,2] (-3) == []\n-- | ```\n-- |\npower :: forall m. Monoid m => m -> Int -> m\npower x = go\n  where\n  go :: Int -> m\n  go p\n    | p <= 0 = mempty\n    | p == 1 = x\n    | p `mod` 2 == 0 = let x' = go (p / 2) in x' <> x'\n    | otherwise = let x' = go (p / 2) in x' <> x' <> x\n\n-- | Allow or \"truncate\" a Monoid to its `mempty` value based on a condition.\nguard :: forall m. Monoid m => Boolean -> m -> m\nguard true a = a\nguard false _ = mempty\n\n-- | A class for records where all fields have `Monoid` instances, used to\n-- | implement the `Monoid` instance for records.\nclass MonoidRecord :: RL.RowList Type -> Row Type -> Row Type -> Constraint\nclass SemigroupRecord rowlist row subrow <= MonoidRecord rowlist row subrow | rowlist -> row subrow where\n  memptyRecord :: Proxy rowlist -> Record subrow\n\ninstance monoidRecordNil :: MonoidRecord RL.Nil row () where\n  memptyRecord _ = {}\n\ninstance monoidRecordCons ::\n  ( IsSymbol key\n  , Monoid focus\n  , Row.Cons key focus subrowTail subrow\n  , MonoidRecord rowlistTail row subrowTail\n  ) =>\n  MonoidRecord (RL.Cons key focus rowlistTail) row subrow where\n  memptyRecord _ = insert mempty tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n    tail = memptyRecord (Proxy :: Proxy rowlistTail)\n", "-- | This module provides the `Effect` type, which is used to represent\n-- | _native_ effects. The `Effect` type provides a typed API for effectful\n-- | computations, while at the same time generating efficient JavaScript.\nmodule Effect\n  ( Effect\n  , untilE, whileE, forE, foreachE\n  ) where\n\nimport Prelude\n\nimport Control.Apply (lift2)\n\n-- | A native effect. The type parameter denotes the return type of running the\n-- | effect, that is, an `Effect Int` is a possibly-effectful computation which\n-- | eventually produces a value of the type `Int` when it finishes.\nforeign import data Effect :: Type -> Type\n\ntype role Effect representational\n\ninstance functorEffect :: Functor Effect where\n  map = liftA1\n\ninstance applyEffect :: Apply Effect where\n  apply = ap\n\ninstance applicativeEffect :: Applicative Effect where\n  pure = pureE\n\nforeign import pureE :: forall a. a -> Effect a\n\ninstance bindEffect :: Bind Effect where\n  bind = bindE\n\nforeign import bindE :: forall a b. Effect a -> (a -> Effect b) -> Effect b\n\ninstance monadEffect :: Monad Effect\n\n-- | The `Semigroup` instance for effects allows you to run two effects, one\n-- | after the other, and then combine their results using the result type's\n-- | `Semigroup` instance.\ninstance semigroupEffect :: Semigroup a => Semigroup (Effect a) where\n  append = lift2 append\n\n-- | If you have a `Monoid a` instance, then `mempty :: Effect a` is defined as\n-- | `pure mempty`.\ninstance monoidEffect :: Monoid a => Monoid (Effect a) where\n  mempty = pureE mempty\n\n-- | Loop until a condition becomes `true`.\n-- |\n-- | `untilE b` is an effectful computation which repeatedly runs the effectful\n-- | computation `b`, until its return value is `true`.\nforeign import untilE :: Effect Boolean -> Effect Unit\n\n-- | Loop while a condition is `true`.\n-- |\n-- | `whileE b m` is effectful computation which runs the effectful computation\n-- | `b`. If its result is `true`, it runs the effectful computation `m` and\n-- | loops. If not, the computation ends.\nforeign import whileE :: forall a. Effect Boolean -> Effect a -> Effect Unit\n\n-- | Loop over a consecutive collection of numbers.\n-- |\n-- | `forE lo hi f` runs the computation returned by the function `f` for each\n-- | of the inputs between `lo` (inclusive) and `hi` (exclusive).\nforeign import forE :: Int -> Int -> (Int -> Effect Unit) -> Effect Unit\n\n-- | Loop over an array of values.\n-- |\n-- | `foreachE xs f` runs the computation returned by the function `f` for each\n-- | of the inputs `xs`.\nforeign import foreachE :: forall a. Array a -> (a -> Effect Unit) -> Effect Unit\n", "export function showErrorImpl(err) {\n  return err.stack || err.toString();\n}\n\nexport function error(msg) {\n  return new Error(msg);\n}\n\nexport function message(e) {\n  return e.message;\n}\n\nexport function name(e) {\n  return e.name || \"Error\";\n}\n\nexport function stackImpl(just) {\n  return function (nothing) {\n    return function (e) {\n      return e.stack ? just(e.stack) : nothing;\n    };\n  };\n}\n\nexport function throwException(e) {\n  return function () {\n    throw e;\n  };\n}\n\nexport function catchException(c) {\n  return function (t) {\n    return function () {\n      try {\n        return t();\n      } catch (e) {\n        if (e instanceof Error || Object.prototype.toString.call(e) === \"[object Error]\") {\n          return c(e)();\n        } else {\n          return c(new Error(e.toString()))();\n        }\n      }\n    };\n  };\n}\n", "-- | This module defines an effect, actions and handlers for working\n-- | with JavaScript exceptions.\n\nmodule Effect.Exception\n  ( Error\n  , error\n  , message\n  , name\n  , stack\n  , throwException\n  , catchException\n  , throw\n  , try\n  ) where\n\nimport Prelude\n\nimport Effect (Effect)\n\nimport Data.Either (Either(..))\nimport Data.Maybe (Maybe(..))\n\n-- | The type of JavaScript errors\nforeign import data Error :: Type\n\ninstance showError :: Show Error where\n  show = showErrorImpl\n\nforeign import showErrorImpl :: Error -> String\n\n-- | Create a JavaScript error, specifying a message\nforeign import error :: String -> Error\n\n-- | Get the error message from a JavaScript error\nforeign import message :: Error -> String\n\n-- | Get the error name when defined, or fallback to 'Error'\nforeign import name :: Error -> String\n\n-- | Get the stack trace from a JavaScript error\nstack :: Error -> Maybe String\nstack = stackImpl Just Nothing\n\nforeign import stackImpl\n  :: (forall a. a -> Maybe a)\n  -> (forall a. Maybe a)\n  -> Error\n  -> Maybe String\n\n-- | Throw an exception\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | main = do\n-- |   x <- readNumber\n-- |   when (x < 0) $ throwException $\n-- |     error \"Expected a non-negative number\"\n-- | ```\nforeign import throwException\n  :: forall a\n   . Error\n  -> Effect a\n\n-- | Catch an exception by providing an exception handler.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | main = catchException Console.logShow do\n-- |   Console.log \"Exceptions thrown in this block will be logged to the console\"\n-- | ```\nforeign import catchException\n  :: forall a\n   . (Error -> Effect a)\n  -> Effect a\n  -> Effect a\n\n-- | A shortcut allowing you to throw an error in one step. Defined as\n-- | `throwException <<< error`.\nthrow :: forall a. String -> Effect a\nthrow = throwException <<< error\n\n-- | Runs an Eff and returns eventual Exceptions as a `Left` value. If the\n-- | computation succeeds the result gets wrapped in a `Right`.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | main :: Effect Unit\n-- | main = do\n-- |   result <- try (readTextFile UTF8 \"README.md\")\n-- |   case result of\n-- |     Right lines ->\n-- |       Console.log (\"README: \\n\" <> lines )\n-- |     Left error ->\n-- |       Console.error (\"Couldn't open README.md. Error was: \" <> show error)\n-- | ```\n\ntry :: forall a. Effect a -> Effect (Either Error a)\ntry action = catchException (pure <<< Left) (Right <$> action)\n", "-- | This module defines the `MonadError` type class and its instances.\n\nmodule Control.Monad.Error.Class where\n\nimport Prelude\n\nimport Data.Either (Either(..), either)\nimport Data.Maybe (Maybe(..), maybe)\nimport Effect (Effect)\nimport Effect.Exception as Ex\n\n\n-- | The `MonadThrow` type class represents those monads which support errors via\n-- | `throwError`, where `throwError e` halts, yielding the error `e`.\n-- |\n-- | An implementation is provided for `ExceptT`, and for other monad transformers\n-- | defined in this library.\n-- |\n-- | Laws:\n-- |\n-- | - Left zero: `throwError e >>= f = throwError e`\n-- |\nclass Monad m <= MonadThrow e m | m -> e where\n  throwError :: forall a. e -> m a\n\n-- | The `MonadError` type class represents those monads which support catching\n-- | errors.\n-- |\n-- | - `catchError x f` calls the error handler `f` if an error is thrown during the\n-- |   evaluation of `x`.\n-- |\n-- | An implementation is provided for `ExceptT`, and for other monad transformers\n-- | defined in this library.\n-- |\n-- | Laws:\n-- |\n-- | - Catch: `catchError (throwError e) f = f e`\n-- | - Pure: `catchError (pure a) f = pure a`\n-- |\nclass MonadThrow e m <= MonadError e m | m -> e where\n  catchError :: forall a. m a -> (e -> m a) -> m a\n\n-- | This function allows you to provide a predicate for selecting the\n-- | exceptions that you're interested in, and handle only those exceptons.\n-- | If the inner computation throws an exception, and the predicate returns\n-- | Nothing, then the whole computation will still fail with that exception.\ncatchJust\n  :: forall e m a b\n   . MonadError e m\n  => (e -> Maybe b) -- ^ Predicate to select exceptions\n  -> m a            -- ^ Computation to run\n  -> (b -> m a)     -- ^ Handler\n  -> m a\ncatchJust p act handler = catchError act handle\n  where\n  handle e =\n    case p e of\n      Nothing -> throwError e\n      Just b -> handler b\n\n-- | Return `Right` if the given action succeeds, `Left` if it throws.\ntry\n  :: forall e m a\n   . MonadError e m\n  => m a\n  -> m (Either e a)\ntry a = (Right <$> a) `catchError` (pure <<< Left)\n\ninstance monadThrowEither :: MonadThrow e (Either e) where\n  throwError = Left\n\ninstance monadErrorEither :: MonadError e (Either e) where\n  catchError (Left e) h = h e\n  catchError (Right x) _ = Right x\n\ninstance monadThrowMaybe :: MonadThrow Unit Maybe where\n  throwError = const Nothing\n\ninstance monadErrorMaybe :: MonadError Unit Maybe where\n  catchError Nothing f  = f unit\n  catchError (Just a) _ = Just a\n \ninstance monadThrowEffect :: MonadThrow Ex.Error Effect where\n  throwError = Ex.throwException\n\ninstance monadErrorEffect :: MonadError Ex.Error Effect where\n  catchError = flip Ex.catchException\n\n\n-- | Make sure that a resource is cleaned up in the event of an exception. The\n-- | release action is called regardless of whether the body action throws or\n-- | returns.\nwithResource\n  :: forall e m r a\n   . MonadError e m\n  => m r\n  -> (r -> m Unit)\n  -> (r -> m a)\n  -> m a\nwithResource acquire release kleisli = do\n  resource <- acquire\n  result <- try $ kleisli resource\n  release resource\n  either throwError pure result\n\n-- | Lift a `Maybe` value to a MonadThrow monad.\nliftMaybe :: forall m e a. MonadThrow e m => e -> Maybe a -> m a\nliftMaybe error = maybe (throwError error) pure\n\n-- | Lift an `Either` value to a MonadThrow monad.\nliftEither :: forall m e a. MonadThrow e m => Either e a -> m a\nliftEither = either throwError pure\n", "module Data.Identity where\n\nimport Prelude\n\nimport Control.Alt (class Alt)\nimport Control.Comonad (class Comonad)\nimport Control.Extend (class Extend)\nimport Control.Lazy (class Lazy)\nimport Data.Eq (class Eq1)\nimport Data.Functor.Invariant (class Invariant, imapF)\nimport Data.Newtype (class Newtype)\nimport Data.Ord (class Ord1)\n\nnewtype Identity a = Identity a\n\nderive instance newtypeIdentity :: Newtype (Identity a) _\n\nderive newtype instance eqIdentity :: Eq a => Eq (Identity a)\n\nderive newtype instance ordIdentity :: Ord a => Ord (Identity a)\n\nderive newtype instance boundedIdentity :: Bounded a => Bounded (Identity a)\n\nderive newtype instance heytingAlgebraIdentity :: HeytingAlgebra a => HeytingAlgebra (Identity a)\n\nderive newtype instance booleanAlgebraIdentity :: BooleanAlgebra a => BooleanAlgebra (Identity a)\n\nderive newtype instance semigroupIdentity :: Semigroup a => Semigroup (Identity a)\n\nderive newtype instance monoidIdentity :: Monoid a => Monoid (Identity a)\n\nderive newtype instance semiringIdentity :: Semiring a => Semiring (Identity a)\n\nderive newtype instance euclideanRingIdentity :: EuclideanRing a => EuclideanRing (Identity a)\n\nderive newtype instance ringIdentity :: Ring a => Ring (Identity a)\n\nderive newtype instance commutativeRingIdentity :: CommutativeRing a => CommutativeRing (Identity a)\n\nderive newtype instance lazyIdentity :: Lazy a => Lazy (Identity a)\n\ninstance showIdentity :: Show a => Show (Identity a) where\n  show (Identity x) = \"(Identity \" <> show x <> \")\"\n\nderive instance eq1Identity :: Eq1 Identity\n\nderive instance ord1Identity :: Ord1 Identity\n\nderive instance functorIdentity :: Functor Identity\n\ninstance invariantIdentity :: Invariant Identity where\n  imap = imapF\n\ninstance altIdentity :: Alt Identity where\n  alt x _ = x\n\ninstance applyIdentity :: Apply Identity where\n  apply (Identity f) (Identity x) = Identity (f x)\n\ninstance applicativeIdentity :: Applicative Identity where\n  pure = Identity\n\ninstance bindIdentity :: Bind Identity where\n  bind (Identity m) f = f m\n\ninstance monadIdentity :: Monad Identity\n\ninstance extendIdentity :: Extend Identity where\n  extend f m = Identity (f m)\n\ninstance comonadIdentity :: Comonad Identity where\n  extract (Identity x) = x\n", "export const _new = function (val) {\n  return function () {\n    return { value: val };\n  };\n};\n\nexport const newWithSelf = function (f) {\n  return function () {\n    var ref = { value: null };\n    ref.value = f(ref);\n    return ref;\n  };\n};\n\nexport const read = function (ref) {\n  return function () {\n    return ref.value;\n  };\n};\n\nexport const modifyImpl = function (f) {\n  return function (ref) {\n    return function () {\n      var t = f(ref.value);\n      ref.value = t.state;\n      return t.value;\n    };\n  };\n};\n\nexport const write = function (val) {\n  return function (ref) {\n    return function () {\n      ref.value = val;\n    };\n  };\n};\n", "-- | This module defines the `Ref` type for mutable value references, as well\n-- | as actions for working with them.\n-- |\n-- | You'll notice that all of the functions that operate on a `Ref` (e.g.\n-- | `new`, `read`, `write`) return their result wrapped in an `Effect`.\n-- | Working with mutable references is considered effectful in PureScript\n-- | because of the principle of purity: functions should not have side\n-- | effects, and should return the same result when called with the same\n-- | arguments. If a `Ref` could be written to without using `Effect`, that\n-- | would cause a side effect (the effect of changing the result of subsequent\n-- | reads for that `Ref`). If there were a function for reading the current\n-- | value of a `Ref` without the result being wrapped in `Effect`, the result\n-- | of calling that function would change each time a new value was written to\n-- | the `Ref`. Even creating a new `Ref` is effectful: if there were a\n-- | function for creating a new `Ref` with the type `forall s. s -> Ref s`,\n-- | then calling that function twice with the same argument would not give the\n-- | same result in each case, since you'd end up with two distinct references\n-- | which could be updated independently of each other.\n-- |\n-- | _Note_: `Control.Monad.ST` provides a pure alternative to `Ref` when\n-- | mutation is restricted to a local scope.\nmodule Effect.Ref\n  ( Ref\n  , new\n  , newWithSelf\n  , read\n  , modify'\n  , modify\n  , modify_\n  , write\n  ) where\n\nimport Prelude\n\nimport Effect (Effect)\n\n-- | A value of type `Ref a` represents a mutable reference\n-- | which holds a value of type `a`.\nforeign import data Ref :: Type -> Type\n\ntype role Ref representational\n\n-- | Create a new mutable reference containing the specified value.\nforeign import _new :: forall s. s -> Effect (Ref s)\n\nnew :: forall s. s -> Effect (Ref s)\nnew = _new\n\n-- | Create a new mutable reference containing a value that can refer to the\n-- | `Ref` being created.\nforeign import newWithSelf :: forall s. (Ref s -> s) -> Effect (Ref s)\n\n-- | Read the current value of a mutable reference.\nforeign import read :: forall s. Ref s -> Effect s\n\n-- | Update the value of a mutable reference by applying a function\n-- | to the current value.\nmodify' :: forall s b. (s -> { state :: s, value :: b }) -> Ref s -> Effect b\nmodify' = modifyImpl\n\nforeign import modifyImpl :: forall s b. (s -> { state :: s, value :: b }) -> Ref s -> Effect b\n\n-- | Update the value of a mutable reference by applying a function\n-- | to the current value. The updated value is returned.\nmodify :: forall s. (s -> s) -> Ref s -> Effect s\nmodify f = modify' \\s -> let s' = f s in { state: s', value: s' }\n\n-- | A version of `modify` which does not return the updated value.\nmodify_ :: forall s. (s -> s) -> Ref s -> Effect Unit\nmodify_ f s = void $ modify f s\n\n-- | Update the value of a mutable reference to the specified value.\nforeign import write :: forall s. s -> Ref s -> Effect Unit\n", "module Control.Monad.Rec.Class\n  ( Step(..)\n  , class MonadRec\n  , tailRec\n  , tailRec2\n  , tailRec3\n  , tailRecM\n  , tailRecM2\n  , tailRecM3\n  , forever\n  , whileJust\n  , untilJust\n  , loop2\n  , loop3\n  ) where\n\nimport Prelude\n\nimport Data.Bifunctor (class Bifunctor)\nimport Data.Either (Either(..))\nimport Data.Identity (Identity(..))\nimport Data.Maybe (Maybe(..))\nimport Effect (Effect, untilE)\nimport Effect.Ref as Ref\nimport Partial.Unsafe (unsafePartial)\n\n-- | The result of a computation: either `Loop` containing the updated\n-- | accumulator, or `Done` containing the final result of the computation.\ndata Step a b = Loop a | Done b\n\nderive instance functorStep :: Functor (Step a)\n\ninstance bifunctorStep :: Bifunctor Step where\n  bimap f _ (Loop a) = Loop (f a)\n  bimap _ g (Done b) = Done (g b)\n\n-- | This type class captures those monads which support tail recursion in\n-- | constant stack space.\n-- |\n-- | The `tailRecM` function takes a step function, and applies that step\n-- | function recursively until a pure value of type `b` is found.\n-- |\n-- | Instances are provided for standard monad transformers.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | loopWriter :: Int -> WriterT (Additive Int) Effect Unit\n-- | loopWriter n = tailRecM go n\n-- |   where\n-- |   go 0 = do\n-- |     traceM \"Done!\"\n-- |     pure (Done unit)\n-- |   go i = do\n-- |     tell $ Additive i\n-- |     pure (Loop (i - 1))\n-- | ```\nclass Monad m <= MonadRec m where\n  tailRecM :: forall a b. (a -> m (Step a b)) -> a -> m b\n\n-- | Create a tail-recursive function of two arguments which uses constant stack space.\n-- |\n-- | The `loop2` helper function provides a curried alternative to the `Loop`\n-- | constructor for this function.\ntailRecM2\n  :: forall m a b c\n   . MonadRec m\n  => (a -> b -> m (Step { a :: a, b :: b } c))\n  -> a\n  -> b\n  -> m c\ntailRecM2 f a b = tailRecM (\\o -> f o.a o.b) { a, b }\n\n-- | Create a tail-recursive function of three arguments which uses constant stack space.\n-- |\n-- | The `loop3` helper function provides a curried alternative to the `Loop`\n-- | constructor for this function.\ntailRecM3\n  :: forall m a b c d\n   . MonadRec m\n  => (a -> b -> c -> m (Step { a :: a, b :: b, c :: c } d))\n  -> a\n  -> b\n  -> c\n  -> m d\ntailRecM3 f a b c = tailRecM (\\o -> f o.a o.b o.c) { a, b, c }\n\n-- | Create a pure tail-recursive function of one argument\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | pow :: Int -> Int -> Int\n-- | pow n p = tailRec go { accum: 1, power: p }\n-- |   where\n-- |   go :: _ -> Step _ Int\n-- |   go { accum: acc, power: 0 } = Done acc\n-- |   go { accum: acc, power: p } = Loop { accum: acc * n, power: p - 1 }\n-- | ```\ntailRec :: forall a b. (a -> Step a b) -> a -> b\ntailRec f = go <<< f\n  where\n  go (Loop a) = go (f a)\n  go (Done b) = b\n\n-- | Create a pure tail-recursive function of two arguments\n-- |\n-- | The `loop2` helper function provides a curried alternative to the `Loop`\n-- | constructor for this function.\ntailRec2 :: forall a b c. (a -> b -> Step { a :: a, b :: b } c) -> a -> b -> c\ntailRec2 f a b = tailRec (\\o -> f o.a o.b) { a, b }\n\n-- | Create a pure tail-recursive function of three arguments\n-- |\n-- | The `loop3` helper function provides a curried alternative to the `Loop`\n-- | constructor for this function.\ntailRec3 :: forall a b c d. (a -> b -> c -> Step { a :: a, b :: b, c :: c } d) -> a -> b -> c -> d\ntailRec3 f a b c = tailRec (\\o -> f o.a o.b o.c) { a, b, c }\n\ninstance monadRecIdentity :: MonadRec Identity where\n  tailRecM f = Identity <<< tailRec (runIdentity <<< f)\n    where runIdentity (Identity x) = x\n\ninstance monadRecEffect :: MonadRec Effect where\n  tailRecM f a = do\n    r <- Ref.new =<< f a\n    untilE do\n      Ref.read r >>= case _ of\n        Loop a' -> do\n          e <- f a'\n          _ <- Ref.write e r\n          pure false\n        Done _ -> pure true\n    fromDone <$> Ref.read r\n    where\n    fromDone :: forall a b. Step a b -> b\n    fromDone = unsafePartial \\(Done b) -> b\n\ninstance monadRecFunction :: MonadRec ((->) e) where\n  tailRecM f a0 e = tailRec (\\a -> f a e) a0\n\ninstance monadRecEither :: MonadRec (Either e) where\n  tailRecM f a0 =\n    let\n      g (Left e) = Done (Left e)\n      g (Right (Loop a)) = Loop (f a)\n      g (Right (Done b)) = Done (Right b)\n    in tailRec g (f a0)\n\ninstance monadRecMaybe :: MonadRec Maybe where\n  tailRecM f a0 =\n    let\n      g Nothing = Done Nothing\n      g (Just (Loop a)) = Loop (f a)\n      g (Just (Done b)) = Done (Just b)\n    in tailRec g (f a0)\n\n-- | `forever` runs an action indefinitely, using the `MonadRec` instance to\n-- | ensure constant stack usage.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | main = forever $ trace \"Hello, World!\"\n-- | ```\nforever :: forall m a b. MonadRec m => m a -> m b\nforever ma = tailRecM (\\u -> Loop u <$ ma) unit\n\n-- | While supplied computation evaluates to `Just _`, it will be\n-- | executed repeatedly and results will be combined using monoid instance.\nwhileJust :: forall a m. Monoid a => MonadRec m => m (Maybe a) -> m a\nwhileJust m = mempty # tailRecM \\v -> m <#> case _ of\n  Nothing -> Done v\n  Just x -> Loop $ v <> x\n\n-- | Supplied computation will be executed repeatedly until it evaluates\n-- | to `Just value` and then that `value` will be returned.\nuntilJust :: forall a m. MonadRec m => m (Maybe a) -> m a\nuntilJust m = unit # tailRecM \\_ -> m <#> case _ of\n  Nothing -> Loop unit\n  Just x -> Done x\n\n-- | A curried version of the `Loop` constructor, provided as a convenience for\n-- | use with `tailRec2` and `tailRecM2`.\nloop2 :: forall a b c. a -> b -> Step { a :: a, b :: b } c\nloop2 a b = Loop { a, b }\n\n-- | A curried version of the `Loop` constructor, provided as a convenience for\n-- | use with `tailRec3` and `tailRecM3`.\nloop3 :: forall a b c d. a -> b -> c -> Step { a :: a, b :: b, c :: c } d\nloop3 a b c = Loop { a, b, c }\n", "// module Unsafe.Coerce\n\nexport const unsafeCoerce = function (x) {\n  return x;\n};\n", "module Control.Monad.ST.Global\n  ( Global\n  , toEffect\n  ) where\n\nimport Prelude\n\nimport Control.Monad.ST (ST, Region)\nimport Effect (Effect)\nimport Unsafe.Coerce (unsafeCoerce)\n\n-- | This region allows `ST` computations to be converted into `Effect`\n-- | computations so they can be run in a global context.\nforeign import data Global :: Region\n\n-- | Converts an `ST` computation into an `Effect` computation.\ntoEffect :: ST Global ~> Effect\ntoEffect = unsafeCoerce\n", "export const map_ = function (f) {\n  return function (a) {\n    return function () {\n      return f(a());\n    };\n  };\n};\n\nexport const pure_ = function (a) {\n  return function () {\n    return a;\n  };\n};\n\nexport const bind_ = function (a) {\n  return function (f) {\n    return function () {\n      return f(a())();\n    };\n  };\n};\n\nexport const run = function (f) {\n  return f();\n};\n\nfunction whileST(f) {\n  return function (a) {\n    return function () {\n      while (f()) {\n        a();\n      }\n    };\n  };\n}\nexport { whileST as while };\n\nfunction forST(lo) {\n  return function (hi) {\n    return function (f) {\n      return function () {\n        for (var i = lo; i < hi; i++) {\n          f(i)();\n        }\n      };\n    };\n  };\n}\nexport { forST as for };\n\nexport const foreach = function (as) {\n  return function (f) {\n    return function () {\n      for (var i = 0, l = as.length; i < l; i++) {\n        f(as[i])();\n      }\n    };\n  };\n};\n\nfunction newSTRef(val) {\n  return function () {\n    return { value: val };\n  };\n}\nexport { newSTRef as new };\n\nexport const read = function (ref) {\n  return function () {\n    return ref.value;\n  };\n};\n\nexport const modifyImpl = function (f) {\n  return function (ref) {\n    return function () {\n      var t = f(ref.value);\n      ref.value = t.state;\n      return t.value;\n    };\n  };\n};\n\nexport const write = function (a) {\n  return function (ref) {\n    return function () {\n      return ref.value = a; // eslint-disable-line no-return-assign\n    };\n  };\n};\n", "module Control.Monad.ST.Internal\n  ( Region\n  , ST\n  , run\n  , while\n  , for\n  , foreach\n  , STRef\n  , new\n  , read\n  , modify'\n  , modify\n  , write\n  ) where\n\nimport Prelude\n\nimport Control.Apply (lift2)\nimport Control.Monad.Rec.Class (class MonadRec, Step(..))\nimport Partial.Unsafe (unsafePartial)\n\n-- | `ST` is concerned with _restricted_ mutation. Mutation is restricted to a\n-- | _region_ of mutable references. This kind is inhabited by phantom types\n-- | which represent regions in the type system.\nforeign import data Region :: Type\n\n-- | The `ST` type constructor allows _local mutation_, i.e. mutation which\n-- | does not \"escape\" into the surrounding computation.\n-- |\n-- | An `ST` computation is parameterized by a phantom type which is used to\n-- | restrict the set of reference cells it is allowed to access.\n-- |\n-- | The `run` function can be used to run a computation in the `ST` monad.\nforeign import data ST :: Region -> Type -> Type\n\ntype role ST nominal representational\n\nforeign import map_ :: forall r a b. (a -> b) -> ST r a -> ST r b\n\nforeign import pure_ :: forall r a. a -> ST r a\n\nforeign import bind_ :: forall r a b. ST r a -> (a -> ST r b) -> ST r b\n\ninstance functorST :: Functor (ST r) where\n  map = map_\n\ninstance applyST :: Apply (ST r) where\n  apply = ap\n\ninstance applicativeST :: Applicative (ST r) where\n  pure = pure_\n\ninstance bindST :: Bind (ST r) where\n  bind = bind_\n\ninstance monadST :: Monad (ST r)\n\ninstance monadRecST :: MonadRec (ST r) where\n  tailRecM f a = do\n    r <- new =<< f a\n    while (isLooping <$> read r) do\n      read r >>= case _ of\n        Loop a' -> do\n          e <- f a'\n          void (write e r)\n        Done _ -> pure unit\n    fromDone <$> read r\n    where\n      fromDone :: forall a b. Step a b -> b\n      fromDone = unsafePartial \\(Done b) -> b\n\n      isLooping = case _ of\n        Loop _ -> true\n        _ -> false\n\ninstance semigroupST :: Semigroup a => Semigroup (ST r a) where\n  append = lift2 append\n\ninstance monoidST :: Monoid a => Monoid (ST r a) where\n  mempty = pure mempty\n\n-- | Run an `ST` computation.\n-- |\n-- | Note: the type of `run` uses a rank-2 type to constrain the phantom\n-- | type `r`, such that the computation must not leak any mutable references\n-- | to the surrounding computation. It may cause problems to apply this\n-- | function using the `$` operator. The recommended approach is to use\n-- | parentheses instead.\nforeign import run :: forall a. (forall r. ST r a) -> a\n\n-- | Loop while a condition is `true`.\n-- |\n-- | `while b m` is ST computation which runs the ST computation `b`. If its\n-- | result is `true`, it runs the ST computation `m` and loops. If not, the\n-- | computation ends.\nforeign import while :: forall r a. ST r Boolean -> ST r a -> ST r Unit\n\n-- | Loop over a consecutive collection of numbers\n-- |\n-- | `ST.for lo hi f` runs the computation returned by the function `f` for each\n-- | of the inputs between `lo` (inclusive) and `hi` (exclusive).\nforeign import for :: forall r a. Int -> Int -> (Int -> ST r a) -> ST r Unit\n\n-- | Loop over an array of values.\n-- |\n-- | `ST.foreach xs f` runs the computation returned by the function `f` for each\n-- | of the inputs `xs`.\nforeign import foreach :: forall r a. Array a -> (a -> ST r Unit) -> ST r Unit\n\n-- | The type `STRef r a` represents a mutable reference holding a value of\n-- | type `a`, which can be used with the `ST r` effect.\nforeign import data STRef :: Region -> Type -> Type\n\ntype role STRef nominal representational\n\n-- | Create a new mutable reference.\nforeign import new :: forall a r. a -> ST r (STRef r a)\n\n-- | Read the current value of a mutable reference.\nforeign import read :: forall a r. STRef r a -> ST r a\n\n-- | Update the value of a mutable reference by applying a function\n-- | to the current value, computing a new state value for the reference and\n-- | a return value.\nmodify' :: forall r a b. (a -> { state :: a, value :: b }) -> STRef r a -> ST r b\nmodify' = modifyImpl\n\nforeign import modifyImpl :: forall r a b. (a -> { state :: a, value :: b }) -> STRef r a -> ST r b\n\n-- | Modify the value of a mutable reference by applying a function to the\n-- | current value. The modified value is returned.\nmodify :: forall r a. (a -> a) -> STRef r a -> ST r a\nmodify f = modify' \\s -> let s' = f s in { state: s', value: s' }\n\n-- | Set the value of a mutable reference.\nforeign import write :: forall a r. a -> STRef r a -> ST r a\n", "export const boolConj = function (b1) {\n  return function (b2) {\n    return b1 && b2;\n  };\n};\n\nexport const boolDisj = function (b1) {\n  return function (b2) {\n    return b1 || b2;\n  };\n};\n\nexport const boolNot = function (b) {\n  return !b;\n};\n", "module Data.HeytingAlgebra\n  ( class HeytingAlgebra\n  , tt\n  , ff\n  , implies\n  , conj\n  , disj\n  , not\n  , (&&)\n  , (||)\n  , class HeytingAlgebraRecord\n  , ffRecord\n  , ttRecord\n  , impliesRecord\n  , conjRecord\n  , disjRecord\n  , notRecord\n  ) where\n\nimport Data.Symbol (class IsSymbol, reflectSymbol)\nimport Data.Unit (Unit, unit)\nimport Prim.Row as Row\nimport Prim.RowList as RL\nimport Record.Unsafe (unsafeGet, unsafeSet)\nimport Type.Proxy (Proxy(..))\n\n-- | The `HeytingAlgebra` type class represents types that are bounded lattices with\n-- | an implication operator such that the following laws hold:\n-- |\n-- | - Associativity:\n-- |   - `a || (b || c) = (a || b) || c`\n-- |   - `a && (b && c) = (a && b) && c`\n-- | - Commutativity:\n-- |   - `a || b = b || a`\n-- |   - `a && b = b && a`\n-- | - Absorption:\n-- |   - `a || (a && b) = a`\n-- |   - `a && (a || b) = a`\n-- | - Idempotent:\n-- |   - `a || a = a`\n-- |   - `a && a = a`\n-- | - Identity:\n-- |   - `a || ff = a`\n-- |   - `a && tt = a`\n-- | - Implication:\n-- |   - ``a `implies` a = tt``\n-- |   - ``a && (a `implies` b) = a && b``\n-- |   - ``b && (a `implies` b) = b``\n-- |   - ``a `implies` (b && c) = (a `implies` b) && (a `implies` c)``\n-- | - Complemented:\n-- |   - ``not a = a `implies` ff``\nclass HeytingAlgebra a where\n  ff :: a\n  tt :: a\n  implies :: a -> a -> a\n  conj :: a -> a -> a\n  disj :: a -> a -> a\n  not :: a -> a\n\ninfixr 3 conj as &&\ninfixr 2 disj as ||\n\ninstance heytingAlgebraBoolean :: HeytingAlgebra Boolean where\n  ff = false\n  tt = true\n  implies a b = not a || b\n  conj = boolConj\n  disj = boolDisj\n  not = boolNot\n\ninstance heytingAlgebraUnit :: HeytingAlgebra Unit where\n  ff = unit\n  tt = unit\n  implies _ _ = unit\n  conj _ _ = unit\n  disj _ _ = unit\n  not _ = unit\n\ninstance heytingAlgebraFunction :: HeytingAlgebra b => HeytingAlgebra (a -> b) where\n  ff _ = ff\n  tt _ = tt\n  implies f g a = f a `implies` g a\n  conj f g a = f a && g a\n  disj f g a = f a || g a\n  not f a = not (f a)\n\ninstance heytingAlgebraProxy :: HeytingAlgebra (Proxy a) where\n  conj _ _ = Proxy\n  disj _ _ = Proxy\n  implies _ _ = Proxy\n  ff = Proxy\n  not _ = Proxy\n  tt = Proxy\n\ninstance heytingAlgebraRecord :: (RL.RowToList row list, HeytingAlgebraRecord list row row) => HeytingAlgebra (Record row) where\n  ff = ffRecord (Proxy :: Proxy list) (Proxy :: Proxy row)\n  tt = ttRecord (Proxy :: Proxy list) (Proxy :: Proxy row)\n  conj = conjRecord (Proxy :: Proxy list)\n  disj = disjRecord (Proxy :: Proxy list)\n  implies = impliesRecord (Proxy :: Proxy list)\n  not = notRecord (Proxy :: Proxy list)\n\nforeign import boolConj :: Boolean -> Boolean -> Boolean\nforeign import boolDisj :: Boolean -> Boolean -> Boolean\nforeign import boolNot :: Boolean -> Boolean\n\n-- | A class for records where all fields have `HeytingAlgebra` instances, used\n-- | to implement the `HeytingAlgebra` instance for records.\nclass HeytingAlgebraRecord :: RL.RowList Type -> Row Type -> Row Type -> Constraint\nclass HeytingAlgebraRecord rowlist row subrow | rowlist -> subrow where\n  ffRecord :: Proxy rowlist -> Proxy row -> Record subrow\n  ttRecord :: Proxy rowlist -> Proxy row -> Record subrow\n  impliesRecord :: Proxy rowlist -> Record row -> Record row -> Record subrow\n  disjRecord :: Proxy rowlist -> Record row -> Record row -> Record subrow\n  conjRecord :: Proxy rowlist -> Record row -> Record row -> Record subrow\n  notRecord :: Proxy rowlist -> Record row -> Record subrow\n\ninstance heytingAlgebraRecordNil :: HeytingAlgebraRecord RL.Nil row () where\n  conjRecord _ _ _ = {}\n  disjRecord _ _ _ = {}\n  ffRecord _ _ = {}\n  impliesRecord _ _ _ = {}\n  notRecord _ _ = {}\n  ttRecord _ _ = {}\n\ninstance heytingAlgebraRecordCons ::\n  ( IsSymbol key\n  , Row.Cons key focus subrowTail subrow\n  , HeytingAlgebraRecord rowlistTail row subrowTail\n  , HeytingAlgebra focus\n  ) =>\n  HeytingAlgebraRecord (RL.Cons key focus rowlistTail) row subrow where\n  conjRecord _ ra rb = insert (conj (get ra) (get rb)) tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    get = unsafeGet key :: Record row -> focus\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n    tail = conjRecord (Proxy :: Proxy rowlistTail) ra rb\n\n  disjRecord _ ra rb = insert (disj (get ra) (get rb)) tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    get = unsafeGet key :: Record row -> focus\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n    tail = disjRecord (Proxy :: Proxy rowlistTail) ra rb\n\n  impliesRecord _ ra rb = insert (implies (get ra) (get rb)) tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    get = unsafeGet key :: Record row -> focus\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n    tail = impliesRecord (Proxy :: Proxy rowlistTail) ra rb\n\n  ffRecord _ row = insert ff tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n    tail = ffRecord (Proxy :: Proxy rowlistTail) row\n\n  notRecord _ row = insert (not (get row)) tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    get = unsafeGet key :: Record row -> focus\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n    tail = notRecord (Proxy :: Proxy rowlistTail) row\n\n  ttRecord _ row = insert tt tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n    tail = ttRecord (Proxy :: Proxy rowlistTail) row\n", "-- | A data type and functions for working with ordered pairs.\nmodule Data.Tuple where\n\nimport Prelude\n\nimport Control.Comonad (class Comonad)\nimport Control.Extend (class Extend)\nimport Control.Lazy (class Lazy, defer)\nimport Data.Eq (class Eq1)\nimport Data.Functor.Invariant (class Invariant, imapF)\nimport Data.Generic.Rep (class Generic)\nimport Data.HeytingAlgebra (implies, ff, tt)\nimport Data.Ord (class Ord1)\n\n-- | A simple product type for wrapping a pair of component values.\ndata Tuple a b = Tuple a b\n\n-- | Allows `Tuple`s to be rendered as a string with `show` whenever there are\n-- | `Show` instances for both component types.\ninstance showTuple :: (Show a, Show b) => Show (Tuple a b) where\n  show (Tuple a b) = \"(Tuple \" <> show a <> \" \" <> show b <> \")\"\n\n-- | Allows `Tuple`s to be checked for equality with `==` and `/=` whenever\n-- | there are `Eq` instances for both component types.\nderive instance eqTuple :: (Eq a, Eq b) => Eq (Tuple a b)\n\nderive instance eq1Tuple :: Eq a => Eq1 (Tuple a)\n\n-- | Allows `Tuple`s to be compared with `compare`, `>`, `>=`, `<` and `<=`\n-- | whenever there are `Ord` instances for both component types. To obtain\n-- | the result, the `fst`s are `compare`d, and if they are `EQ`ual, the\n-- | `snd`s are `compare`d.\nderive instance ordTuple :: (Ord a, Ord b) => Ord (Tuple a b)\n\nderive instance ord1Tuple :: Ord a => Ord1 (Tuple a)\n\ninstance boundedTuple :: (Bounded a, Bounded b) => Bounded (Tuple a b) where\n  top = Tuple top top\n  bottom = Tuple bottom bottom\n\ninstance semigroupoidTuple :: Semigroupoid Tuple where\n  compose (Tuple _ c) (Tuple a _) = Tuple a c\n\n-- | The `Semigroup` instance enables use of the associative operator `<>` on\n-- | `Tuple`s whenever there are `Semigroup` instances for the component\n-- | types. The `<>` operator is applied pairwise, so:\n-- | ```purescript\n-- | (Tuple a1 b1) <> (Tuple a2 b2) = Tuple (a1 <> a2) (b1 <> b2)\n-- | ```\ninstance semigroupTuple :: (Semigroup a, Semigroup b) => Semigroup (Tuple a b) where\n  append (Tuple a1 b1) (Tuple a2 b2) = Tuple (a1 <> a2) (b1 <> b2)\n\ninstance monoidTuple :: (Monoid a, Monoid b) => Monoid (Tuple a b) where\n  mempty = Tuple mempty mempty\n\ninstance semiringTuple :: (Semiring a, Semiring b) => Semiring (Tuple a b) where\n  add (Tuple x1 y1) (Tuple x2 y2) = Tuple (add x1 x2) (add y1 y2)\n  one = Tuple one one\n  mul (Tuple x1 y1) (Tuple x2 y2) = Tuple (mul x1 x2) (mul y1 y2)\n  zero = Tuple zero zero\n\ninstance ringTuple :: (Ring a, Ring b) => Ring (Tuple a b) where\n  sub (Tuple x1 y1) (Tuple x2 y2) = Tuple (sub x1 x2) (sub y1 y2)\n\ninstance commutativeRingTuple :: (CommutativeRing a, CommutativeRing b) => CommutativeRing (Tuple a b)\n\ninstance heytingAlgebraTuple :: (HeytingAlgebra a, HeytingAlgebra b) => HeytingAlgebra (Tuple a b) where\n  tt = Tuple tt tt\n  ff = Tuple ff ff\n  implies (Tuple x1 y1) (Tuple x2 y2) = Tuple (x1 `implies` x2) (y1 `implies` y2)\n  conj (Tuple x1 y1) (Tuple x2 y2) = Tuple (conj x1 x2) (conj y1 y2)\n  disj (Tuple x1 y1) (Tuple x2 y2) = Tuple (disj x1 x2) (disj y1 y2)\n  not (Tuple x y) = Tuple (not x) (not y)\n\ninstance booleanAlgebraTuple :: (BooleanAlgebra a, BooleanAlgebra b) => BooleanAlgebra (Tuple a b)\n\n-- | The `Functor` instance allows functions to transform the contents of a\n-- | `Tuple` with the `<$>` operator, applying the function to the second\n-- | component, so:\n-- | ```purescript\n-- | f <$> (Tuple x y) = Tuple x (f y)\n-- | ````\nderive instance functorTuple :: Functor (Tuple a)\n\nderive instance genericTuple :: Generic (Tuple a b) _\n\ninstance invariantTuple :: Invariant (Tuple a) where\n  imap = imapF\n\n-- | The `Apply` instance allows functions to transform the contents of a\n-- | `Tuple` with the `<*>` operator whenever there is a `Semigroup` instance\n-- | for the `fst` component, so:\n-- | ```purescript\n-- | (Tuple a1 f) <*> (Tuple a2 x) == Tuple (a1 <> a2) (f x)\n-- | ```\ninstance applyTuple :: (Semigroup a) => Apply (Tuple a) where\n  apply (Tuple a1 f) (Tuple a2 x) = Tuple (a1 <> a2) (f x)\n\ninstance applicativeTuple :: (Monoid a) => Applicative (Tuple a) where\n  pure = Tuple mempty\n\ninstance bindTuple :: (Semigroup a) => Bind (Tuple a) where\n  bind (Tuple a1 b) f = case f b of\n    Tuple a2 c -> Tuple (a1 <> a2) c\n\ninstance monadTuple :: (Monoid a) => Monad (Tuple a)\n\ninstance extendTuple :: Extend (Tuple a) where\n  extend f t@(Tuple a _) = Tuple a (f t)\n\ninstance comonadTuple :: Comonad (Tuple a) where\n  extract = snd\n\ninstance lazyTuple :: (Lazy a, Lazy b) => Lazy (Tuple a b) where\n  defer f = Tuple (defer $ \\_ -> fst (f unit)) (defer $ \\_ -> snd (f unit))\n\n-- | Returns the first component of a tuple.\nfst :: forall a b. Tuple a b -> a\nfst (Tuple a _) = a\n\n-- | Returns the second component of a tuple.\nsnd :: forall a b. Tuple a b -> b\nsnd (Tuple _ b) = b\n\n-- | Turn a function that expects a tuple into a function of two arguments.\ncurry :: forall a b c. (Tuple a b -> c) -> a -> b -> c\ncurry f a b = f (Tuple a b)\n\n-- | Turn a function of two arguments into a function that expects a tuple.\nuncurry :: forall a b c. (a -> b -> c) -> Tuple a b -> c\nuncurry f (Tuple a b) = f a b\n\n-- | Exchange the first and second components of a tuple.\nswap :: forall a b. Tuple a b -> Tuple b a\nswap (Tuple a b) = Tuple b a\n", "-- | This module defines the `MonadState` type class and its instances.\n\nmodule Control.Monad.State.Class where\n\nimport Prelude (class Monad, Unit, unit)\n\nimport Data.Tuple (Tuple(..))\n\n-- | The `MonadState s` type class represents those monads which support a single piece of mutable\n-- | state of type `s`.\n-- |\n-- | - `state f` updates the state using the function `f`.\n-- |\n-- | An implementation is provided for `StateT`, and for other monad transformers\n-- | defined in this library.\n-- |\n-- | Laws:\n-- |\n-- | - `do { get ; get } = get`\n-- | - `do { put x ; put y } = put y`\n-- | - `do { put x ; get } = put x $> x`\n-- | - `do { s <- get ; put s } = pure unit`\n-- |\nclass Monad m <= MonadState s m | m -> s where\n  state :: forall a. (s -> (Tuple a s)) -> m a\n\n-- | Get the current state.\nget :: forall m s. MonadState s m => m s\nget = state \\s -> Tuple s s\n\n-- | Get a value which depends on the current state.\ngets :: forall s m a. MonadState s m => (s -> a) -> m a\ngets f = state \\s -> Tuple (f s) s\n\n-- | Set the state.\nput :: forall m s. MonadState s m => s -> m Unit\nput s = state \\_ -> Tuple unit s\n\n-- | Modify the state by applying a function to the current state. The returned\n-- | value is the new state value.\nmodify :: forall s m. MonadState s m => (s -> s) -> m s\nmodify f = state \\s -> let s' = f s in Tuple s' s'\n\nmodify_ :: forall s m. MonadState s m => (s -> s) -> m Unit\nmodify_ f = state \\s -> Tuple unit (f s)\n", "-- | This module defines the `MonadTrans` type class of _monad transformers_.\n\nmodule Control.Monad.Trans.Class where\n\nimport Prelude (class Monad)\n\n-- | The `MonadTrans` type class represents _monad transformers_.\n-- |\n-- | A monad transformer is a type constructor of kind `(* -> *) -> * -> *`, which\n-- | takes a `Monad` as its first argument, and returns another `Monad`.\n-- |\n-- | This allows us to add additional effects to an existing monad. By iterating this\n-- | process, we create monad transformer _stacks_, which contain all of the effects\n-- | required for a particular computation.\n-- |\n-- | The laws state that `lift` is a `Monad` morphism.\n-- |\n-- | Laws:\n-- |\n-- | - `lift (pure a) = pure a`\n-- | - `lift (do { x <- m ; y }) = do { x <- lift m ; lift y }`\nclass MonadTrans t where\n  lift :: forall m a. Monad m => m a -> t m a\n", "module Effect.Class where\n\nimport Control.Category (identity)\nimport Control.Monad (class Monad)\nimport Effect (Effect)\n\n-- | The `MonadEffect` class captures those monads which support native effects.\n-- |\n-- | Instances are provided for `Effect` itself, and the standard monad\n-- | transformers.\n-- |\n-- | `liftEffect` can be used in any appropriate monad transformer stack to lift an\n-- | action of type `Effect a` into the monad.\n-- |\nclass Monad m <= MonadEffect m where\n  liftEffect :: forall a. Effect a -> m a\n\ninstance monadEffectEffect :: MonadEffect Effect where\n  liftEffect = identity\n", "-- | This module defines the `MonadWriter` type class and its instances.\n\nmodule Control.Monad.Writer.Class where\n\nimport Prelude\n\nimport Data.Tuple (Tuple(..))\n\n-- | The `MonadTell w` type class represents those monads which support a\n-- | monoidal accumulator of type `w`, where `tell` appends a value to the\n-- | accumulator.\n-- |\n-- | An implementation is provided for `WriterT`, and for other monad\n-- | transformers defined in this library.\n-- |\n-- | Law:\n-- |\n-- | - `do { tell x ; tell y } = tell (x <> y)`\nclass (Semigroup w, Monad m) <= MonadTell w m | m -> w where\n  tell :: w -> m Unit\n\n-- | An extension of the `MonadTell` class that introduces some operations on\n-- | the accumulator:\n-- |\n-- | - `listen` modifies the result to include the changes to the accumulator.\n-- | - `pass` applies the returned function to the accumulator.\n-- |\n-- | An implementation is provided for `WriterT`, and for other monad\n-- | transformers defined in this library.\n-- |\n-- | Laws in addition to the `MonadTell` law:\n-- |\n-- | - `do { tell x ; tell y } = tell (x <> y)`\n-- | - `listen (pure a) = pure (Tuple a mempty)`\n-- | - `listen (writer a x) = tell x $> Tuple a x`\nclass (Monoid w, MonadTell w m) <= MonadWriter w m | m -> w where\n  listen :: forall a. m a -> m (Tuple a w)\n  pass :: forall a. m (Tuple a (w -> w)) -> m a\n\n-- | Projects a value from modifications made to the accumulator during an\n-- | action.\nlistens :: forall w m a b. MonadWriter w m => (w -> b) -> m a -> m (Tuple a b)\nlistens f m = do\n  Tuple a w <- listen m\n  pure $ Tuple a (f w)\n\n-- | Modify the final accumulator value by applying a function.\ncensor :: forall w m a. MonadWriter w m => (w -> w) -> m a -> m a\ncensor f m = pass do\n  a <- m\n  pure $ Tuple a f\n", "module Control.Plus\n  ( class Plus, empty\n  , module Control.Alt\n  , module Data.Functor\n  ) where\n\nimport Control.Alt (class Alt, alt, (<|>))\n\nimport Data.Functor (class Functor, map, void, ($>), (<#>), (<$), (<$>))\n\n-- | The `Plus` type class extends the `Alt` type class with a value that\n-- | should be the left and right identity for `(<|>)`.\n-- |\n-- | It is similar to `Monoid`, except that it applies to types of\n-- | kind `* -> *`, like `Array` or `List`, rather than concrete types like\n-- | `String` or `Number`.\n-- |\n-- | `Plus` instances should satisfy the following laws:\n-- |\n-- | - Left identity: `empty <|> x == x`\n-- | - Right identity: `x <|> empty == x`\n-- | - Annihilation: `f <$> empty == empty`\nclass Alt f <= Plus f where\n  empty :: forall a. f a\n\ninstance plusArray :: Plus Array where\n  empty = []\n", "module Safe.Coerce\n  ( module Prim.Coerce\n  , coerce\n  ) where\n\nimport Prim.Coerce (class Coercible)\nimport Unsafe.Coerce (unsafeCoerce)\n\n-- | Coerce a value of one type to a value of some other type, without changing\n-- | its runtime representation. This function behaves identically to\n-- | `unsafeCoerce` at runtime. Unlike `unsafeCoerce`, it is safe, because the\n-- | `Coercible` constraint prevents any use of this function from compiling\n-- | unless the compiler can prove that the two types have the same runtime\n-- | representation.\n-- |\n-- | One application for this function is to avoid doing work that you know is a\n-- | no-op because of newtypes. For example, if you have an `Array (Conj a)` and you\n-- | want an `Array (Disj a)`, you could do `Data.Array.map (un Conj >>> Disj)`, but\n-- | this performs an unnecessary traversal of the array, with O(n) cost.\n-- | `coerce` accomplishes the same with only O(1) cost:\n-- |\n-- | ```purescript\n-- | mapConjToDisj :: forall a. Array (Conj a) -> Array (Disj a)\n-- | mapConjToDisj = coerce\n-- | ```\ncoerce :: forall a b. Coercible a b => a -> b\ncoerce = unsafeCoerce\n", "module Data.Newtype where\n\nimport Data.Monoid.Additive (Additive(..))\nimport Data.Monoid.Conj (Conj(..))\nimport Data.Monoid.Disj (Disj(..))\nimport Data.Monoid.Dual (Dual(..))\nimport Data.Monoid.Endo (Endo(..))\nimport Data.Monoid.Multiplicative (Multiplicative(..))\nimport Data.Semigroup.First (First(..))\nimport Data.Semigroup.Last (Last(..))\nimport Safe.Coerce (class Coercible, coerce)\n\n-- | A type class for `newtype`s to enable convenient wrapping and unwrapping,\n-- | and the use of the other functions in this module.\n-- |\n-- | The compiler can derive instances of `Newtype` automatically:\n-- |\n-- | ``` purescript\n-- | newtype EmailAddress = EmailAddress String\n-- |\n-- | derive instance newtypeEmailAddress :: Newtype EmailAddress _\n-- | ```\n-- |\n-- | Note that deriving for `Newtype` instances requires that the type be\n-- | defined as `newtype` rather than `data` declaration (even if the `data`\n-- | structurally fits the rules of a `newtype`), and the use of a wildcard for\n-- | the wrapped type.\nclass Newtype :: Type -> Type -> Constraint\nclass Coercible t a <= Newtype t a | t -> a\n\nwrap :: forall t a. Newtype t a => a -> t\nwrap = coerce\n\nunwrap :: forall t a. Newtype t a => t -> a\nunwrap = coerce\n\ninstance newtypeAdditive :: Newtype (Additive a) a\n\ninstance newtypeMultiplicative :: Newtype (Multiplicative a) a\n\ninstance newtypeConj :: Newtype (Conj a) a\n\ninstance newtypeDisj :: Newtype (Disj a) a\n\ninstance newtypeDual :: Newtype (Dual a) a\n\ninstance newtypeEndo :: Newtype (Endo c a) (c a a)\n\ninstance newtypeFirst :: Newtype (First a) a\n\ninstance newtypeLast :: Newtype (Last a) a\n\n-- | Given a constructor for a `Newtype`, this returns the appropriate `unwrap`\n-- | function.\nun :: forall t a. Newtype t a => (a -> t) -> t -> a\nun _ = unwrap\n\n-- | This combinator unwraps the newtype, applies a monomorphic function to the \n-- | contained value and wraps the result back in the newtype\nmodify :: forall t a. Newtype t a => (a -> a) -> t -> t\nmodify fn t = wrap (fn (unwrap t))\n\n-- | This combinator is for when you have a higher order function that you want\n-- | to use in the context of some newtype - `foldMap` being a common example:\n-- |\n-- | ``` purescript\n-- | ala Additive foldMap [1,2,3,4] -- 10\n-- | ala Multiplicative foldMap [1,2,3,4] -- 24\n-- | ala Conj foldMap [true, false] -- false\n-- | ala Disj foldMap [true, false] -- true\n-- | ```\nala\n  :: forall f t a s b\n   . Coercible (f t) (f a)\n  => Newtype t a\n  => Newtype s b\n  => (a -> t)\n  -> ((b -> s) -> f t)\n  -> f a\nala _ f = coerce (f wrap)\n\n-- | Similar to `ala` but useful for cases where you want to use an additional\n-- | projection with the higher order function:\n-- |\n-- | ``` purescript\n-- | alaF Additive foldMap String.length [\"hello\", \"world\"] -- 10\n-- | alaF Multiplicative foldMap Math.abs [1.0, -2.0, 3.0, -4.0] -- 24.0\n-- | ```\n-- |\n-- | The type admits other possibilities due to the polymorphic `Functor`\n-- | constraints, but the case described above works because ((->) a) is a\n-- | `Functor`.\nalaF\n  :: forall f g t a s b\n   . Coercible (f t) (f a)\n  => Coercible (g s) (g b)\n  => Newtype t a\n  => Newtype s b\n  => (a -> t)\n  -> (f t -> g s)\n  -> f a\n  -> g b\nalaF _ = coerce\n\n-- | Lifts a function operate over newtypes. This can be used to lift a\n-- | function to manipulate the contents of a single newtype, somewhat like\n-- | `map` does for a `Functor`:\n-- |\n-- | ``` purescript\n-- | newtype Label = Label String\n-- | derive instance newtypeLabel :: Newtype Label _\n-- |\n-- | toUpperLabel :: Label -> Label\n-- | toUpperLabel = over Label String.toUpper\n-- | ```\n-- |\n-- | But the result newtype is polymorphic, meaning the result can be returned\n-- | as an alternative newtype:\n-- |\n-- | ``` purescript\n-- | newtype UppercaseLabel = UppercaseLabel String\n-- | derive instance newtypeUppercaseLabel :: Newtype UppercaseLabel _\n-- |\n-- | toUpperLabel' :: Label -> UppercaseLabel\n-- | toUpperLabel' = over Label String.toUpper\n-- | ```\nover\n  :: forall t a s b\n   . Newtype t a\n  => Newtype s b\n  => (a -> t)\n  -> (a -> b)\n  -> t\n  -> s\nover _ = coerce\n\n-- | Much like `over`, but where the lifted function operates on values in a\n-- | `Functor`:\n-- |\n-- | ``` purescript\n-- | findLabel :: String -> Array Label -> Maybe Label\n-- | findLabel s = overF Label (Foldable.find (_ == s))\n-- | ```\n-- |\n-- | The above example also demonstrates that the functor type is polymorphic\n-- | here too, the input is an `Array` but the result is a `Maybe`.\noverF\n  :: forall f g t a s b\n   . Coercible (f a) (f t)\n  => Coercible (g b) (g s)\n  => Newtype t a\n  => Newtype s b\n  => (a -> t)\n  -> (f a -> g b)\n  -> f t\n  -> g s\noverF _ = coerce\n\n-- | The opposite of `over`: lowers a function that operates on `Newtype`d\n-- | values to operate on the wrapped value instead.\n-- |\n-- | ``` purescript\n-- | newtype Degrees = Degrees Number\n-- | derive instance newtypeDegrees :: Newtype Degrees _\n-- |\n-- | newtype NormalDegrees = NormalDegrees Number\n-- | derive instance newtypeNormalDegrees :: Newtype NormalDegrees _\n-- |\n-- | normaliseDegrees :: Degrees -> NormalDegrees\n-- | normaliseDegrees (Degrees deg) = NormalDegrees (deg % 360.0)\n-- |\n-- | asNormalDegrees :: Number -> Number\n-- | asNormalDegrees = under Degrees normaliseDegrees\n-- | ```\n-- |\n-- | As with `over` the `Newtype` is polymorphic, as illustrated in the example\n-- | above - both `Degrees` and `NormalDegrees` are instances of `Newtype`,\n-- | so even though `normaliseDegrees` changes the result type we can still put\n-- | a `Number` in and get a `Number` out via `under`.\nunder\n  :: forall t a s b\n   . Newtype t a\n  => Newtype s b\n  => (a -> t)\n  -> (t -> s)\n  -> a\n  -> b\nunder _ = coerce\n\n-- | Much like `under`, but where the lifted function operates on values in a\n-- | `Functor`:\n-- |\n-- | ``` purescript\n-- | newtype EmailAddress = EmailAddress String\n-- | derive instance newtypeEmailAddress :: Newtype EmailAddress _\n-- |\n-- | isValid :: EmailAddress -> Boolean\n-- | isValid x = false -- imagine a slightly less strict predicate here\n-- |\n-- | findValidEmailString :: Array String -> Maybe String\n-- | findValidEmailString = underF EmailAddress (Foldable.find isValid)\n-- | ```\n-- |\n-- | The above example also demonstrates that the functor type is polymorphic\n-- | here too, the input is an `Array` but the result is a `Maybe`.\nunderF\n  :: forall f g t a s b\n   . Coercible (f t) (f a)\n  => Coercible (g s) (g b)\n  => Newtype t a\n  => Newtype s b\n  => (a -> t)\n  -> (f t -> g s)\n  -> f a\n  -> g b\nunderF _ = coerce\n\n-- | Lifts a binary function to operate over newtypes.\n-- |\n-- | ``` purescript\n-- | newtype Meter = Meter Int\n-- | derive newtype instance newtypeMeter :: Newtype Meter _\n-- | newtype SquareMeter = SquareMeter Int\n-- | derive newtype instance newtypeSquareMeter :: Newtype SquareMeter _\n-- |\n-- | area :: Meter -> Meter -> SquareMeter\n-- | area = over2 Meter (*)\n-- | ```\n-- |\n-- | The above example also demonstrates that the return type is polymorphic\n-- | here too.\nover2\n  :: forall t a s b\n   . Newtype t a\n  => Newtype s b\n  => (a -> t)\n  -> (a -> a -> b)\n  -> t\n  -> t\n  -> s\nover2 _ = coerce\n\n-- | Much like `over2`, but where the lifted binary function operates on\n-- | values in a `Functor`.\noverF2\n  :: forall f g t a s b\n   . Coercible (f a) (f t)\n  => Coercible (g b) (g s)\n  => Newtype t a\n  => Newtype s b\n  => (a -> t)\n  -> (f a -> f a -> g b)\n  -> f t\n  -> f t\n  -> g s\noverF2 _ = coerce\n\n-- | The opposite of `over2`: lowers a binary function that operates on `Newtype`d\n-- | values to operate on the wrapped value instead.\nunder2\n  :: forall t a s b\n   . Newtype t a\n  => Newtype s b\n  => (a -> t)\n  -> (t -> t -> s)\n  -> a\n  -> a\n  -> b\nunder2 _ = coerce\n\n-- | Much like `under2`, but where the lifted binary function operates on\n-- | values in a `Functor`.\nunderF2\n  :: forall f g t a s b\n   . Coercible (f t) (f a)\n  => Coercible (g s) (g b)\n  => Newtype t a\n  => Newtype s b\n  => (a -> t)\n  -> (f t -> f t -> g s)\n  -> f a\n  -> f a\n  -> g b\nunderF2 _ = coerce\n\n-- | Similar to the function from the `Traversable` class, but operating within\n-- | a newtype instead.\ntraverse\n  :: forall f t a\n   . Coercible (f a) (f t)\n  => Newtype t a\n  => (a -> t)\n  -> (a -> f a)\n  -> t\n  -> f t\ntraverse _ = coerce\n\n-- | Similar to the function from the `Distributive` class, but operating within\n-- | a newtype instead.\ncollect\n  :: forall f t a\n   . Coercible (f a) (f t)\n  => Newtype t a\n  => (a -> t)\n  -> (f a -> a)\n  -> f t\n  -> t\ncollect _ = coerce\n", "-- | This module defines the writer monad transformer, `WriterT`.\n\nmodule Control.Monad.Writer.Trans\n  ( WriterT(..), runWriterT, execWriterT, mapWriterT\n  , module Control.Monad.Trans.Class\n  , module Control.Monad.Writer.Class\n  ) where\n\nimport Prelude\n\nimport Control.Alt (class Alt, (<|>))\nimport Control.Alternative (class Alternative)\nimport Control.Apply (lift2)\nimport Control.Monad.Cont.Class (class MonadCont, callCC)\nimport Control.Monad.Error.Class (class MonadThrow, class MonadError, catchError, throwError)\nimport Control.Monad.Reader.Class (class MonadAsk, class MonadReader, ask, local)\nimport Control.Monad.Rec.Class (class MonadRec, tailRecM, Step(..))\nimport Control.Monad.State.Class (class MonadState, state)\nimport Control.Monad.Trans.Class (class MonadTrans, lift)\nimport Control.Monad.Writer.Class (class MonadTell, tell, class MonadWriter, censor, listen, listens, pass)\nimport Control.MonadPlus (class MonadPlus)\nimport Control.Plus (class Plus, empty)\nimport Data.Newtype (class Newtype)\nimport Data.Tuple (Tuple(..), snd)\nimport Effect.Class (class MonadEffect, liftEffect)\n\n-- | The writer monad transformer.\n-- |\n-- | This monad transformer extends the base monad with a monoidal accumulator of\n-- | type `w`.\n-- |\n-- | The `MonadWriter` type class describes the operations supported by this monad.\nnewtype WriterT w m a = WriterT (m (Tuple a w))\n\n-- | Run a computation in the `WriterT` monad.\nrunWriterT :: forall w m a. WriterT w m a -> m (Tuple a w)\nrunWriterT (WriterT x) = x\n\n-- | Run a computation in the `WriterT` monad, discarding the result.\nexecWriterT :: forall w m a. Functor m => WriterT w m a -> m w\nexecWriterT (WriterT m) = snd <$> m\n\n-- | Change the accumulator and base monad types in a `WriterT` monad action.\nmapWriterT :: forall w1 w2 m1 m2 a b. (m1 (Tuple a w1) -> m2 (Tuple b w2)) -> WriterT w1 m1 a -> WriterT w2 m2 b\nmapWriterT f (WriterT m) = WriterT (f m)\n\nderive instance newtypeWriterT :: Newtype (WriterT w m a) _\n\ninstance functorWriterT :: Functor m => Functor (WriterT w m) where\n  map f = mapWriterT $ map \\(Tuple a w) -> Tuple (f a) w\n\ninstance applyWriterT :: (Semigroup w, Apply m) => Apply (WriterT w m) where\n  apply (WriterT f) (WriterT v) = WriterT\n    let k (Tuple a w) (Tuple b w') = Tuple (a b) (w <> w')\n    in k <$> f <*> v\n\ninstance applicativeWriterT :: (Monoid w, Applicative m) => Applicative (WriterT w m) where\n  pure a = WriterT $ pure $ Tuple a mempty\n\ninstance altWriterT :: Alt m => Alt (WriterT w m) where\n  alt (WriterT m) (WriterT n) = WriterT (m <|> n)\n\ninstance plusWriterT :: Plus m => Plus (WriterT w m) where\n  empty = WriterT empty\n\ninstance alternativeWriterT :: (Monoid w, Alternative m) => Alternative (WriterT w m)\n\ninstance bindWriterT :: (Semigroup w, Bind m) => Bind (WriterT w m) where\n  bind (WriterT m) k = WriterT $\n    m >>= \\(Tuple a w) ->\n      case k a of\n        WriterT wt ->\n          map (\\(Tuple b w') -> Tuple b (w <> w')) wt\n\ninstance monadWriterT :: (Monoid w, Monad m) => Monad (WriterT w m)\n\ninstance monadRecWriterT :: (Monoid w, MonadRec m) => MonadRec (WriterT w m) where\n  tailRecM f a = WriterT $ tailRecM f' (Tuple a mempty)\n    where\n    f' (Tuple a' w) =\n      case f a' of\n        WriterT wt -> wt >>= \\(Tuple m w1) ->\n          pure case m of\n            Loop x -> Loop (Tuple x (w <> w1))\n            Done y -> Done (Tuple y (w <> w1))\n\ninstance monadPlusWriterT :: (Monoid w, MonadPlus m) => MonadPlus (WriterT w m)\n\ninstance monadTransWriterT :: Monoid w => MonadTrans (WriterT w) where\n  lift m = WriterT do\n    a <- m\n    pure $ Tuple a mempty\n\ninstance monadEffectWriter :: (Monoid w, MonadEffect m) => MonadEffect (WriterT w m) where\n  liftEffect = lift <<< liftEffect\n\ninstance monadContWriterT :: (Monoid w, MonadCont m) => MonadCont (WriterT w m) where\n  callCC f = WriterT $ callCC \\c ->\n    case f (\\a -> WriterT $ c (Tuple a mempty)) of WriterT b -> b\n\ninstance monadThrowWriterT :: (Monoid w, MonadThrow e m) => MonadThrow e (WriterT w m) where\n  throwError e = lift (throwError e)\n\ninstance monadErrorWriterT :: (Monoid w, MonadError e m) => MonadError e (WriterT w m) where\n  catchError (WriterT m) h = WriterT $ catchError m (\\e -> case h e of WriterT a -> a)\n\ninstance monadAskWriterT :: (Monoid w, MonadAsk r m) => MonadAsk r (WriterT w m) where\n  ask = lift ask\n\ninstance monadReaderWriterT :: (Monoid w, MonadReader r m) => MonadReader r (WriterT w m) where\n  local f = mapWriterT (local f)\n\ninstance monadStateWriterT :: (Monoid w, MonadState s m) => MonadState s (WriterT w m) where\n  state f = lift (state f)\n\ninstance monadTellWriterT :: (Monoid w, Monad m) => MonadTell w (WriterT w m) where\n  tell = WriterT <<< pure <<< Tuple unit\n\ninstance monadWriterWriterT :: (Monoid w, Monad m) => MonadWriter w (WriterT w m) where\n  listen (WriterT m) = WriterT do\n    Tuple a w <- m\n    pure $ Tuple (Tuple a w) w\n  pass (WriterT m) = WriterT do\n    Tuple (Tuple a f) w <- m\n    pure $ Tuple a (f w)\n\ninstance semigroupWriterT :: (Apply m, Semigroup w, Semigroup a) => Semigroup (WriterT w m a) where\n  append = lift2 (<>)\n\ninstance monoidWriterT :: (Applicative m, Monoid w, Monoid a) => Monoid (WriterT w m a) where\n  mempty = pure mempty\n\n", "module Control.Parallel.Class where\n\nimport Prelude\n\nimport Control.Alt (class Alt)\nimport Control.Alternative (class Alternative)\nimport Control.Monad.Cont.Trans (ContT(..), runContT)\nimport Control.Monad.Except.Trans (ExceptT(..))\nimport Control.Monad.Maybe.Trans (MaybeT(..))\nimport Control.Monad.Reader.Trans (mapReaderT, ReaderT)\nimport Control.Monad.Writer.Trans (mapWriterT, WriterT)\nimport Control.Plus (class Plus)\nimport Data.Either (Either)\nimport Data.Functor.Compose (Compose(..))\nimport Data.Functor.Costar (Costar(..))\nimport Data.Maybe (Maybe(..))\nimport Data.Newtype (class Newtype)\nimport Data.Profunctor.Star (Star(..))\nimport Effect.Class (class MonadEffect, liftEffect)\nimport Effect.Ref as Ref\n\n-- | The `Parallel` class abstracts over monads which support\n-- | parallel composition via some related `Applicative`.\nclass (Monad m, Applicative f) <= Parallel f m | m -> f, f -> m where\n  parallel :: m ~> f\n  sequential :: f ~> m\n\ninstance monadParExceptT :: Parallel f m => Parallel (Compose f (Either e)) (ExceptT e m) where\n  parallel (ExceptT ma) = Compose (parallel ma)\n  sequential (Compose fa) = ExceptT (sequential fa)\n\ninstance monadParReaderT :: Parallel f m => Parallel (ReaderT e f) (ReaderT e m) where\n  parallel = mapReaderT parallel\n  sequential = mapReaderT sequential\n\ninstance monadParWriterT :: (Monoid w, Parallel f m) => Parallel (WriterT w f) (WriterT w m) where\n  parallel = mapWriterT parallel\n  sequential = mapWriterT sequential\n\ninstance monadParMaybeT :: Parallel f m => Parallel (Compose f Maybe) (MaybeT m) where\n  parallel (MaybeT ma) = Compose (parallel ma)\n  sequential (Compose fa) = MaybeT (sequential fa)\n\ninstance monadParStar :: Parallel f m => Parallel (Star f a) (Star m a) where\n  parallel (Star f) = (Star $ parallel <<< f)\n  sequential (Star f) = (Star $ sequential <<< f)\n\ninstance monadParCostar :: Parallel f m => Parallel (Costar f a) (Costar m a) where\n  parallel (Costar f) = (Costar $ sequential >>> f)\n  sequential (Costar f) = (Costar $ parallel >>> f)\n\n\n-- | The `ParCont` type constructor provides an `Applicative` instance\n-- | based on `ContT Unit m`, which waits for multiple continuations to be\n-- | resumed simultaneously.\n-- |\n-- | ParCont sections of code can be embedded in sequential code by using\n-- | the `parallel` and `sequential` functions:\n-- |\n-- | ```purescript\n-- | loadModel :: ContT Unit (Eff (ajax :: AJAX)) Model\n-- | loadModel = do\n-- |   token <- authenticate\n-- |   sequential $\n-- |     Model <$> parallel (get \"/products/popular/\" token)\n-- |           <*> parallel (get \"/categories/all\" token)\n-- | ```\nnewtype ParCont m a = ParCont (ContT Unit m a)\n\nderive instance newtypeParCont :: Newtype (ParCont m a) _\n\ninstance functorParCont :: MonadEffect m => Functor (ParCont m) where\n  map f = parallel <<< map f <<< sequential\n\ninstance applyParCont :: MonadEffect m => Apply (ParCont m) where\n  apply (ParCont ca) (ParCont cb) = ParCont $ ContT \\k -> do\n    ra <- liftEffect (Ref.new Nothing)\n    rb <- liftEffect (Ref.new Nothing)\n\n    runContT ca \\a -> do\n      mb <- liftEffect (Ref.read rb)\n      case mb of\n        Nothing -> liftEffect (Ref.write (Just a) ra)\n        Just b -> k (a b)\n\n    runContT cb \\b -> do\n      ma <- liftEffect (Ref.read ra)\n      case ma of\n        Nothing -> liftEffect (Ref.write (Just b) rb)\n        Just a -> k (a b)\n\ninstance applicativeParCont :: MonadEffect m => Applicative (ParCont m) where\n  pure = parallel <<< pure\n\ninstance altParCont :: MonadEffect m => Alt (ParCont m) where\n  alt (ParCont c1) (ParCont c2) = ParCont $ ContT \\k -> do\n    done <- liftEffect (Ref.new false)\n\n    runContT c1 \\a -> do\n      b <- liftEffect (Ref.read done)\n      if b\n        then pure unit\n        else do\n          liftEffect (Ref.write true done)\n          k a\n\n    runContT c2 \\a -> do\n      b <- liftEffect (Ref.read done)\n      if b\n        then pure unit\n        else do\n          liftEffect (Ref.write true done)\n          k a\n\ninstance plusParCont :: MonadEffect m => Plus (ParCont m) where\n  empty = ParCont $ ContT \\_ -> pure unit\n\ninstance alternativeParCont :: MonadEffect m => Alternative (ParCont m)\n\ninstance monadParParCont :: MonadEffect m => Parallel (ParCont m) (ContT Unit m) where\n  parallel = ParCont\n  sequential (ParCont ma) = ma\n", "export const foldrArray = function (f) {\n  return function (init) {\n    return function (xs) {\n      var acc = init;\n      var len = xs.length;\n      for (var i = len - 1; i >= 0; i--) {\n        acc = f(xs[i])(acc);\n      }\n      return acc;\n    };\n  };\n};\n\nexport const foldlArray = function (f) {\n  return function (init) {\n    return function (xs) {\n      var acc = init;\n      var len = xs.length;\n      for (var i = 0; i < len; i++) {\n        acc = f(acc)(xs[i]);\n      }\n      return acc;\n    };\n  };\n};\n", "module Data.Bifunctor where\n\nimport Control.Category (identity)\nimport Data.Const (Const(..))\nimport Data.Either (Either(..))\nimport Data.Tuple (Tuple(..))\n\n-- | A `Bifunctor` is a `Functor` from the pair category `(Type, Type)` to `Type`.\n-- |\n-- | A type constructor with two type arguments can be made into a `Bifunctor` if\n-- | both of its type arguments are covariant.\n-- |\n-- | The `bimap` function maps a pair of functions over the two type arguments\n-- | of the bifunctor.\n-- |\n-- | Laws:\n-- |\n-- | - Identity: `bimap identity identity == identity`\n-- | - Composition: `bimap f1 g1 <<< bimap f2 g2 == bimap (f1 <<< f2) (g1 <<< g2)`\n-- |\nclass Bifunctor f where\n  bimap :: forall a b c d. (a -> b) -> (c -> d) -> f a c -> f b d\n\n-- | Map a function over the first type argument of a `Bifunctor`.\nlmap :: forall f a b c. Bifunctor f => (a -> b) -> f a c -> f b c\nlmap f = bimap f identity\n\n-- | Map a function over the second type arguments of a `Bifunctor`.\nrmap :: forall f a b c. Bifunctor f => (b -> c) -> f a b -> f a c\nrmap = bimap identity\n\ninstance bifunctorEither :: Bifunctor Either where\n  bimap f _ (Left l) = Left (f l)\n  bimap _ g (Right r) = Right (g r)\n\ninstance bifunctorTuple :: Bifunctor Tuple where\n  bimap f g (Tuple x y) = Tuple (f x) (g y)\n\ninstance bifunctorConst :: Bifunctor Const where\n  bimap f _ (Const a) = Const (f a)\n", "module Data.Monoid.Conj where\n\nimport Prelude\n\nimport Data.Eq (class Eq1)\nimport Data.HeytingAlgebra (ff, tt)\nimport Data.Ord (class Ord1)\n\n-- | Monoid and semigroup for conjunction.\n-- |\n-- | ``` purescript\n-- | Conj x <> Conj y == Conj (x && y)\n-- | (mempty :: Conj _) == Conj tt\n-- | ```\nnewtype Conj a = Conj a\n\nderive newtype instance eqConj :: Eq a => Eq (Conj a)\nderive instance eq1Conj :: Eq1 Conj\n\nderive newtype instance ordConj :: Ord a => Ord (Conj a)\nderive instance ord1Conj :: Ord1 Conj\n\nderive newtype instance boundedConj :: Bounded a => Bounded (Conj a)\n\ninstance showConj :: (Show a) => Show (Conj a) where\n  show (Conj a) = \"(Conj \" <> show a <> \")\"\n\nderive instance functorConj :: Functor Conj\n\ninstance applyConj :: Apply Conj where\n  apply (Conj f) (Conj x) = Conj (f x)\n\ninstance applicativeConj :: Applicative Conj where\n  pure = Conj\n\ninstance bindConj :: Bind Conj where\n  bind (Conj x) f = f x\n\ninstance monadConj :: Monad Conj\n\ninstance semigroupConj :: HeytingAlgebra a => Semigroup (Conj a) where\n  append (Conj a) (Conj b) = Conj (conj a b)\n\ninstance monoidConj :: HeytingAlgebra a => Monoid (Conj a) where\n  mempty = Conj tt\n\ninstance semiringConj :: HeytingAlgebra a => Semiring (Conj a) where\n  zero = Conj tt\n  one = Conj ff\n  add (Conj a) (Conj b) = Conj (conj a b)\n  mul (Conj a) (Conj b) = Conj (disj a b)\n", "module Data.Foldable\n  ( class Foldable, foldr, foldl, foldMap\n  , foldrDefault, foldlDefault, foldMapDefaultL, foldMapDefaultR\n  , fold\n  , foldM\n  , traverse_\n  , for_\n  , sequence_\n  , oneOf\n  , oneOfMap\n  , intercalate\n  , surroundMap\n  , surround\n  , and\n  , or\n  , all\n  , any\n  , sum\n  , product\n  , elem\n  , notElem\n  , indexl\n  , indexr\n  , find\n  , findMap\n  , maximum\n  , maximumBy\n  , minimum\n  , minimumBy\n  , null\n  , length\n  , lookup\n  ) where\n\nimport Prelude\n\nimport Control.Plus (class Plus, alt, empty)\nimport Data.Const (Const)\nimport Data.Either (Either(..))\nimport Data.Functor.App (App(..))\nimport Data.Functor.Compose (Compose(..))\nimport Data.Functor.Coproduct (Coproduct, coproduct)\nimport Data.Functor.Product (Product(..))\nimport Data.Identity (Identity(..))\nimport Data.Maybe (Maybe(..))\nimport Data.Maybe.First (First(..))\nimport Data.Maybe.Last (Last(..))\nimport Data.Monoid.Additive (Additive(..))\nimport Data.Monoid.Conj (Conj(..))\nimport Data.Monoid.Disj (Disj(..))\nimport Data.Monoid.Dual (Dual(..))\nimport Data.Monoid.Endo (Endo(..))\nimport Data.Monoid.Multiplicative (Multiplicative(..))\nimport Data.Newtype (alaF, unwrap)\nimport Data.Tuple (Tuple(..))\n\n-- | `Foldable` represents data structures which can be _folded_.\n-- |\n-- | - `foldr` folds a structure from the right\n-- | - `foldl` folds a structure from the left\n-- | - `foldMap` folds a structure by accumulating values in a `Monoid`\n-- |\n-- | Default implementations are provided by the following functions:\n-- |\n-- | - `foldrDefault`\n-- | - `foldlDefault`\n-- | - `foldMapDefaultR`\n-- | - `foldMapDefaultL`\n-- |\n-- | Note: some combinations of the default implementations are unsafe to\n-- | use together - causing a non-terminating mutually recursive cycle.\n-- | These combinations are documented per function.\nclass Foldable f where\n  foldr :: forall a b. (a -> b -> b) -> b -> f a -> b\n  foldl :: forall a b. (b -> a -> b) -> b -> f a -> b\n  foldMap :: forall a m. Monoid m => (a -> m) -> f a -> m\n\n-- | A default implementation of `foldr` using `foldMap`.\n-- |\n-- | Note: when defining a `Foldable` instance, this function is unsafe to use\n-- | in combination with `foldMapDefaultR`.\nfoldrDefault\n  :: forall f a b\n   . Foldable f\n  => (a -> b -> b)\n  -> b\n  -> f a\n  -> b\nfoldrDefault c u xs = unwrap (foldMap (Endo <<< c) xs) u\n\n-- | A default implementation of `foldl` using `foldMap`.\n-- |\n-- | Note: when defining a `Foldable` instance, this function is unsafe to use\n-- | in combination with `foldMapDefaultL`.\nfoldlDefault\n  :: forall f a b\n   . Foldable f\n  => (b -> a -> b)\n  -> b\n  -> f a\n  -> b\nfoldlDefault c u xs = unwrap (unwrap (foldMap (Dual <<< Endo <<< flip c) xs)) u\n\n-- | A default implementation of `foldMap` using `foldr`.\n-- |\n-- | Note: when defining a `Foldable` instance, this function is unsafe to use\n-- | in combination with `foldrDefault`.\nfoldMapDefaultR\n  :: forall f a m\n   . Foldable f\n  => Monoid m\n  => (a -> m)\n  -> f a\n  -> m\nfoldMapDefaultR f = foldr (\\x acc -> f x <> acc) mempty\n\n-- | A default implementation of `foldMap` using `foldl`.\n-- |\n-- | Note: when defining a `Foldable` instance, this function is unsafe to use\n-- | in combination with `foldlDefault`.\nfoldMapDefaultL\n  :: forall f a m\n   . Foldable f\n  => Monoid m\n  => (a -> m)\n  -> f a\n  -> m\nfoldMapDefaultL f = foldl (\\acc x -> acc <> f x) mempty\n\ninstance foldableArray :: Foldable Array where\n  foldr = foldrArray\n  foldl = foldlArray\n  foldMap = foldMapDefaultR\n\nforeign import foldrArray :: forall a b. (a -> b -> b) -> b -> Array a -> b\nforeign import foldlArray :: forall a b. (b -> a -> b) -> b -> Array a -> b\n\ninstance foldableMaybe :: Foldable Maybe where\n  foldr _ z Nothing  = z\n  foldr f z (Just x) = x `f` z\n  foldl _ z Nothing  = z\n  foldl f z (Just x) = z `f` x\n  foldMap _ Nothing  = mempty\n  foldMap f (Just x) = f x\n\ninstance foldableFirst :: Foldable First where\n  foldr f z (First x) = foldr f z x\n  foldl f z (First x) = foldl f z x\n  foldMap f (First x) = foldMap f x\n\ninstance foldableLast :: Foldable Last where\n  foldr f z (Last x) = foldr f z x\n  foldl f z (Last x) = foldl f z x\n  foldMap f (Last x) = foldMap f x\n\ninstance foldableAdditive :: Foldable Additive where\n  foldr f z (Additive x) = x `f` z\n  foldl f z (Additive x) = z `f` x\n  foldMap f (Additive x) = f x\n\ninstance foldableDual :: Foldable Dual where\n  foldr f z (Dual x) = x `f` z\n  foldl f z (Dual x) = z `f` x\n  foldMap f (Dual x) = f x\n\ninstance foldableDisj :: Foldable Disj where\n  foldr f z (Disj x) = f x z\n  foldl f z (Disj x) = f z x\n  foldMap f (Disj x) = f x\n\ninstance foldableConj :: Foldable Conj where\n  foldr f z (Conj x) = f x z\n  foldl f z (Conj x) = f z x\n  foldMap f (Conj x) = f x\n\ninstance foldableMultiplicative :: Foldable Multiplicative where\n  foldr f z (Multiplicative x) = x `f` z\n  foldl f z (Multiplicative x) = z `f` x\n  foldMap f (Multiplicative x) = f x\n\ninstance foldableEither :: Foldable (Either a) where\n  foldr _ z (Left _)  = z\n  foldr f z (Right x) = f x z\n  foldl _ z (Left _)  = z\n  foldl f z (Right x) = f z x\n  foldMap _ (Left _)  = mempty\n  foldMap f (Right x) = f x\n\ninstance foldableTuple :: Foldable (Tuple a) where\n  foldr f z (Tuple _ x) = f x z\n  foldl f z (Tuple _ x) = f z x\n  foldMap f (Tuple _ x) = f x\n\ninstance foldableIdentity :: Foldable Identity where\n  foldr f z (Identity x) = f x z\n  foldl f z (Identity x) = f z x\n  foldMap f (Identity x) = f x\n\ninstance foldableConst :: Foldable (Const a) where\n  foldr _ z _ = z\n  foldl _ z _ = z\n  foldMap _ _ = mempty\n\ninstance foldableProduct :: (Foldable f, Foldable g) => Foldable (Product f g) where\n  foldr f z (Product (Tuple fa ga)) = foldr f (foldr f z ga) fa\n  foldl f z (Product (Tuple fa ga)) = foldl f (foldl f z fa) ga\n  foldMap f (Product (Tuple fa ga)) = foldMap f fa <> foldMap f ga\n\ninstance foldableCoproduct :: (Foldable f, Foldable g) => Foldable (Coproduct f g) where\n  foldr f z = coproduct (foldr f z) (foldr f z)\n  foldl f z = coproduct (foldl f z) (foldl f z)\n  foldMap f = coproduct (foldMap f) (foldMap f)\n\ninstance foldableCompose :: (Foldable f, Foldable g) => Foldable (Compose f g) where\n  foldr f i (Compose fga) = foldr (flip (foldr f)) i fga\n  foldl f i (Compose fga) = foldl (foldl f) i fga\n  foldMap f (Compose fga) = foldMap (foldMap f) fga\n\ninstance foldableApp :: Foldable f => Foldable (App f) where\n  foldr f i (App x) = foldr f i x\n  foldl f i (App x) = foldl f i x\n  foldMap f (App x) = foldMap f x\n\n-- | Fold a data structure, accumulating values in some `Monoid`.\nfold :: forall f m. Foldable f => Monoid m => f m -> m\nfold = foldMap identity\n\n-- | Similar to 'foldl', but the result is encapsulated in a monad.\n-- |\n-- | Note: this function is not generally stack-safe, e.g., for monads which\n-- | build up thunks a la `Eff`.\nfoldM :: forall f m a b. Foldable f => Monad m => (b -> a -> m b) -> b -> f a -> m b\nfoldM f b0 = foldl (\\b a -> b >>= flip f a) (pure b0)\n\n-- | Traverse a data structure, performing some effects encoded by an\n-- | `Applicative` functor at each value, ignoring the final result.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | traverse_ print [1, 2, 3]\n-- | ```\ntraverse_\n  :: forall a b f m\n   . Applicative m\n  => Foldable f\n  => (a -> m b)\n  -> f a\n  -> m Unit\ntraverse_ f = foldr ((*>) <<< f) (pure unit)\n\n-- | A version of `traverse_` with its arguments flipped.\n-- |\n-- | This can be useful when running an action written using do notation\n-- | for every element in a data structure:\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | for_ [1, 2, 3] \\n -> do\n-- |   print n\n-- |   trace \"squared is\"\n-- |   print (n * n)\n-- | ```\nfor_\n  :: forall a b f m\n   . Applicative m\n  => Foldable f\n  => f a\n  -> (a -> m b)\n  -> m Unit\nfor_ = flip traverse_\n\n-- | Perform all of the effects in some data structure in the order\n-- | given by the `Foldable` instance, ignoring the final result.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | sequence_ [ trace \"Hello, \", trace \" world!\" ]\n-- | ```\nsequence_ :: forall a f m. Applicative m => Foldable f => f (m a) -> m Unit\nsequence_ = traverse_ identity\n\n-- | Combines a collection of elements using the `Alt` operation.\noneOf :: forall f g a. Foldable f => Plus g => f (g a) -> g a\noneOf = foldr alt empty\n\n-- | Folds a structure into some `Plus`.\noneOfMap :: forall f g a b. Foldable f => Plus g => (a -> g b) -> f a -> g b\noneOfMap f = foldr (alt <<< f) empty\n\n-- | Fold a data structure, accumulating values in some `Monoid`,\n-- | combining adjacent elements using the specified separator.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | > intercalate \", \" [\"Lorem\", \"ipsum\", \"dolor\"]\n-- | = \"Lorem, ipsum, dolor\"\n-- |\n-- | > intercalate \"*\" [\"a\", \"b\", \"c\"]\n-- | = \"a*b*c\"\n-- |\n-- | > intercalate [1] [[2, 3], [4, 5], [6, 7]]\n-- | = [2, 3, 1, 4, 5, 1, 6, 7]\n-- | ```\nintercalate :: forall f m. Foldable f => Monoid m => m -> f m -> m\nintercalate sep xs = (foldl go { init: true, acc: mempty } xs).acc\n  where\n  go { init: true } x = { init: false, acc: x }\n  go { acc: acc }   x = { init: false, acc: acc <> sep <> x }\n\n-- | `foldMap` but with each element surrounded by some fixed value.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | > surroundMap \"*\" show []\n-- | = \"*\"\n-- |\n-- | > surroundMap \"*\" show [1]\n-- | = \"*1*\"\n-- |\n-- | > surroundMap \"*\" show [1, 2]\n-- | = \"*1*2*\"\n-- |\n-- | > surroundMap \"*\" show [1, 2, 3]\n-- | = \"*1*2*3*\"\n-- | ```\nsurroundMap :: forall f a m. Foldable f => Semigroup m => m -> (a -> m) -> f a -> m\nsurroundMap d t f = unwrap (foldMap joined f) d\n  where joined a = Endo \\m -> d <> t a <> m\n\n-- | `fold` but with each element surrounded by some fixed value.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | > surround \"*\" []\n-- | = \"*\"\n-- |\n-- | > surround \"*\" [\"1\"]\n-- | = \"*1*\"\n-- |\n-- | > surround \"*\" [\"1\", \"2\"]\n-- | = \"*1*2*\"\n-- |\n-- | > surround \"*\" [\"1\", \"2\", \"3\"]\n-- | = \"*1*2*3*\"\n-- | ```\nsurround :: forall f m. Foldable f => Semigroup m => m -> f m -> m\nsurround d = surroundMap d identity\n\n-- | The conjunction of all the values in a data structure. When specialized\n-- | to `Boolean`, this function will test whether all of the values in a data\n-- | structure are `true`.\nand :: forall a f. Foldable f => HeytingAlgebra a => f a -> a\nand = all identity\n\n-- | The disjunction of all the values in a data structure. When specialized\n-- | to `Boolean`, this function will test whether any of the values in a data\n-- | structure is `true`.\nor :: forall a f. Foldable f => HeytingAlgebra a => f a -> a\nor = any identity\n\n-- | `all f` is the same as `and <<< map f`; map a function over the structure,\n-- | and then get the conjunction of the results.\nall :: forall a b f. Foldable f => HeytingAlgebra b => (a -> b) -> f a -> b\nall  = alaF Conj foldMap\n\n-- | `any f` is the same as `or <<< map f`; map a function over the structure,\n-- | and then get the disjunction of the results.\nany :: forall a b f. Foldable f => HeytingAlgebra b => (a -> b) -> f a -> b\nany = alaF Disj foldMap\n\n-- | Find the sum of the numeric values in a data structure.\nsum :: forall a f. Foldable f => Semiring a => f a -> a\nsum = foldl (+) zero\n\n-- | Find the product of the numeric values in a data structure.\nproduct :: forall a f. Foldable f => Semiring a => f a -> a\nproduct = foldl (*) one\n\n-- | Test whether a value is an element of a data structure.\nelem :: forall a f. Foldable f => Eq a => a -> f a -> Boolean\nelem = any <<< (==)\n\n-- | Test whether a value is not an element of a data structure.\nnotElem :: forall a f. Foldable f => Eq a => a -> f a -> Boolean\nnotElem x = not <<< elem x\n\n-- | Try to get nth element from the left in a data structure\nindexl :: forall a f. Foldable f => Int -> f a -> Maybe a\nindexl idx = _.elem <<< foldl go { elem: Nothing, pos: 0 }\n  where\n  go cursor a =\n    case cursor.elem of\n      Just _ -> cursor\n      _ ->\n        if cursor.pos == idx\n          then { elem: Just a, pos: cursor.pos }\n          else { pos: cursor.pos + 1, elem: cursor.elem }\n\n-- | Try to get nth element from the right in a data structure\nindexr :: forall a f. Foldable f => Int -> f a -> Maybe a\nindexr idx = _.elem <<< foldr go { elem: Nothing, pos: 0 }\n  where\n  go a cursor =\n    case cursor.elem of\n      Just _ -> cursor\n      _ ->\n        if cursor.pos == idx\n          then { elem: Just a, pos: cursor.pos }\n          else { pos: cursor.pos + 1, elem: cursor.elem }\n\n-- | Try to find an element in a data structure which satisfies a predicate.\nfind :: forall a f. Foldable f => (a -> Boolean) -> f a -> Maybe a\nfind p = foldl go Nothing\n  where\n  go Nothing x | p x = Just x\n  go r _ = r\n\n-- | Try to find an element in a data structure which satisfies a predicate mapping.\nfindMap :: forall a b f. Foldable f => (a -> Maybe b) -> f a -> Maybe b\nfindMap p = foldl go Nothing\n  where\n  go Nothing x = p x\n  go r _ = r\n\n-- | Find the largest element of a structure, according to its `Ord` instance.\nmaximum :: forall a f. Ord a => Foldable f => f a -> Maybe a\nmaximum = maximumBy compare\n\n-- | Find the largest element of a structure, according to a given comparison\n-- | function. The comparison function should represent a total ordering (see\n-- | the `Ord` type class laws); if it does not, the behaviour is undefined.\nmaximumBy :: forall a f. Foldable f => (a -> a -> Ordering) -> f a -> Maybe a\nmaximumBy cmp = foldl max' Nothing\n  where\n  max' Nothing x  = Just x\n  max' (Just x) y = Just (if cmp x y == GT then x else y)\n\n-- | Find the smallest element of a structure, according to its `Ord` instance.\nminimum :: forall a f. Ord a => Foldable f => f a -> Maybe a\nminimum = minimumBy compare\n\n-- | Find the smallest element of a structure, according to a given comparison\n-- | function. The comparison function should represent a total ordering (see\n-- | the `Ord` type class laws); if it does not, the behaviour is undefined.\nminimumBy :: forall a f. Foldable f => (a -> a -> Ordering) -> f a -> Maybe a\nminimumBy cmp = foldl min' Nothing\n  where\n  min' Nothing x  = Just x\n  min' (Just x) y = Just (if cmp x y == LT then x else y)\n\n-- | Test whether the structure is empty.\n-- | Optimized for structures that are similar to cons-lists, because there\n-- | is no general way to do better.\nnull :: forall a f. Foldable f => f a -> Boolean\nnull = foldr (\\_ _ -> false) true\n\n-- | Returns the size/length of a finite structure.\n-- | Optimized for structures that are similar to cons-lists, because there\n-- | is no general way to do better.\nlength :: forall a b f. Foldable f => Semiring b => f a -> b\nlength = foldl (\\c _ -> add one c) zero\n\n-- | Lookup a value in a data structure of `Tuple`s, generalizing association lists.\nlookup :: forall a b f. Foldable f => Eq a => a -> f (Tuple a b) -> Maybe b\nlookup a = unwrap <<< foldMap \\(Tuple a' b) -> First (if a == a' then Just b else Nothing)\n", "// jshint maxparams: 3\n\nexport const traverseArrayImpl = (function () {\n  function array1(a) {\n    return [a];\n  }\n\n  function array2(a) {\n    return function (b) {\n      return [a, b];\n    };\n  }\n\n  function array3(a) {\n    return function (b) {\n      return function (c) {\n        return [a, b, c];\n      };\n    };\n  }\n\n  function concat2(xs) {\n    return function (ys) {\n      return xs.concat(ys);\n    };\n  }\n\n  return function (apply) {\n    return function (map) {\n      return function (pure) {\n        return function (f) {\n          return function (array) {\n            function go(bot, top) {\n              switch (top - bot) {\n              case 0: return pure([]);\n              case 1: return map(array1)(f(array[bot]));\n              case 2: return apply(map(array2)(f(array[bot])))(f(array[bot + 1]));\n              case 3: return apply(apply(map(array3)(f(array[bot])))(f(array[bot + 1])))(f(array[bot + 2]));\n              default:\n                // This slightly tricky pivot selection aims to produce two\n                // even-length partitions where possible.\n                var pivot = bot + Math.floor((top - bot) / 4) * 2;\n                return apply(map(concat2)(go(bot, pivot)))(go(pivot, top));\n              }\n            }\n            return go(0, array.length);\n          };\n        };\n      };\n    };\n  };\n})();\n", "module Data.Traversable\n  ( class Traversable, traverse, sequence\n  , traverseDefault, sequenceDefault\n  , for\n  , scanl\n  , scanr\n  , mapAccumL\n  , mapAccumR\n  , module Data.Foldable\n  , module Data.Traversable.Accum\n  ) where\n\nimport Prelude\n\nimport Control.Apply (lift2)\nimport Data.Const (Const(..))\nimport Data.Either (Either(..))\nimport Data.Foldable (class Foldable, all, and, any, elem, find, fold, foldMap, foldMapDefaultL, foldMapDefaultR, foldl, foldlDefault, foldr, foldrDefault, for_, intercalate, maximum, maximumBy, minimum, minimumBy, notElem, oneOf, or, sequence_, sum, traverse_)\nimport Data.Functor.App (App(..))\nimport Data.Functor.Compose (Compose(..))\nimport Data.Functor.Coproduct (Coproduct(..), coproduct)\nimport Data.Functor.Product (Product(..), product)\nimport Data.Identity (Identity(..))\nimport Data.Maybe (Maybe(..))\nimport Data.Maybe.First (First(..))\nimport Data.Maybe.Last (Last(..))\nimport Data.Monoid.Additive (Additive(..))\nimport Data.Monoid.Conj (Conj(..))\nimport Data.Monoid.Disj (Disj(..))\nimport Data.Monoid.Dual (Dual(..))\nimport Data.Monoid.Multiplicative (Multiplicative(..))\nimport Data.Traversable.Accum (Accum)\nimport Data.Traversable.Accum.Internal (StateL(..), StateR(..), stateL, stateR)\nimport Data.Tuple (Tuple(..))\n\n-- | `Traversable` represents data structures which can be _traversed_,\n-- | accumulating results and effects in some `Applicative` functor.\n-- |\n-- | - `traverse` runs an action for every element in a data structure,\n-- |   and accumulates the results.\n-- | - `sequence` runs the actions _contained_ in a data structure,\n-- |   and accumulates the results.\n-- |\n-- | ```purescript\n-- | import Data.Traversable\n-- | import Data.Maybe\n-- | import Data.Int (fromNumber)\n-- |\n-- | sequence [Just 1, Just 2, Just 3] == Just [1,2,3]\n-- | sequence [Nothing, Just 2, Just 3] == Nothing\n-- |\n-- | traverse fromNumber [1.0, 2.0, 3.0] == Just [1,2,3]\n-- | traverse fromNumber [1.5, 2.0, 3.0] == Nothing\n-- |\n-- | traverse logShow [1,2,3]\n-- | -- prints:\n-- |    1\n-- |    2\n-- |    3\n-- |\n-- | traverse (\\x -> [x, 0]) [1,2,3] == [[1,2,3],[1,2,0],[1,0,3],[1,0,0],[0,2,3],[0,2,0],[0,0,3],[0,0,0]]\n-- | ```\n-- |\n-- | The `traverse` and `sequence` functions should be compatible in the\n-- | following sense:\n-- |\n-- | - `traverse f xs = sequence (f <$> xs)`\n-- | - `sequence = traverse identity`\n-- |\n-- | `Traversable` instances should also be compatible with the corresponding\n-- | `Foldable` instances, in the following sense:\n-- |\n-- | - `foldMap f = runConst <<< traverse (Const <<< f)`\n-- |\n-- | Default implementations are provided by the following functions:\n-- |\n-- | - `traverseDefault`\n-- | - `sequenceDefault`\nclass (Functor t, Foldable t) <= Traversable t where\n  traverse :: forall a b m. Applicative m => (a -> m b) -> t a -> m (t b)\n  sequence :: forall a m. Applicative m => t (m a) -> m (t a)\n\n-- | A default implementation of `traverse` using `sequence` and `map`.\ntraverseDefault\n  :: forall t a b m\n   . Traversable t\n  => Applicative m\n  => (a -> m b)\n  -> t a\n  -> m (t b)\ntraverseDefault f ta = sequence (f <$> ta)\n\n-- | A default implementation of `sequence` using `traverse`.\nsequenceDefault\n  :: forall t a m\n   . Traversable t\n  => Applicative m\n  => t (m a)\n  -> m (t a)\nsequenceDefault = traverse identity\n\ninstance traversableArray :: Traversable Array where\n  traverse = traverseArrayImpl apply map pure\n  sequence = sequenceDefault\n\nforeign import traverseArrayImpl\n  :: forall m a b\n   . (forall x y. m (x -> y) -> m x -> m y)\n  -> (forall x y. (x -> y) -> m x -> m y)\n  -> (forall x. x -> m x)\n  -> (a -> m b)\n  -> Array a\n  -> m (Array b)\n\ninstance traversableMaybe :: Traversable Maybe where\n  traverse _ Nothing  = pure Nothing\n  traverse f (Just x) = Just <$> f x\n  sequence Nothing  = pure Nothing\n  sequence (Just x) = Just <$> x\n\ninstance traversableFirst :: Traversable First where\n  traverse f (First x) = First <$> traverse f x\n  sequence (First x) = First <$> sequence x\n\ninstance traversableLast :: Traversable Last where\n  traverse f (Last x) = Last <$> traverse f x\n  sequence (Last x) = Last <$> sequence x\n\ninstance traversableAdditive :: Traversable Additive where\n  traverse f (Additive x) = Additive <$> f x\n  sequence (Additive x) = Additive <$> x\n\ninstance traversableDual :: Traversable Dual where\n  traverse f (Dual x) = Dual <$> f x\n  sequence (Dual x) = Dual <$> x\n\ninstance traversableConj :: Traversable Conj where\n  traverse f (Conj x) = Conj <$> f x\n  sequence (Conj x) = Conj <$> x\n\ninstance traversableDisj :: Traversable Disj where\n  traverse f (Disj x) = Disj <$> f x\n  sequence (Disj x) = Disj <$> x\n\ninstance traversableMultiplicative :: Traversable Multiplicative where\n  traverse f (Multiplicative x) = Multiplicative <$> f x\n  sequence (Multiplicative x) = Multiplicative <$> x\n\ninstance traversableEither :: Traversable (Either a) where\n  traverse _ (Left x)  = pure (Left x)\n  traverse f (Right x) = Right <$> f x\n  sequence (Left x) = pure (Left x)\n  sequence (Right x)  = Right <$> x\n\ninstance traversableTuple :: Traversable (Tuple a) where\n  traverse f (Tuple x y) = Tuple x <$> f y\n  sequence (Tuple x y) = Tuple x <$> y\n\ninstance traversableIdentity :: Traversable Identity where\n  traverse f (Identity x) = Identity <$> f x\n  sequence (Identity x) = Identity <$> x\n\ninstance traversableConst :: Traversable (Const a) where\n  traverse _ (Const x) = pure (Const x)\n  sequence (Const x) = pure (Const x)\n\ninstance traversableProduct :: (Traversable f, Traversable g) => Traversable (Product f g) where\n  traverse f (Product (Tuple fa ga)) = lift2 product (traverse f fa) (traverse f ga)\n  sequence (Product (Tuple fa ga)) = lift2 product (sequence fa) (sequence ga)\n\ninstance traversableCoproduct :: (Traversable f, Traversable g) => Traversable (Coproduct f g) where\n  traverse f = coproduct\n    (map (Coproduct <<< Left) <<< traverse f)\n    (map (Coproduct <<< Right) <<< traverse f)\n  sequence = coproduct\n    (map (Coproduct <<< Left) <<< sequence)\n    (map (Coproduct <<< Right) <<< sequence)\n\ninstance traversableCompose :: (Traversable f, Traversable g) => Traversable (Compose f g) where\n  traverse f (Compose fga) = map Compose $ traverse (traverse f) fga\n  sequence = traverse identity\n\ninstance traversableApp :: Traversable f => Traversable (App f) where\n  traverse f (App x) = App <$> traverse f x\n  sequence (App x) = App <$> sequence x\n\n-- | A version of `traverse` with its arguments flipped.\n-- |\n-- |\n-- | This can be useful when running an action written using do notation\n-- | for every element in a data structure:\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | for [1, 2, 3] \\n -> do\n-- |   print n\n-- |   return (n * n)\n-- | ```\nfor\n  :: forall a b m t\n   . Applicative m\n  => Traversable t\n  => t a\n  -> (a -> m b)\n  -> m (t b)\nfor x f = traverse f x\n\n-- | Fold a data structure from the left, keeping all intermediate results\n-- | instead of only the final result. Note that the initial value does not\n-- | appear in the result (unlike Haskell's `Prelude.scanl`).\n-- |\n-- | ```purescript\n-- | scanl (+) 0  [1,2,3] = [1,3,6]\n-- | scanl (-) 10 [1,2,3] = [9,7,4]\n-- | ```\nscanl :: forall a b f. Traversable f => (b -> a -> b) -> b -> f a -> f b\nscanl f b0 xs = (mapAccumL (\\b a -> let b' = f b a in { accum: b', value: b' }) b0 xs).value\n\n-- | Fold a data structure from the left, keeping all intermediate results\n-- | instead of only the final result.\n-- |\n-- | Unlike `scanl`, `mapAccumL` allows the type of accumulator to differ\n-- | from the element type of the final data structure.\nmapAccumL\n  :: forall a b s f\n   . Traversable f\n  => (s -> a -> Accum s b)\n  -> s\n  -> f a\n  -> Accum s (f b)\nmapAccumL f s0 xs = stateL (traverse (\\a -> StateL \\s -> f s a) xs) s0\n\n-- | Fold a data structure from the right, keeping all intermediate results\n-- | instead of only the final result. Note that the initial value does not\n-- | appear in the result (unlike Haskell's `Prelude.scanr`).\n-- |\n-- | ```purescript\n-- | scanr (+) 0 [1,2,3] = [6,5,3]\n-- | scanr (flip (-)) 10 [1,2,3] = [4,5,7]\n-- | ```\nscanr :: forall a b f. Traversable f => (a -> b -> b) -> b -> f a -> f b\nscanr f b0 xs = (mapAccumR (\\b a -> let b' = f a b in { accum: b', value: b' }) b0 xs).value\n\n-- | Fold a data structure from the right, keeping all intermediate results\n-- | instead of only the final result.\n-- |\n-- | Unlike `scanr`, `mapAccumR` allows the type of accumulator to differ\n-- | from the element type of the final data structure.\nmapAccumR\n  :: forall a b s f\n   . Traversable f\n  => (s -> a -> Accum s b)\n  -> s\n  -> f a\n  -> Accum s (f b)\nmapAccumR f s0 xs = stateR (traverse (\\a -> StateR \\s -> f s a) xs) s0\n", "module Control.Parallel\n  ( parApply\n  , parTraverse\n  , parTraverse_\n  , parSequence\n  , parSequence_\n  , parOneOf\n  , parOneOfMap\n  , module Control.Parallel.Class\n  ) where\n\nimport Prelude\n\nimport Control.Alternative (class Alternative)\nimport Control.Parallel.Class (class Parallel, parallel, sequential, ParCont(..))\n\nimport Data.Foldable (class Foldable, traverse_, oneOfMap)\nimport Data.Traversable (class Traversable, traverse)\n\n-- | Apply a function to an argument under a type constructor in parallel.\nparApply\n  :: forall f m a b\n   . Parallel f m\n   => m (a -> b)\n   -> m a\n   -> m b\nparApply mf ma = sequential(apply (parallel mf) (parallel ma))\n\n-- | Traverse a collection in parallel.\nparTraverse\n  :: forall f m t a b\n   . Parallel f m\n  => Traversable t\n  => (a -> m b)\n  -> t a\n  -> m (t b)\nparTraverse f = sequential <<< traverse (parallel <<< f)\n\n-- | Traverse a collection in parallel, discarding any results.\nparTraverse_\n  :: forall f m t a b\n   . Parallel f m\n  => Foldable t\n  => (a -> m b)\n  -> t a\n  -> m Unit\nparTraverse_ f = sequential <<< traverse_ (parallel <<< f)\n\nparSequence\n  :: forall a t m f\n   . Parallel f m\n  => Traversable t\n  => t (m a)\n  -> m (t a)\nparSequence = parTraverse identity\n\nparSequence_\n  :: forall a t m f\n   . Parallel f m\n  => Foldable t\n  => t (m a)\n  -> m Unit\nparSequence_ = parTraverse_ identity\n\n-- | Race a collection in parallel.\nparOneOf\n  :: forall a t m f\n   . Parallel f m\n  => Alternative f\n  => Foldable t\n  => Functor t\n  => t (m a)\n  -> m a\nparOneOf = sequential <<< oneOfMap parallel\n\n-- | Race a collection in parallel while mapping to some effect.\nparOneOfMap\n  :: forall a b t m f\n   . Parallel f m\n  => Alternative f\n  => Foldable t\n  => Functor t\n  => (a -> m b)\n  -> t a\n  -> m b\nparOneOfMap f = sequential <<< oneOfMap (parallel <<< f)\n", "module Data.Time.Duration where\n\nimport Prelude\n\nimport Data.Newtype (class Newtype, over)\n\n-- | A duration measured in milliseconds.\nnewtype Milliseconds = Milliseconds Number\n\nderive instance newtypeMilliseconds :: Newtype Milliseconds _\nderive newtype instance eqMilliseconds :: Eq Milliseconds\nderive newtype instance ordMilliseconds :: Ord Milliseconds\n\ninstance semigroupMilliseconds :: Semigroup Milliseconds where\n  append (Milliseconds x) (Milliseconds y) = Milliseconds (x + y)\n\ninstance monoidMilliseconds :: Monoid Milliseconds where\n  mempty = Milliseconds 0.0\n\ninstance showMilliseconds :: Show Milliseconds where\n  show (Milliseconds n) = \"(Milliseconds \" <> show n <> \")\"\n\n-- | A duration measured in seconds.\nnewtype Seconds = Seconds Number\n\nderive instance newtypeSeconds :: Newtype Seconds _\nderive newtype instance eqSeconds :: Eq Seconds\nderive newtype instance ordSeconds :: Ord Seconds\n\ninstance semigroupSeconds :: Semigroup Seconds where\n  append (Seconds x) (Seconds y) = Seconds (x + y)\n\ninstance monoidSeconds :: Monoid Seconds where\n  mempty = Seconds 0.0\n\ninstance showSeconds :: Show Seconds where\n  show (Seconds n) = \"(Seconds \" <> show n <> \")\"\n\n-- | A duration measured in minutes.\nnewtype Minutes = Minutes Number\n\nderive instance newtypeMinutes :: Newtype Minutes _\nderive newtype instance eqMinutes :: Eq Minutes\nderive newtype instance ordMinutes :: Ord Minutes\n\ninstance semigroupMinutes :: Semigroup Minutes where\n  append (Minutes x) (Minutes y) = Minutes (x + y)\n\ninstance monoidMinutes :: Monoid Minutes where\n  mempty = Minutes 0.0\n\ninstance showMinutes :: Show Minutes where\n  show (Minutes n) = \"(Minutes \" <> show n <> \")\"\n\n-- | A duration measured in hours.\nnewtype Hours = Hours Number\n\nderive instance newtypeHours :: Newtype Hours _\nderive newtype instance eqHours :: Eq Hours\nderive newtype instance ordHours :: Ord Hours\n\ninstance semigroupHours :: Semigroup Hours where\n  append (Hours x) (Hours y) = Hours (x + y)\n\ninstance monoidHours :: Monoid Hours where\n  mempty = Hours 0.0\n\ninstance showHours :: Show Hours where\n  show (Hours n) = \"(Hours \" <> show n <> \")\"\n\n-- | A duration measured in days, where a day is assumed to be exactly 24 hours.\nnewtype Days = Days Number\n\nderive instance newtypeDays :: Newtype Days _\nderive newtype instance eqDays :: Eq Days\nderive newtype instance ordDays :: Ord Days\n\ninstance semigroupDays :: Semigroup Days where\n  append (Days x) (Days y) = Days (x + y)\n\ninstance monoidDays :: Monoid Days where\n  mempty = Days 0.0\n\ninstance showDays :: Show Days where\n  show (Days n) = \"(Days \" <> show n <> \")\"\n\n-- | A class for enabling conversions between duration types.\nclass Duration a where\n  fromDuration :: a -> Milliseconds\n  toDuration :: Milliseconds -> a\n\n-- | Converts directly between durations of differing types.\nconvertDuration :: forall a b. Duration a => Duration b => a -> b\nconvertDuration = toDuration <<< fromDuration\n\n-- | Negates a duration, turning a positive duration negative or a negative\n-- | duration positive.\nnegateDuration :: forall a. Duration a => a -> a\nnegateDuration = toDuration <<< over Milliseconds negate <<< fromDuration\n\ninstance durationMilliseconds :: Duration Milliseconds where\n  fromDuration = identity\n  toDuration = identity\n\ninstance durationSeconds :: Duration Seconds where\n  fromDuration = over Seconds (_ * 1000.0)\n  toDuration = over Milliseconds (_ / 1000.0)\n\ninstance durationMinutes :: Duration Minutes where\n  fromDuration = over Minutes (_ * 60000.0)\n  toDuration = over Milliseconds (_ / 60000.0)\n\ninstance durationHours :: Duration Hours where\n  fromDuration = over Hours (_ * 3600000.0)\n  toDuration = over Milliseconds (_ / 3600000.0)\n\ninstance durationDays :: Duration Days where\n  fromDuration = over Days (_ * 86400000.0)\n  toDuration = over Milliseconds (_ / 86400000.0)\n", "// module Partial.Unsafe\n\nexport const _unsafePartial = function (f) {\n  return f();\n};\n", "// module Partial\n\nexport const _crashWith = function (msg) {\n  throw new Error(msg);\n};\n", "-- | Some partial helper functions. See the README for more documentation.\nmodule Partial\n  ( crash\n  , crashWith\n  ) where\n\n-- | A partial function which crashes on any input with a default message.\ncrash :: forall a. Partial => a\ncrash = crashWith \"Partial.crash: partial function\"\n\n-- | A partial function which crashes on any input with the specified message.\ncrashWith :: forall a. Partial => String -> a\ncrashWith = _crashWith\n\nforeign import _crashWith :: forall a. String -> a\n", "-- | Utilities for working with partial functions.\n-- | See the README for more documentation.\nmodule Partial.Unsafe\n  ( unsafePartial\n  , unsafeCrashWith\n  ) where\n\nimport Partial (crashWith)\n\n-- Note: this function's type signature is more like\n-- `(Unit -> a) -> a`. However, we would need to use\n-- `unsafeCoerce` to make this compile, incurring\n-- either a dependency or reimplementing it here.\n-- Rather than doing that, we'll use a type signature\n-- of `a -> b` instead.\nforeign import _unsafePartial :: forall a b. a -> b\n\n-- | Discharge a partiality constraint, unsafely.\nunsafePartial :: forall a. (Partial => a) -> a\nunsafePartial = _unsafePartial\n\n-- | A function which crashes with the specified error message.\nunsafeCrashWith :: forall a. String -> a\nunsafeCrashWith msg = unsafePartial (crashWith msg)\n", "module Effect.Aff\n  ( Aff\n  , Fiber\n  , ParAff(..)\n  , Canceler(..)\n  , makeAff\n  , launchAff\n  , launchAff_\n  , launchSuspendedAff\n  , runAff\n  , runAff_\n  , runSuspendedAff\n  , forkAff\n  , suspendAff\n  , supervise\n  , attempt\n  , apathize\n  , delay\n  , never\n  , finally\n  , invincible\n  , killFiber\n  , joinFiber\n  , cancelWith\n  , bracket\n  , BracketConditions\n  , generalBracket\n  , nonCanceler\n  , effectCanceler\n  , fiberCanceler\n  , module Exports\n  ) where\n\nimport Prelude\n\nimport Control.Alt (class Alt)\nimport Control.Alternative (class Alternative)\nimport Control.Apply (lift2)\nimport Control.Lazy (class Lazy)\nimport Control.Monad.Error.Class (class MonadError, class MonadThrow, throwError, catchError, try)\nimport Control.Monad.Error.Class (try, throwError, catchError) as Exports\nimport Control.Monad.Rec.Class (class MonadRec, Step(..))\nimport Control.Monad.ST.Class (class MonadST, liftST)\nimport Control.Monad.ST.Global (Global)\nimport Control.Parallel (parSequence_, parallel)\nimport Control.Parallel.Class (class Parallel)\nimport Control.Parallel.Class (sequential, parallel) as Exports\nimport Control.Plus (class Plus, empty)\nimport Data.Either (Either(..))\nimport Data.Function.Uncurried as Fn\nimport Data.Newtype (class Newtype)\nimport Data.Time.Duration (Milliseconds(..))\nimport Data.Time.Duration (Milliseconds(..)) as Exports\nimport Effect (Effect)\nimport Effect.Class (class MonadEffect, liftEffect)\nimport Effect.Exception (Error, error)\nimport Effect.Exception (Error, error, message) as Exports\nimport Effect.Unsafe (unsafePerformEffect)\nimport Partial.Unsafe (unsafeCrashWith)\nimport Unsafe.Coerce (unsafeCoerce)\n\n-- | An `Aff a` is an asynchronous computation with effects. The\n-- | computation may either error with an exception, or produce a result of\n-- | type `a`. `Aff` effects are assembled from primitive `Effect` effects using\n-- | `makeAff` or `liftEffect`.\nforeign import data Aff :: Type -> Type\n\ntype role Aff representational\n\ninstance functorAff :: Functor Aff where\n  map = _map\n\ninstance applyAff :: Apply Aff where\n  apply = ap\n\ninstance applicativeAff :: Applicative Aff where\n  pure = _pure\n\ninstance bindAff :: Bind Aff where\n  bind = _bind\n\ninstance monadAff :: Monad Aff\n\ninstance semigroupAff :: Semigroup a => Semigroup (Aff a) where\n  append = lift2 append\n\ninstance monoidAff :: Monoid a => Monoid (Aff a) where\n  mempty = pure mempty\n\ninstance altAff :: Alt Aff where\n  alt a1 a2 = catchError a1 (const a2)\n\ninstance plusAff :: Plus Aff where\n  empty = throwError (error \"Always fails\")\n\n-- | This instance is provided for compatibility. `Aff` is always stack-safe\n-- | within a given fiber. This instance will just result in unnecessary\n-- | bind overhead.\ninstance monadRecAff :: MonadRec Aff where\n  tailRecM k = go\n    where\n    go a = do\n      res <- k a\n      case res of\n        Done r -> pure r\n        Loop b -> go b\n\ninstance monadThrowAff :: MonadThrow Error Aff where\n  throwError = _throwError\n\ninstance monadErrorAff :: MonadError Error Aff where\n  catchError = _catchError\n\ninstance monadEffectAff :: MonadEffect Aff where\n  liftEffect = _liftEffect\n\ninstance lazyAff :: Lazy (Aff a) where\n  defer f = pure unit >>= f\n\ninstance monadSTAff :: MonadST Global Aff where\n  liftST = liftST >>> liftEffect\n\n-- | Applicative for running parallel effects. Any `Aff` can be coerced to a\n-- | `ParAff` and back using the `Parallel` class.\nforeign import data ParAff :: Type -> Type\n\ntype role ParAff representational\n\ninstance functorParAff :: Functor ParAff where\n  map = _parAffMap\n\n-- | Runs effects in parallel, combining their results.\ninstance applyParAff :: Apply ParAff where\n  apply = _parAffApply\n\ninstance applicativeParAff :: Applicative ParAff where\n  pure = parallel <<< pure\n\ninstance semigroupParAff :: Semigroup a => Semigroup (ParAff a) where\n  append = lift2 append\n\ninstance monoidParAff :: Monoid a => Monoid (ParAff a) where\n  mempty = pure mempty\n\n-- | Races effects in parallel. Returns the first successful result or the\n-- | first error if all fail with an exception. Losing branches will be\n-- | cancelled.\ninstance altParAff :: Alt ParAff where\n  alt = _parAffAlt\n\ninstance plusParAff :: Plus ParAff where\n  empty = parallel empty\n\ninstance alternativeParAff :: Alternative ParAff\n\ninstance parallelAff :: Parallel ParAff Aff where\n  parallel = (unsafeCoerce :: forall a. Aff a -> ParAff a)\n  sequential = _sequential\n\ntype OnComplete a =\n  { rethrow :: Boolean\n  , handler :: (Either Error a -> Effect Unit) -> Effect Unit\n  }\n\n-- | Represents a forked computation by way of `forkAff`. `Fiber`s are\n-- | memoized, so their results are only computed once.\nnewtype Fiber a = Fiber\n  { run :: Effect Unit\n  , kill :: Fn.Fn2 Error (Either Error Unit -> Effect Unit) (Effect (Effect Unit))\n  , join :: (Either Error a -> Effect Unit) -> Effect (Effect Unit)\n  , onComplete :: OnComplete a -> Effect (Effect Unit)\n  , isSuspended :: Effect Boolean\n  }\n\ninstance functorFiber :: Functor Fiber where\n  map f t = unsafePerformEffect (makeFiber (f <$> joinFiber t))\n\ninstance applyFiber :: Apply Fiber where\n  apply t1 t2 = unsafePerformEffect (makeFiber (joinFiber t1 <*> joinFiber t2))\n\ninstance applicativeFiber :: Applicative Fiber where\n  pure a = unsafePerformEffect (makeFiber (pure a))\n\n-- | Invokes pending cancelers in a fiber and runs cleanup effects. Blocks\n-- | until the fiber has fully exited.\nkillFiber :: forall a. Error -> Fiber a -> Aff Unit\nkillFiber e (Fiber t) = do\n  suspended <- liftEffect t.isSuspended\n  if suspended then\n    liftEffect $ void $ Fn.runFn2 t.kill e (const (pure unit))\n  else\n    makeAff \\k -> effectCanceler <$> Fn.runFn2 t.kill e k\n\n-- | Blocks until the fiber completes, yielding the result. If the fiber\n-- | throws an exception, it is rethrown in the current fiber.\njoinFiber :: Fiber ~> Aff\njoinFiber (Fiber t) = makeAff \\k -> effectCanceler <$> t.join k\n\n-- | A cancellation effect for actions run via `makeAff`. If a `Fiber` is\n-- | killed, and an async action is pending, the canceler will be called to\n-- | clean it up.\nnewtype Canceler = Canceler (Error -> Aff Unit)\n\nderive instance newtypeCanceler :: Newtype Canceler _\n\ninstance semigroupCanceler :: Semigroup Canceler where\n  append (Canceler c1) (Canceler c2) =\n    Canceler \\err -> parSequence_ [ c1 err, c2 err ]\n\n-- | A no-op `Canceler` can be constructed with `mempty`.\ninstance monoidCanceler :: Monoid Canceler where\n  mempty = nonCanceler\n\n-- | A canceler which does not cancel anything.\nnonCanceler :: Canceler\nnonCanceler = Canceler (const (pure unit))\n\n-- | A canceler from an Effect action.\neffectCanceler :: Effect Unit -> Canceler\neffectCanceler = Canceler <<< const <<< liftEffect\n\n-- | A canceler from a Fiber.\nfiberCanceler :: forall a. Fiber a -> Canceler\nfiberCanceler = Canceler <<< flip killFiber\n\n-- | Forks an `Aff` from an `Effect` context, returning the `Fiber`.\nlaunchAff :: forall a. Aff a -> Effect (Fiber a)\nlaunchAff aff = do\n  fiber <- makeFiber aff\n  case fiber of Fiber f -> f.run\n  pure fiber\n\n-- | Forks an `Aff` from an `Effect` context, discarding the `Fiber`.\nlaunchAff_ :: Aff Unit -> Effect Unit\nlaunchAff_ = void <<< launchAff\n\n-- | Suspends an `Aff` from an `Effect` context, returning the `Fiber`.\nlaunchSuspendedAff :: forall a. Aff a -> Effect (Fiber a)\nlaunchSuspendedAff = makeFiber\n\n-- | Forks an `Aff` from an `Effect` context and also takes a callback to run when\n-- | it completes. Returns the pending `Fiber`.\nrunAff :: forall a. (Either Error a -> Effect Unit) -> Aff a -> Effect (Fiber Unit)\nrunAff k aff = launchAff $ liftEffect <<< k =<< try aff\n\n-- | Forks an `Aff` from an `Effect` context and also takes a callback to run when\n-- | it completes, discarding the `Fiber`.\nrunAff_ :: forall a. (Either Error a -> Effect Unit) -> Aff a -> Effect Unit\nrunAff_ k aff = void $ runAff k aff\n\n-- | Suspends an `Aff` from an `Effect` context and also takes a callback to run\n-- | when it completes. Returns the suspended `Fiber`.\nrunSuspendedAff :: forall a. (Either Error a -> Effect Unit) -> Aff a -> Effect (Fiber Unit)\nrunSuspendedAff k aff = launchSuspendedAff $ liftEffect <<< k =<< try aff\n\n-- | Forks an `Aff` from within a parent `Aff` context, returning the `Fiber`.\nforkAff :: forall a. Aff a -> Aff (Fiber a)\nforkAff = _fork true\n\n-- | Suspends an `Aff` from within a parent `Aff` context, returning the `Fiber`.\n-- | A suspended `Aff` is not executed until a consumer observes the result\n-- | with `joinFiber`.\nsuspendAff :: forall a. Aff a -> Aff (Fiber a)\nsuspendAff = _fork false\n\n-- | Pauses the running fiber.\ndelay :: Milliseconds -> Aff Unit\ndelay (Milliseconds n) = Fn.runFn2 _delay Right n\n\n-- | An async computation which does not resolve.\nnever :: forall a. Aff a\nnever = makeAff \\_ -> pure mempty\n\n-- | A monomorphic version of `try`. Catches thrown errors and lifts them\n-- | into an `Either`.\nattempt :: forall a. Aff a -> Aff (Either Error a)\nattempt = try\n\n-- | Ignores any errors.\napathize :: forall a. Aff a -> Aff Unit\napathize = attempt >>> map (const unit)\n\n-- | Runs the first effect after the second, regardless of whether it completed\n-- | successfully or the fiber was cancelled.\nfinally :: forall a. Aff Unit -> Aff a -> Aff a\nfinally fin a = bracket (pure unit) (const fin) (const a)\n\n-- | Runs an effect such that it cannot be killed.\ninvincible :: forall a. Aff a -> Aff a\ninvincible a = bracket a (const (pure unit)) pure\n\n-- | Attaches a custom `Canceler` to an action. If the computation is canceled,\n-- | then the custom `Canceler` will be run afterwards.\ncancelWith :: forall a. Aff a -> Canceler -> Aff a\ncancelWith aff (Canceler cancel) =\n  generalBracket (pure unit)\n    { killed: \\e _ -> cancel e\n    , failed: const pure\n    , completed: const pure\n    }\n    (const aff)\n\n-- | Guarantees resource acquisition and cleanup. The first effect may acquire\n-- | some resource, while the second will dispose of it. The third effect makes\n-- | use of the resource. Disposal is always run last, regardless. Neither\n-- | acquisition nor disposal may be cancelled and are guaranteed to run until\n-- | they complete.\nbracket :: forall a b. Aff a -> (a -> Aff Unit) -> (a -> Aff b) -> Aff b\nbracket acquire completed =\n  generalBracket acquire\n    { killed: const completed\n    , failed: const completed\n    , completed: const completed\n    }\n\ntype Supervised a =\n  { fiber :: Fiber a\n  , supervisor :: Supervisor\n  }\n\n-- | Creates a new supervision context for some `Aff`, guaranteeing fiber\n-- | cleanup when the parent completes. Any pending fibers forked within\n-- | the context will be killed and have their cancelers run.\nsupervise :: forall a. Aff a -> Aff a\nsupervise aff =\n  generalBracket (liftEffect acquire)\n    { killed: \\err sup -> parSequence_ [ killFiber err sup.fiber, killAll err sup ]\n    , failed: const (killAll killError)\n    , completed: const (killAll killError)\n    }\n    (joinFiber <<< _.fiber)\n  where\n  killError :: Error\n  killError =\n    error \"[Aff] Child fiber outlived parent\"\n\n  killAll :: Error -> Supervised a -> Aff Unit\n  killAll err sup = makeAff \\k ->\n    Fn.runFn3 _killAll err sup.supervisor (k (pure unit))\n\n  acquire :: Effect (Supervised a)\n  acquire = do\n    sup <- Fn.runFn2 _makeSupervisedFiber ffiUtil aff\n    case sup.fiber of Fiber f -> f.run\n    pure sup\n\nforeign import data Supervisor :: Type\nforeign import _pure :: forall a. a -> Aff a\nforeign import _throwError :: forall a. Error -> Aff a\nforeign import _catchError :: forall a. Aff a -> (Error -> Aff a) -> Aff a\nforeign import _fork :: forall a. Boolean -> Aff a -> Aff (Fiber a)\nforeign import _map :: forall a b. (a -> b) -> Aff a -> Aff b\nforeign import _bind :: forall a b. Aff a -> (a -> Aff b) -> Aff b\nforeign import _delay :: forall a. Fn.Fn2 (Unit -> Either a Unit) Number (Aff Unit)\nforeign import _liftEffect :: forall a. Effect a -> Aff a\nforeign import _parAffMap :: forall a b. (a -> b) -> ParAff a -> ParAff b\nforeign import _parAffApply :: forall a b. ParAff (a -> b) -> ParAff a -> ParAff b\nforeign import _parAffAlt :: forall a. ParAff a -> ParAff a -> ParAff a\nforeign import _makeFiber :: forall a. Fn.Fn2 FFIUtil (Aff a) (Effect (Fiber a))\nforeign import _makeSupervisedFiber :: forall a. Fn.Fn2 FFIUtil (Aff a) (Effect (Supervised a))\nforeign import _killAll :: Fn.Fn3 Error Supervisor (Effect Unit) (Effect Canceler)\nforeign import _sequential :: ParAff ~> Aff\n\ntype BracketConditions a b =\n  { killed :: Error -> a -> Aff Unit\n  , failed :: Error -> a -> Aff Unit\n  , completed :: b -> a -> Aff Unit\n  }\n\n-- | A general purpose bracket which lets you observe the status of the\n-- | bracketed action. The bracketed action may have been killed with an\n-- | exception, thrown an exception, or completed successfully.\nforeign import generalBracket :: forall a b. Aff a -> BracketConditions a b -> (a -> Aff b) -> Aff b\n\n-- | Constructs an `Aff` from low-level `Effect` effects using a callback. A\n-- | `Canceler` effect should be returned to cancel the pending action. The\n-- | supplied callback may be invoked only once. Subsequent invocation are\n-- | ignored.\nforeign import makeAff :: forall a. ((Either Error a -> Effect Unit) -> Effect Canceler) -> Aff a\n\nmakeFiber :: forall a. Aff a -> Effect (Fiber a)\nmakeFiber aff = Fn.runFn2 _makeFiber ffiUtil aff\n\nnewtype FFIUtil = FFIUtil\n  { isLeft :: forall a b. Either a b -> Boolean\n  , fromLeft :: forall a b. Either a b -> a\n  , fromRight :: forall a b. Either a b -> b\n  , left :: forall a b. a -> Either a b\n  , right :: forall a b. b -> Either a b\n  }\n\nffiUtil :: FFIUtil\nffiUtil = FFIUtil\n  { isLeft\n  , fromLeft: unsafeFromLeft\n  , fromRight: unsafeFromRight\n  , left: Left\n  , right: Right\n  }\n  where\n  isLeft :: forall a b. Either a b -> Boolean\n  isLeft = case _ of\n    Left _ -> true\n    Right _ -> false\n\n  unsafeFromLeft :: forall a b. Either a b -> a\n  unsafeFromLeft = case _ of\n    Left a -> a\n    Right _ -> unsafeCrashWith \"unsafeFromLeft: Right\"\n\n  unsafeFromRight :: forall a b. Either a b -> b\n  unsafeFromRight = case _ of\n    Right a -> a\n    Left _ -> unsafeCrashWith \"unsafeFromRight: Left\"\n", "-- | This module defines the state monad transformer, `StateT`.\n\nmodule Control.Monad.State.Trans\n  ( StateT(..), runStateT, evalStateT, execStateT, mapStateT, withStateT\n  , module Control.Monad.Trans.Class\n  , module Control.Monad.State.Class\n  ) where\n\nimport Prelude\n\nimport Control.Alt (class Alt, (<|>))\nimport Control.Alternative (class Alternative)\nimport Control.Apply (lift2)\nimport Control.Lazy (class Lazy)\nimport Control.Monad.Cont.Class (class MonadCont, callCC)\nimport Control.Monad.Error.Class (class MonadThrow, class MonadError, catchError, throwError)\nimport Control.Monad.Reader.Class (class MonadAsk, class MonadReader, ask, local)\nimport Control.Monad.Rec.Class (class MonadRec, tailRecM, Step(..))\nimport Control.Monad.State.Class (class MonadState, get, gets, modify, modify_, put, state)\nimport Control.Monad.Trans.Class (class MonadTrans, lift)\nimport Control.Monad.Writer.Class (class MonadWriter, class MonadTell, pass, listen, tell)\nimport Control.MonadPlus (class MonadPlus)\nimport Control.Plus (class Plus, empty)\nimport Data.Newtype (class Newtype)\nimport Data.Tuple (Tuple(..), fst, snd)\nimport Effect.Class (class MonadEffect, liftEffect)\n\n-- | The state monad transformer.\n-- |\n-- | This monad transformer extends the base monad with the operations `get`\n-- | and `put` which can be used to model a single piece of mutable state.\n-- |\n-- | The `MonadState` type class describes the operations supported by this monad.\nnewtype StateT s m a = StateT (s -> m (Tuple a s))\n\n-- | Run a computation in the `StateT` monad.\nrunStateT :: forall s m a. StateT s m a -> s -> m (Tuple a s)\nrunStateT (StateT s) = s\n\n-- | Run a computation in the `StateT` monad, discarding the final state.\nevalStateT :: forall s m a. Functor m => StateT s m a -> s -> m a\nevalStateT (StateT m) s = fst <$> m s\n\n-- | Run a computation in the `StateT` monad discarding the result.\nexecStateT :: forall s m a. Functor m => StateT s m a -> s -> m s\nexecStateT (StateT m) s = snd <$> m s\n\n-- | Change the result type in a `StateT` monad action.\nmapStateT :: forall s m1 m2 a b. (m1 (Tuple a s) -> m2 (Tuple b s)) -> StateT s m1 a -> StateT s m2 b\nmapStateT f (StateT m) = StateT (f <<< m)\n\n-- | Modify the final state in a `StateT` monad action.\nwithStateT :: forall s m a. (s -> s) -> StateT s m a -> StateT s m a\nwithStateT f (StateT s) = StateT (s <<< f)\n\nderive instance newtypeStateT :: Newtype (StateT s m a) _\n\ninstance functorStateT :: Functor m => Functor (StateT s m) where\n  map f (StateT a) = StateT (\\s -> map (\\(Tuple b s') -> Tuple (f b) s') (a s))\n\ninstance applyStateT :: Monad m => Apply (StateT s m) where\n  apply = ap\n\ninstance applicativeStateT :: Monad m => Applicative (StateT s m) where\n  pure a = StateT \\s -> pure $ Tuple a s\n\ninstance altStateT :: (Monad m, Alt m) => Alt (StateT s m) where\n  alt (StateT x) (StateT y) = StateT \\s -> x s <|> y s\n\ninstance plusStateT :: (Monad m, Plus m) => Plus (StateT s m) where\n  empty = StateT \\_ -> empty\n\ninstance alternativeStateT :: (Monad m, Alternative m) => Alternative (StateT s m)\n\ninstance bindStateT :: Monad m => Bind (StateT s m) where\n  bind (StateT x) f = StateT \\s ->\n    x s >>= \\(Tuple v s') -> case f v of StateT st -> st s'\n\ninstance monadStateT :: Monad m => Monad (StateT s m)\n\ninstance monadRecStateT :: MonadRec m => MonadRec (StateT s m) where\n  tailRecM f a = StateT \\s -> tailRecM f' (Tuple a s)\n    where\n    f' (Tuple a' s) =\n      case f a' of\n        StateT st -> st s >>= \\(Tuple m s1) ->\n          pure case m of\n            Loop x -> Loop (Tuple x s1)\n            Done y -> Done (Tuple y s1)\n\ninstance monadPlusStateT :: MonadPlus m => MonadPlus (StateT s m)\n\ninstance monadTransStateT :: MonadTrans (StateT s) where\n  lift m = StateT \\s -> do\n    x <- m\n    pure $ Tuple x s\n\ninstance lazyStateT :: Lazy (StateT s m a) where\n  defer f = StateT \\s -> case f unit of StateT f' -> f' s\n\ninstance monadEffectState :: MonadEffect m => MonadEffect (StateT s m) where\n  liftEffect = lift <<< liftEffect\n\ninstance monadContStateT :: MonadCont m => MonadCont (StateT s m) where\n  callCC f = StateT \\s -> callCC \\c ->\n    case f (\\a -> StateT \\s' -> c (Tuple a s')) of StateT f' -> f' s\n\ninstance monadThrowStateT :: MonadThrow e m => MonadThrow e (StateT s m) where\n  throwError e = lift (throwError e)\n\ninstance monadErrorStateT :: MonadError e m => MonadError e (StateT s m) where\n  catchError (StateT m) h =\n    StateT \\s -> catchError (m s) (\\e -> case h e of StateT f -> f s)\n\ninstance monadAskStateT :: MonadAsk r m => MonadAsk r (StateT s m) where\n  ask = lift ask\n\ninstance monadReaderStateT :: MonadReader r m => MonadReader r (StateT s m) where\n  local = mapStateT <<< local\n\ninstance monadStateStateT :: Monad m => MonadState s (StateT s m) where\n  state f = StateT $ pure <<< f\n\ninstance monadTellStateT :: MonadTell w m => MonadTell w (StateT s m) where\n  tell = lift <<< tell\n\ninstance monadWriterStateT :: MonadWriter w m => MonadWriter w (StateT s m) where\n  listen m = StateT \\s ->\n    case m of\n      StateT m' -> do\n        Tuple (Tuple a s') w <- listen (m' s)\n        pure $ Tuple (Tuple a w) s'\n  pass m = StateT \\s -> pass\n    case m of\n      StateT m' -> do\n        Tuple (Tuple a f) s' <- m' s\n        pure $ Tuple (Tuple a s') f\n\ninstance semigroupStateT :: (Monad m, Semigroup a) => Semigroup (StateT s m a) where\n  append = lift2 (<>)\n\ninstance monoidStateT :: (Monad m, Monoid a) => Monoid (StateT s m a) where\n  mempty = pure mempty\n\n", "module Effect.Aff.Class where\n\nimport Prelude\nimport Control.Monad.Cont.Trans (ContT)\nimport Control.Monad.Except.Trans (ExceptT)\nimport Control.Monad.List.Trans (ListT)\nimport Control.Monad.Maybe.Trans (MaybeT)\nimport Control.Monad.Reader.Trans (ReaderT)\nimport Control.Monad.RWS.Trans (RWST)\nimport Control.Monad.State.Trans (StateT)\nimport Control.Monad.Trans.Class (lift)\nimport Control.Monad.Writer.Trans (WriterT)\nimport Effect.Aff (Aff)\nimport Effect.Class (class MonadEffect)\n\nclass MonadEffect m <= MonadAff m where\n  liftAff :: Aff ~> m\n\ninstance monadAffAff :: MonadAff Aff where\n  liftAff = identity\n\ninstance monadAffContT :: MonadAff m => MonadAff (ContT r m) where\n  liftAff = lift <<< liftAff\n\ninstance monadAffExceptT :: MonadAff m => MonadAff (ExceptT e m) where\n  liftAff = lift <<< liftAff\n\ninstance monadAffListT :: MonadAff m => MonadAff (ListT m) where\n  liftAff = lift <<< liftAff\n\ninstance monadAffMaybe :: MonadAff m => MonadAff (MaybeT m) where\n  liftAff = lift <<< liftAff\n\ninstance monadAffReader :: MonadAff m => MonadAff (ReaderT r m) where\n  liftAff = lift <<< liftAff\n\ninstance monadAffRWS :: (MonadAff m, Monoid w) => MonadAff (RWST r w s m) where\n  liftAff = lift <<< liftAff\n\ninstance monadAffState :: MonadAff m => MonadAff (StateT s m) where\n  liftAff = lift <<< liftAff\n\ninstance monadAffWriter :: (MonadAff m, Monoid w) => MonadAff (WriterT w m) where\n  liftAff = lift <<< liftAff\n", "import Stream from \"stream\";\n\nconst DEBUG = process.env['NODEJS_OBJECT_STREAM_TRACE'] !== ''\n\n/** @type {(s: string) => void} */\nconst log = m => DEBUG ? console.log(m) : undefined;\n\nlet chainCount = 0\nlet composeCount = 0\nlet neverCount = 0\nlet onceCount = 0\nlet bindCount = 0\nlet zipCount = 0\nlet mapCount = 0\nlet constCount = 0\nlet fromPromiseCount = 0\n\nexport class Never extends Stream.Readable {\n  constructor() {\n    super({objectMode: true})\n    this.id = neverCount++\n  }\n\n  _read() {\n    log(`Never {id: ${this.id}}#_read()`)\n    log(`  this.push(null)`)\n    this.push(null)\n  }\n}\n\n/** @template T */\nexport class Once extends Stream.Duplex {\n  /** @param {T} a */\n  constructor(a) {\n    super({objectMode: true})\n    this.a = a\n    this.id = onceCount++\n    this.push(this.a)\n    this.push(null)\n    log(`Once {id: ${this.id}}#new()`)\n    log(`  this.push(${a})`)\n    log(`  this.push(null)`)\n  }\n\n  _write(_ck, _enc, cb) {\n    cb()\n  }\n\n  _read() {\n    log(`Once {id: ${this.id}}#_read()`)\n  }\n}\n\n/** @template T */\nexport class Const extends Stream.Transform {\n  /** @param {T} a */\n  constructor(a) {\n    super({objectMode: true})\n    this.a = a\n    this.id = constCount++\n  }\n\n  /** @type {Stream.Transform['_transform']} */\n  _transform(_c, _enc, cb) {\n    log(`Const {id: ${this.id}}#_transform(${_c}, _, _)`)\n    log(`  cb(${this.a})`)\n    this.push(this.a)\n    cb()\n  }\n}\n\n/** @template T */\nexport class FromPromise extends Stream.Readable {\n  /** @param {Promise<T>} p */\n  constructor(p) {\n    super({objectMode: true})\n    this.id = fromPromiseCount++\n    p\n       .then(a => {\n         log(`FromPromise {id: ${this.id}}#new()`)\n         log(`  ...p.then(...)`)\n         log(`    this.push(${a})`)\n         log(`    this.push(null)`)\n         this.push(a)\n         this.push(null)\n       })\n       .catch(e => {\n         log(`FromPromise {id: ${this.id}}#new()`)\n         log(`  ...p.catch(...)`)\n         log(`    this.destroy(${e})`)\n         this.destroy(e)\n       })\n  }\n\n  _read() {\n    log(`FromPromise {id: ${this.id}}#_read()`)\n  }\n}\n\n/** @template T */\nexport class Chain extends Stream.Readable {\n  /** @param {...Stream.Readable} streams */\n  constructor(...streams) {\n    super({objectMode: true})\n    this.id = chainCount++\n    this.ix = -1\n    this.streams = streams\n    this.next()\n    if (this.streams[this.ix]) {\n      this.streams[this.ix].pause()\n    }\n  }\n\n  next() {\n    log(`Chain {id: ${this.id}}#next()`)\n    this.ix++\n    if (this.ix === this.streams.length) {\n      log(`  this.push(null)`)\n      this.push(null)\n    } else {\n      const cur = this.streams[this.ix]\n\n      cur.once('error', e => {\n        log(`Chain {id: ${this.id}}#next()`)\n        log(`  cur.once('error', ...)`)\n        log(`    this.destroy(${e})`)\n        this.destroy(e)\n      })\n\n      cur.once('end', () => {\n        log(`Chain {id: ${this.id}}#next()`)\n        log(`  cur.once('end', ...)`)\n        log(`    this.next()`)\n        this.next()\n      })\n\n      cur.on('data', ck => {\n        log(`Chain {id: ${this.id}}#next()`)\n        log(`  cur.on('data', ...)`)\n        log(`    this.push(${ck})`)\n        const canPush = this.push(ck)\n        if (cur && !canPush) {\n          log(`    cur.pause()`)\n          cur.pause()\n        }\n      })\n\n      const prev = this.streams[this.ix - 1]\n      if (prev && prev.isPaused()) {\n        cur.pause()\n      }\n    }\n  }\n\n  _read() {\n    log(`Chain {id: ${this.id}}#_read()`)\n    this.streams.forEach(s => {\n      if (s.isPaused()) {\n        log(`  s.resume()`)\n        s.resume()\n      }\n    })\n  }\n}\n\n/**\n  * @template T\n  * @template R\n  */\nexport class Map extends Stream.Transform {\n  /** @param {(t: T) => R} f */\n  constructor(f) {\n    super({objectMode: true})\n    this.f = f\n    this.id = mapCount++\n  }\n\n  /** @type {Stream.Transform['_transform']} */\n  _transform(ck, _, cb) {\n    log(`Map {id: ${this.id}}#_transform(${ck}, _, _)`)\n    const r = this.f(ck)\n    log(`  const r = (${r})`)\n    log(`  cb(null, ${r})`)\n    cb(null, r)\n  }\n}\n\nexport class Zip extends Stream.Readable {\n  /** @type {Array<Stream.Readable>} */\n  streams = []\n\n  /** @type {Array<unknown | null>} */\n  buf = []\n\n  /** @param {...Stream.Readable} streams */\n  constructor(...streams) {\n    super({objectMode: true})\n    this.id = zipCount++\n    log(`Zip {id: ${this.id}}#new()`)\n    log(`  this.streams = Array {streams: ${streams.length}}`)\n    this.streams = streams\n    this.streams.forEach((s, ix) => {\n      log(`  this.streams[${ix}].once('error', ...)`)\n      log(`  this.streams[${ix}].once('end', ...)`)\n      log(`  this.streams[${ix}].once('data', ...)`)\n      s.once('error', e => this.destroy(e))\n      s.once('end', () => this.push(null))\n      s.on('data', ck => {\n        log(`Zip {id: ${this.id}}#new()`)\n        log(`  this.streams[${ix}].once('data', ...)`)\n        log(`    this.bufput(${ix}, ${ck})`)\n        log(`    stream.pause()`)\n        this.bufput(ix, ck)\n        s.pause()\n      })\n      s.pause()\n    })\n  }\n\n  /** @type {(ix: number, val: unknown) => boolean} */\n  bufput(ix, val) {\n    log(`Zip {id: ${this.id}}#bufput(${ix}, ${val})`)\n    const bufstr = JSON.stringify(this.buf.map(a => a === null ? 'null' : '..'))\n    log(`  this.buf = ${bufstr}`)\n    this.buf[ix] = val\n    if (!this.isWaiting()) {\n      log(`  this.push(${bufstr})`)\n      const canPush = this.push(this.buf)\n      this.bufinit()\n      if (canPush) {\n        log(`  this.streams.forEach(s => s.resume())`)\n        this.streams.forEach(s => s.resume())\n      }\n      return canPush\n    } else {\n      return true\n    }\n  }\n\n  bufinit() {\n    const nuls = this.streams.map(() => null)\n    log(`  this.buf = ${JSON.stringify(nuls)}`)\n    this.buf = nuls\n  }\n\n  isWaiting() {\n    return this.buf.some(a => a === null)\n  }\n\n  _read() {\n    log(`Zip {id: ${this.id}}#_read()`)\n    this.streams.forEach(s => {\n      if (s.isPaused()) {\n        s.resume()\n      }\n    })\n  }\n}\n\nexport class Compose extends Stream.Duplex {\n  /**\n   * @param {Stream.Readable | Stream.Transform} a\n   * @param {Stream.Transform} b\n   */\n  constructor(a, b) {\n    super({objectMode: true})\n    this.id = composeCount++\n\n    this.a = a\n    this.b = b\n\n    log(`Compose {id: ${this.id}}#new()`)\n    log(`  a.on('data', ...)`)\n    log(`  a.once('end', ...)`)\n    log(`  a.once('error', ...)`)\n    log(`  a.pause()`)\n    log(`  b.on('drain', ...)`)\n    log(`  b.on('data', ...)`)\n    log(`  b.on('error', ...)`)\n    log(`  b.on('finish', ...)`)\n\n    this.a.once('end', () => {\n      log(`Compose {id: ${this.id}}#new()`)\n      log(`  a.on('end', ...)`)\n      log(`    b.end()`)\n      this.b.end()\n    })\n\n    this.a.on('data', ck => {\n      log(`Compose {id: ${this.id}}#new()`)\n      log(`  a.on('data', ...)`)\n      log(`    b.write(${ck})`)\n      const canWrite = this.b.write(ck)\n\n      if (!canWrite) {\n        log(`    a.pause()`)\n        this.a.pause()\n      }\n    })\n\n    this.a.once('error', e => {\n      log(`Compose {id: ${this.id}}#new()`)\n      log(`  a.once('error', ...)`)\n      log(`    this.destroy(${e})`)\n      this.destroy(e)\n      this.b.destroy(e)\n    })\n\n    this.b.on('drain', () => {\n      log(`Compose {id: ${this.id}}#new()`)\n      log(`  b.on('drain', ...)`)\n      log(`    this.a.resume()`)\n      this.a.resume()\n    })\n\n    this.b.on('data', ck => {\n      log(`Compose {id: ${this.id}}#new()`)\n      log(`  b.on('data', ...)`)\n      log(`    this.push(${ck})`)\n      const canPush = this.push(ck)\n      if (!canPush) {\n        log(`    b.pause()`)\n        this.b.pause()\n      }\n    })\n\n    this.b.once('end', () => {\n      log(`Compose {id: ${this.id}}#new()`)\n      log(`  b.once('end', ...)`)\n      log(`    this.push(null)`)\n      this.push(null)\n    })\n\n    this.b.once('error', e => {\n      log(`Compose {id: ${this.id}}#new()`)\n      log(`  b.once('error', ...)`)\n      log(`    this.destroy(${e})`)\n      this.destroy(e)\n      this.a.destroy(e)\n    })\n\n    this.b.once('finish', () => {\n      log(`Compose {id: ${this.id}}#new()`)\n      log(`  b.once('finish', ...)`)\n      log(`    this.emit('finish')`)\n      this.emit('finish')\n    })\n  }\n\n  _read() {\n    log(`Compose {id: ${this.id}}#_read()`)\n    if (this.b.isPaused()) {\n      log(`  b.resume()`)\n      this.b.resume()\n    }\n  }\n\n  /** @type {Stream.Duplex['_write']} */\n  _write(ck, _enc, cb) {\n    log(`Compose {id: ${this.id}}#_write(${ck}, _, _)`)\n    if (this.a instanceof Stream.Readable) {\n      throw new Error('Cannot `write` to a Readable stream')\n    }\n\n    log(`  this.a.write(${ck}, _, _)`)\n    this.a.write(ck, _enc, cb)\n  }\n}\n\n/**\n * @template T \n */\nexport class Bind extends Stream.Duplex {\n  /**\n   * @param {(t: T) => () => Stream.Readable} f\n   */\n  constructor(f) {\n    super({objectMode: true})\n    this.f = f\n    this.id = bindCount++\n\n    /** @type {Stream.Readable | undefined } */\n    this.cur = undefined\n\n    /** @type {Array<Stream.Readable>} */\n    this.streams = []\n    this.done = false\n  }\n\n  /** @type {NonNullable<Stream.Duplex['_final']>} */\n  _final(cb) {\n    log(`Bind {id: ${this.id}}#_final(_)`)\n    this.done = true\n    cb()\n  }\n\n  initcur() {\n    log(`Bind {id: ${this.id}}#initcur()`)\n    if (!this.cur) {\n      this.cur = this.streams[0]\n    }\n\n    const s = this.cur\n\n    log(`  s.on('data', ...)`)\n    s.on('data', ck => {\n      log(`Bind {id: ${this.id}}#initcur()`)\n      log(`  s.on('data', ...)`)\n      log(`    this.push(${ck})`)\n      const canPush = this.push(ck)\n      if (!canPush) {\n        s.pause()\n      }\n    })\n\n    log(`  s.once('end', ...)`)\n    s.once('end', () => {\n      log(`Bind {id: ${this.id}}#initcur()`)\n      log(`  s.once('end', ...)`)\n      log(`  this.streams.shift()`)\n      this.streams.shift()\n      if (this.streams.length > 0) {\n        log(`  this.cur = this.streams[0]`)\n        this.cur = this.streams[0]\n        log(`  this.initcur()`)\n        this.initcur()\n      } else if (this.done) {\n        log(`  this.push(null)`)\n        this.push(null)\n      } else {\n        log(`  this.cur = undefined`)\n        this.cur = undefined\n      }\n    })\n  }\n\n  /** @type {Stream.Duplex['_write']} */\n  _write(ck, _, cb) {\n    log(`Bind {id: ${this.id}}#_write(${ck}, _, _)`)\n    try {\n      log(`  this.streams = ${JSON.stringify(this.streams.map(_ => 'Readable'))}`)\n      this.streams.push(this.f(ck)())\n      log(`  this.initcur()`)\n      this.initcur()\n      log(`  cb()`)\n      cb()\n    } catch(e) {\n      log(`  cb(${e})`)\n      // @ts-ignore\n      cb(e)\n    }\n  }\n\n  /** @type {Stream.Duplex['_read']} */\n  _read() {\n    log(`Bind {id: ${this.id}}#_read()`)\n    if (this.cur && this.cur.isPaused()) {\n      log(`  this.cur.resume()`)\n      this.cur.resume()\n    }\n  }\n}\n\n/** @type {() => Stream.Readable} */\nexport const neverImpl = () => new Never();\n\n/** @type {<T>(a: T) => () => Stream.Transform} */\nexport const constImpl = (a) => () => new Const(a);\n\n/** @type {<T>(a: T) => () => Stream.Readable} */\nexport const onceImpl = (a) => () => new Once(a);\n\n/** @type {<T>(a: () => Promise<T>) => () => Stream.Readable} */\nexport const fromPromiseImpl = (a) => () => new FromPromise(a())\n\n/** @type {(ss: Array<Stream.Readable>) => () => Stream.Readable} */\nexport const chainImpl = (ss) => () => new Chain(...ss);\n\n/** @type {<T, R>(f: (t: T) => R) => () => Stream.Transform} */\nexport const mapImpl = (f) => () => new Map(f);\n\n/** @type {(iab: Stream.Readable) => (ia: Stream.Readable) => () => Stream.Readable} */\nexport const applyImpl = (iab) => (ia) => () =>\n  new Compose(new Zip(iab, ia), new Map(([ab, a]) => ab(a)))\n\n/** @type {<T>(f: (t: T) => () => Stream.Readable) => () => Stream.Duplex} */\nexport const bindImpl = (f) => () => new Bind(f)\n\n/** @type {(a: Stream.Transform | Stream.Readable) => (b: Stream.Transform) => () => Stream.Duplex} */\nexport const pipeImpl = (a) => (b) => () => new Compose(a, b)\n\nprocess.on('beforeExit', () => {\n  debugger;\n})\n", "export function promise(f) {\n  return function () {\n    return new Promise(function (success, error) {\n      var succF = function (s) { return function() { return success(s); } };\n      var failF = function (s) { return function() { return error(s); } };\n\n      // This indicates the aff was wrong?\n      try { f(succF)(failF)(); }\n      catch (e) {\n        error(e);\n      }\n    });\n  };\n}\n\nexport function thenImpl(promise) {\n  return function(errCB) {\n    return function(succCB) {\n      return function() {\n        promise.then(succCB, errCB);\n      };\n    };\n  };\n}\n", "export const mapWithIndexArray = function (f) {\n  return function (xs) {\n    var l = xs.length;\n    var result = Array(l);\n    for (var i = 0; i < l; i++) {\n      result[i] = f(i)(xs[i]);\n    }\n    return result;\n  };\n};\n", "module Data.FunctorWithIndex\n  ( class FunctorWithIndex, mapWithIndex, mapDefault\n  ) where\n\nimport Prelude\n\nimport Data.Bifunctor (bimap)\nimport Data.Const (Const(..))\nimport Data.Either (Either(..))\nimport Data.Functor.App (App(..))\nimport Data.Functor.Compose (Compose(..))\nimport Data.Functor.Coproduct (Coproduct(..))\nimport Data.Functor.Product (Product(..))\nimport Data.Identity (Identity(..))\nimport Data.Maybe (Maybe)\nimport Data.Maybe.First (First)\nimport Data.Maybe.Last (Last)\nimport Data.Monoid.Additive (Additive)\nimport Data.Monoid.Conj (Conj)\nimport Data.Monoid.Disj (Disj)\nimport Data.Monoid.Dual (Dual)\nimport Data.Monoid.Multiplicative (Multiplicative)\nimport Data.Tuple (Tuple, curry)\n\n-- | A `Functor` with an additional index.\n-- | Instances must satisfy a modified form of the `Functor` laws\n-- | ```purescript\n-- | mapWithIndex (\\_ a -> a) = identity\n-- | mapWithIndex f . mapWithIndex g = mapWithIndex (\\i -> f i <<< g i)\n-- | ```\n-- | and be compatible with the `Functor` instance\n-- | ```purescript\n-- | map f = mapWithIndex (const f)\n-- | ```\nclass Functor f <= FunctorWithIndex i f | f -> i where\n  mapWithIndex :: forall a b. (i -> a -> b) -> f a -> f b\n\nforeign import mapWithIndexArray :: forall a b. (Int -> a -> b) -> Array a -> Array b\n\ninstance functorWithIndexArray :: FunctorWithIndex Int Array where\n  mapWithIndex = mapWithIndexArray\n\ninstance functorWithIndexMaybe :: FunctorWithIndex Unit Maybe where\n  mapWithIndex f = map $ f unit\n\ninstance functorWithIndexFirst :: FunctorWithIndex Unit First where\n  mapWithIndex f = map $ f unit\n\ninstance functorWithIndexLast :: FunctorWithIndex Unit Last where\n  mapWithIndex f = map $ f unit\n\ninstance functorWithIndexAdditive :: FunctorWithIndex Unit Additive where\n  mapWithIndex f = map $ f unit\n\ninstance functorWithIndexDual :: FunctorWithIndex Unit Dual where\n  mapWithIndex f = map $ f unit\n\ninstance functorWithIndexConj :: FunctorWithIndex Unit Conj where\n  mapWithIndex f = map $ f unit\n\ninstance functorWithIndexDisj :: FunctorWithIndex Unit Disj where\n  mapWithIndex f = map $ f unit\n\ninstance functorWithIndexMultiplicative :: FunctorWithIndex Unit Multiplicative where\n  mapWithIndex f = map $ f unit\n\ninstance functorWithIndexEither :: FunctorWithIndex Unit (Either a) where\n  mapWithIndex f = map $ f unit\n\ninstance functorWithIndexTuple :: FunctorWithIndex Unit (Tuple a) where\n  mapWithIndex f = map $ f unit\n\ninstance functorWithIndexIdentity :: FunctorWithIndex Unit Identity where\n  mapWithIndex f (Identity a) = Identity (f unit a)\n\ninstance functorWithIndexConst :: FunctorWithIndex Void (Const a) where\n  mapWithIndex _ (Const x) = Const x\n\ninstance functorWithIndexProduct :: (FunctorWithIndex a f, FunctorWithIndex b g) => FunctorWithIndex (Either a b) (Product f g) where\n  mapWithIndex f (Product fga) = Product (bimap (mapWithIndex (f <<< Left)) (mapWithIndex (f <<< Right)) fga)\n\ninstance functorWithIndexCoproduct :: (FunctorWithIndex a f, FunctorWithIndex b g) => FunctorWithIndex (Either a b) (Coproduct f g) where\n  mapWithIndex f (Coproduct e) = Coproduct (bimap (mapWithIndex (f <<< Left)) (mapWithIndex (f <<< Right)) e)\n\ninstance functorWithIndexCompose :: (FunctorWithIndex a f, FunctorWithIndex b g) => FunctorWithIndex (Tuple a b) (Compose f g) where\n  mapWithIndex f (Compose fga) = Compose $ mapWithIndex (mapWithIndex <<< curry f) fga\n\ninstance functorWithIndexApp :: FunctorWithIndex a f => FunctorWithIndex a (App f) where\n  mapWithIndex f (App x) = App $ mapWithIndex f x\n\n-- | A default implementation of Functor's `map` in terms of `mapWithIndex`\nmapDefault :: forall i f a b. FunctorWithIndex i f => (a -> b) -> f a -> f b\nmapDefault f = mapWithIndex (const f)\n", "export const unfoldrArrayImpl = function (isNothing) {\n  return function (fromJust) {\n    return function (fst) {\n      return function (snd) {\n        return function (f) {\n          return function (b) {\n            var result = [];\n            var value = b;\n            while (true) { // eslint-disable-line no-constant-condition\n              var maybe = f(value);\n              if (isNothing(maybe)) return result;\n              var tuple = fromJust(maybe);\n              result.push(fst(tuple));\n              value = snd(tuple);\n            }\n          };\n        };\n      };\n    };\n  };\n};\n", "export const unfoldr1ArrayImpl = function (isNothing) {\n  return function (fromJust) {\n    return function (fst) {\n      return function (snd) {\n        return function (f) {\n          return function (b) {\n            var result = [];\n            var value = b;\n            while (true) { // eslint-disable-line no-constant-condition\n              var tuple = f(value);\n              result.push(fst(tuple));\n              var maybe = snd(tuple);\n              if (isNothing(maybe)) return result;\n              value = fromJust(maybe);\n            }\n          };\n        };\n      };\n    };\n  };\n};\n", "module Data.Unfoldable1\n  ( class Unfoldable1, unfoldr1\n  , replicate1\n  , replicate1A\n  , singleton\n  , range\n  , iterateN\n  ) where\n\nimport Prelude\n\nimport Data.Maybe (Maybe(..), fromJust, isNothing)\nimport Data.Semigroup.Traversable (class Traversable1, sequence1)\nimport Data.Tuple (Tuple(..), fst, snd)\nimport Partial.Unsafe (unsafePartial)\n\n-- | This class identifies data structures which can be _unfolded_.\n-- |\n-- | The generating function `f` in `unfoldr1 f` corresponds to the `uncons`\n-- | operation of a non-empty list or array; it always returns a value, and\n-- | then optionally a value to continue unfolding from.\n-- |\n-- | Note that, in order to provide an `Unfoldable1 t` instance, `t` need not\n-- | be a type which is guaranteed to be non-empty. For example, the fact that\n-- | lists can be empty does not prevent us from providing an\n-- | `Unfoldable1 List` instance. However, the result of `unfoldr1` should\n-- | always be non-empty.\n-- |\n-- | Every type which has an `Unfoldable` instance can be given an\n-- | `Unfoldable1` instance (and, in fact, is required to, because\n-- | `Unfoldable1` is a superclass of `Unfoldable`). However, there are types\n-- | which have `Unfoldable1` instances but cannot have `Unfoldable` instances.\n-- | In particular, types which are guaranteed to be non-empty, such as\n-- | `NonEmptyList`, cannot be given `Unfoldable` instances.\n-- |\n-- | The utility of this class, then, is that it provides an `Unfoldable`-like\n-- | interface while still permitting instances for guaranteed-non-empty types\n-- | like `NonEmptyList`.\nclass Unfoldable1 t where\n  unfoldr1 :: forall a b. (b -> Tuple a (Maybe b)) -> b -> t a\n\ninstance unfoldable1Array :: Unfoldable1 Array where\n  unfoldr1 = unfoldr1ArrayImpl isNothing (unsafePartial fromJust) fst snd\n\ninstance unfoldable1Maybe :: Unfoldable1 Maybe where\n  unfoldr1 f b = Just (fst (f b))\n\nforeign import unfoldr1ArrayImpl\n  :: forall a b\n   . (forall x. Maybe x -> Boolean)\n  -> (forall x. Maybe x -> x)\n  -> (forall x y. Tuple x y -> x)\n  -> (forall x y. Tuple x y -> y)\n  -> (b -> Tuple a (Maybe b))\n  -> b\n  -> Array a\n\n-- | Replicate a value `n` times. At least one value will be produced, so values\n-- | `n` less than 1 will be treated as 1.\n-- |\n-- | ``` purescript\n-- | replicate1 2 \"foo\" == (NEL.cons \"foo\" (NEL.singleton \"foo\") :: NEL.NonEmptyList String)\n-- | replicate1 0 \"foo\" == (NEL.singleton \"foo\" :: NEL.NonEmptyList String)\n-- | ```\nreplicate1 :: forall f a. Unfoldable1 f => Int -> a -> f a\nreplicate1 n v = unfoldr1 step (n - 1)\n  where\n    step :: Int -> Tuple a (Maybe Int)\n    step i\n      | i <= 0 = Tuple v Nothing\n      | otherwise = Tuple v (Just (i - 1))\n\n-- | Perform an `Apply` action `n` times (at least once, so values `n` less\n-- | than 1 will be treated as 1), and accumulate the results.\n-- |\n-- | ``` purescript\n-- | > replicate1A 2 (randomInt 1 10) :: Effect (NEL.NonEmptyList Int)\n-- | (NonEmptyList (NonEmpty 8 (2 : Nil)))\n-- | > replicate1A 0 (randomInt 1 10) :: Effect (NEL.NonEmptyList Int)\n-- | (NonEmptyList (NonEmpty 4 Nil))\n-- | ```\nreplicate1A\n  :: forall m f a\n   . Apply m\n  => Unfoldable1 f\n  => Traversable1 f\n  => Int\n  -> m a\n  -> m (f a)\nreplicate1A n m = sequence1 (replicate1 n m)\n\n-- | Contain a single value. For example:\n-- |\n-- | ``` purescript\n-- | singleton \"foo\" == (NEL.singleton \"foo\" :: NEL.NonEmptyList String)\n-- | ```\nsingleton :: forall f a. Unfoldable1 f => a -> f a\nsingleton = replicate1 1\n\n-- | Create an `Unfoldable1` containing a range of values, including both\n-- | endpoints.\n-- |\n-- | ``` purescript\n-- | range 0 0 == (NEL.singleton 0 :: NEL.NonEmptyList Int)\n-- | range 1 2 == (NEL.cons 1 (NEL.singleton 2) :: NEL.NonEmptyList Int)\n-- | range 2 0 == (NEL.cons 2 (NEL.cons 1 (NEL.singleton 0)) :: NEL.NonEmptyList Int)\n-- | ```\nrange :: forall f. Unfoldable1 f => Int -> Int -> f Int\nrange start end =\n  let delta = if end >= start then 1 else -1 in unfoldr1 (go delta) start\n  where\n    go delta i =\n      let i' = i + delta\n      in Tuple i (if i == end then Nothing else Just i')\n\n-- | Create an `Unfoldable1` by repeated application of a function to a seed value.\n-- | For example:\n-- |\n-- | ``` purescript\n-- | (iterateN 5 (_ + 1) 0 :: Array Int) == [0, 1, 2, 3, 4]\n-- | (iterateN 5 (_ + 1) 0 :: NonEmptyArray Int) == NonEmptyArray [0, 1, 2, 3, 4]\n-- |\n-- | (iterateN 0 (_ + 1) 0 :: Array Int) == [0]\n-- | (iterateN 0 (_ + 1) 0 :: NonEmptyArray Int) == NonEmptyArray [0]\n-- | ```\niterateN :: forall f a. Unfoldable1 f => Int -> (a -> a) -> a -> f a\niterateN n f s = unfoldr1 go $ Tuple s (n - 1)\n  where\n  go (Tuple x n') = Tuple x\n    if n' > 0 then Just $ Tuple (f x) $ n' - 1\n    else Nothing\n", "-- | This module provides a type class for _unfoldable functors_, i.e.\n-- | functors which support an `unfoldr` operation.\n-- |\n-- | This allows us to unify various operations on arrays, lists,\n-- | sequences, etc.\n\nmodule Data.Unfoldable\n  ( class Unfoldable, unfoldr\n  , replicate\n  , replicateA\n  , none\n  , fromMaybe\n  , module Data.Unfoldable1\n  ) where\n\nimport Prelude\n\nimport Data.Maybe (Maybe(..), isNothing, fromJust)\nimport Data.Traversable (class Traversable, sequence)\nimport Data.Tuple (Tuple(..), fst, snd)\nimport Data.Unfoldable1 (class Unfoldable1, unfoldr1, singleton, range, iterateN, replicate1, replicate1A)\nimport Partial.Unsafe (unsafePartial)\n\n-- | This class identifies (possibly empty) data structures which can be\n-- | _unfolded_.\n-- |\n-- | The generating function `f` in `unfoldr f` is understood as follows:\n-- |\n-- | - If `f b` is `Nothing`, then `unfoldr f b` should be empty.\n-- | - If `f b` is `Just (Tuple a b1)`, then `unfoldr f b` should consist of `a`\n-- |   appended to the result of `unfoldr f b1`.\n-- |\n-- | Note that it is not possible to give `Unfoldable` instances to types which\n-- | represent structures which are guaranteed to be non-empty, such as\n-- | `NonEmptyArray`: consider what `unfoldr (const Nothing)` should produce.\n-- | Structures which are guaranteed to be non-empty can instead be given\n-- | `Unfoldable1` instances.\nclass Unfoldable1 t <= Unfoldable t where\n  unfoldr :: forall a b. (b -> Maybe (Tuple a b)) -> b -> t a\n\ninstance unfoldableArray :: Unfoldable Array where\n  unfoldr = unfoldrArrayImpl isNothing (unsafePartial fromJust) fst snd\n\ninstance unfoldableMaybe :: Unfoldable Maybe where\n  unfoldr f b = fst <$> f b\n\nforeign import unfoldrArrayImpl\n  :: forall a b\n   . (forall x. Maybe x -> Boolean)\n  -> (forall x. Maybe x -> x)\n  -> (forall x y. Tuple x y -> x)\n  -> (forall x y. Tuple x y -> y)\n  -> (b -> Maybe (Tuple a b))\n  -> b\n  -> Array a\n\n-- | Replicate a value some natural number of times.\n-- | For example:\n-- |\n-- | ``` purescript\n-- | replicate 2 \"foo\" == ([\"foo\", \"foo\"] :: Array String)\n-- | ```\nreplicate :: forall f a. Unfoldable f => Int -> a -> f a\nreplicate n v = unfoldr step n\n  where\n    step :: Int -> Maybe (Tuple a Int)\n    step i =\n      if i <= 0 then Nothing\n      else Just (Tuple v (i - 1))\n\n-- | Perform an Applicative action `n` times, and accumulate all the results.\n-- |\n-- | ``` purescript\n-- | > replicateA 5 (randomInt 1 10) :: Effect (Array Int)\n-- | [1,3,2,7,5]\n-- | ```\nreplicateA\n  :: forall m f a\n   . Applicative m\n  => Unfoldable f\n  => Traversable f\n  => Int\n  -> m a\n  -> m (f a)\nreplicateA n m = sequence (replicate n m)\n\n-- | The container with no elements - unfolded with zero iterations.\n-- | For example:\n-- |\n-- | ``` purescript\n-- | none == ([] :: Array Unit)\n-- | ```\nnone :: forall f a. Unfoldable f => f a\nnone = unfoldr (const Nothing) unit\n\n-- | Convert a Maybe to any Unfoldable, such as lists or arrays.\n-- |\n-- | ``` purescript\n-- | fromMaybe (Nothing :: Maybe Int) == []\n-- | fromMaybe (Just 1) == [1]\n-- | ```\nfromMaybe :: forall f a. Unfoldable f => Maybe a -> f a\nfromMaybe = unfoldr (\\b -> flip Tuple Nothing <$> b)\n", "-- | This module defines a generic non-empty data structure, which adds an\n-- | additional element to any container type.\nmodule Data.NonEmpty\n  ( NonEmpty(..)\n  , singleton\n  , (:|)\n  , foldl1\n  , fromNonEmpty\n  , oneOf\n  , head\n  , tail\n  ) where\n\nimport Prelude\n\nimport Control.Alt ((<|>))\nimport Control.Alternative (class Alternative)\nimport Control.Plus (class Plus, empty)\nimport Data.Eq (class Eq1)\nimport Data.Foldable (class Foldable, foldl, foldr, foldMap)\nimport Data.FoldableWithIndex (class FoldableWithIndex, foldMapWithIndex, foldlWithIndex, foldrWithIndex)\nimport Data.FunctorWithIndex (class FunctorWithIndex, mapWithIndex)\nimport Data.Maybe (Maybe(..), maybe)\nimport Data.Ord (class Ord1)\nimport Data.Semigroup.Foldable (class Foldable1)\nimport Data.Semigroup.Foldable (foldl1) as Foldable1\nimport Data.Traversable (class Traversable, traverse, sequence)\nimport Data.TraversableWithIndex (class TraversableWithIndex, traverseWithIndex)\nimport Data.Tuple (uncurry)\nimport Data.Unfoldable (class Unfoldable, unfoldr)\nimport Data.Unfoldable1 (class Unfoldable1)\n\n-- | A non-empty container of elements of type a.\n-- |\n-- | ```purescript\n-- | import Data.NonEmpty\n-- |\n-- | nonEmptyArray :: NonEmpty Array Int\n-- | nonEmptyArray = NonEmpty 1 [2,3]\n-- |\n-- | import Data.List(List(..), (:))\n-- |\n-- | nonEmptyList :: NonEmpty List Int\n-- | nonEmptyList = NonEmpty 1 (2 : 3 : Nil)\n-- | ```\ndata NonEmpty f a = NonEmpty a (f a)\n\n-- | An infix synonym for `NonEmpty`.\n-- |\n-- | ```purescript\n-- | nonEmptyArray :: NonEmpty Array Int\n-- | nonEmptyArray = 1 :| [2,3]\n-- |\n-- | nonEmptyList :: NonEmpty List Int\n-- | nonEmptyList = 1 :| 2 : 3 : Nil\n-- | ```\ninfixr 5 NonEmpty as :|\n\n-- | Create a non-empty structure with a single value.\n-- |\n-- | ```purescript\n-- | import Prelude\n-- |\n-- | singleton 1 == 1 :| []\n-- | singleton 1 == 1 :| Nil\n-- | ```\nsingleton :: forall f a. Plus f => a -> NonEmpty f a\nsingleton a = a :| empty\n\n-- | Fold a non-empty structure, collecting results using a binary operation.\n-- |\n-- | ```purescript\n-- | foldl1 (+) (1 :| [2, 3]) == 6\n-- | ```\nfoldl1 :: forall f a. Foldable f => (a -> a -> a) -> NonEmpty f a -> a\nfoldl1 = Foldable1.foldl1\n\n-- | Apply a function that takes the `first` element and remaining elements\n-- | as arguments to a non-empty container.\n-- |\n-- | For example, return the remaining elements multiplied by the first element:\n-- |\n-- | ```purescript\n-- | fromNonEmpty (\\x xs -> map (_ * x) xs) (3 :| [2, 1]) == [6, 3]\n-- | ```\nfromNonEmpty :: forall f a r. (a -> f a -> r) -> NonEmpty f a -> r\nfromNonEmpty f (a :| fa) = a `f` fa\n\n-- | Returns the `alt` (`<|>`) result of:\n-- | - The first element lifted to the container of the remaining elements.\n-- | - The remaining elements.\n-- |\n-- | ```purescript\n-- | import Data.Maybe(Maybe(..))\n-- |\n-- | oneOf (1 :| Nothing) == Just 1\n-- | oneOf (1 :| Just 2) == Just 1\n-- |\n-- | oneOf (1 :| [2, 3]) == [1,2,3]\n-- | ```\noneOf :: forall f a. Alternative f => NonEmpty f a -> f a\noneOf (a :| fa) = pure a <|> fa\n\n-- | Get the 'first' element of a non-empty container.\n-- |\n-- | ```purescript\n-- | head (1 :| [2, 3]) == 1\n-- | ```\nhead :: forall f a. NonEmpty f a -> a\nhead (x :| _) = x\n\n-- | Get everything but the 'first' element of a non-empty container.\n-- |\n-- | ```purescript\n-- | tail (1 :| [2, 3]) == [2, 3]\n-- | ```\ntail :: forall f a. NonEmpty f a -> f a\ntail (_ :| xs) = xs\n\ninstance showNonEmpty :: (Show a, Show (f a)) => Show (NonEmpty f a) where\n  show (a :| fa) = \"(NonEmpty \" <> show a <> \" \" <> show fa <> \")\"\n\nderive instance eqNonEmpty :: (Eq1 f, Eq a) => Eq (NonEmpty f a)\n\nderive instance eq1NonEmpty :: Eq1 f => Eq1 (NonEmpty f)\n\nderive instance ordNonEmpty :: (Ord1 f, Ord a) => Ord (NonEmpty f a)\n\nderive instance ord1NonEmpty :: Ord1 f => Ord1 (NonEmpty f)\n\nderive instance functorNonEmpty :: Functor f => Functor (NonEmpty f)\n\ninstance functorWithIndex\n  :: FunctorWithIndex i f\n  => FunctorWithIndex (Maybe i) (NonEmpty f) where\n  mapWithIndex f (a :| fa) = f Nothing a :| mapWithIndex (f <<< Just) fa\n\ninstance foldableNonEmpty :: Foldable f => Foldable (NonEmpty f) where\n  foldMap f (a :| fa) = f a <> foldMap f fa\n  foldl f b (a :| fa) = foldl f (f b a) fa\n  foldr f b (a :| fa) = f a (foldr f b fa)\n\ninstance foldableWithIndexNonEmpty\n  :: (FoldableWithIndex i f)\n  => FoldableWithIndex (Maybe i) (NonEmpty f) where\n  foldMapWithIndex f (a :| fa) = f Nothing a <> foldMapWithIndex (f <<< Just) fa\n  foldlWithIndex f b (a :| fa) = foldlWithIndex (f <<< Just) (f Nothing b a) fa\n  foldrWithIndex f b (a :| fa) = f Nothing a (foldrWithIndex (f <<< Just) b fa)\n\ninstance traversableNonEmpty :: Traversable f => Traversable (NonEmpty f) where\n  sequence (a :| fa) = NonEmpty <$> a <*> sequence fa\n  traverse f (a :| fa) = NonEmpty <$> f a <*> traverse f fa\n\ninstance traversableWithIndexNonEmpty\n  :: (TraversableWithIndex i f)\n  => TraversableWithIndex (Maybe i) (NonEmpty f) where\n  traverseWithIndex f (a :| fa) =\n    NonEmpty <$> f Nothing a <*> traverseWithIndex (f <<< Just) fa\n\ninstance foldable1NonEmpty :: Foldable f => Foldable1 (NonEmpty f) where\n  foldMap1 f (a :| fa) = foldl (\\s a1 -> s <> f a1) (f a) fa\n  foldr1 f (a :| fa) = maybe a (f a) $ foldr (\\a1 -> Just <<< maybe a1 (f a1)) Nothing fa\n  foldl1 f (a :| fa) = foldl f a fa\n\ninstance unfoldable1NonEmpty :: Unfoldable f => Unfoldable1 (NonEmpty f) where\n  unfoldr1 f b = uncurry (:|) $ unfoldr (map f) <$> f b\n\n-- | This is a lawful `Semigroup` instance that will behave sensibly for common nonempty\n-- | containers like lists and arrays. However, it's not guaranteed that `pure` will behave\n-- | sensibly alongside `<>` for all types, as we don't have any laws which govern their behavior.\ninstance semigroupNonEmpty\n  :: (Applicative f, Semigroup (f a))\n  => Semigroup (NonEmpty f a) where\n  append (a1 :| f1) (a2 :| f2) = a1 :| (f1 <> pure a2 <> f2)\n", "module Data.List.Types\n  ( List(..)\n  , (:)\n  , NonEmptyList(..)\n  , toList\n  , nelCons\n  ) where\n\nimport Prelude\n\nimport Control.Alt (class Alt)\nimport Control.Alternative (class Alternative)\nimport Control.Apply (lift2)\nimport Control.Comonad (class Comonad)\nimport Control.Extend (class Extend)\nimport Control.MonadPlus (class MonadPlus)\nimport Control.Plus (class Plus)\nimport Data.Eq (class Eq1, eq1)\nimport Data.Foldable (class Foldable, foldl, foldr, intercalate)\nimport Data.FoldableWithIndex (class FoldableWithIndex, foldlWithIndex, foldrWithIndex, foldMapWithIndex)\nimport Data.FunctorWithIndex (class FunctorWithIndex, mapWithIndex)\nimport Data.Maybe (Maybe(..), maybe)\nimport Data.Newtype (class Newtype)\nimport Data.NonEmpty (NonEmpty, (:|))\nimport Data.NonEmpty as NE\nimport Data.Ord (class Ord1, compare1)\nimport Data.Semigroup.Foldable (class Foldable1)\nimport Data.Semigroup.Traversable (class Traversable1, traverse1)\nimport Data.Traversable (class Traversable, traverse)\nimport Data.TraversableWithIndex (class TraversableWithIndex, traverseWithIndex)\nimport Data.Tuple (Tuple(..), snd)\nimport Data.Unfoldable (class Unfoldable)\nimport Data.Unfoldable1 (class Unfoldable1)\n\ndata List a = Nil | Cons a (List a)\n\ninfixr 6 Cons as :\n\ninstance showList :: Show a => Show (List a) where\n  show Nil = \"Nil\"\n  show xs = \"(\" <> intercalate \" : \" (show <$> xs) <> \" : Nil)\"\n\ninstance eqList :: Eq a => Eq (List a) where\n  eq = eq1\n\ninstance eq1List :: Eq1 List where\n  eq1 xs ys = go xs ys true\n    where\n      go _ _ false = false\n      go Nil Nil acc = acc\n      go (x : xs') (y : ys') acc = go xs' ys' $ acc && (y == x)\n      go _ _ _ = false\n\ninstance ordList :: Ord a => Ord (List a) where\n  compare = compare1\n\ninstance ord1List :: Ord1 List where\n  compare1 xs ys = go xs ys\n    where\n    go Nil Nil = EQ\n    go Nil _ = LT\n    go _ Nil = GT\n    go (x : xs') (y : ys') =\n      case compare x y of\n        EQ -> go xs' ys'\n        other -> other\n\ninstance semigroupList :: Semigroup (List a) where\n  append xs ys = foldr (:) ys xs\n\ninstance monoidList :: Monoid (List a) where\n  mempty = Nil\n\ninstance functorList :: Functor List where\n  map = listMap\n\n-- chunked list Functor inspired by OCaml\n-- https://discuss.ocaml.org/t/a-new-list-map-that-is-both-stack-safe-and-fast/865\n-- chunk sizes determined through experimentation\nlistMap :: forall a b. (a -> b) -> List a -> List b\nlistMap f = chunkedRevMap Nil\n  where\n  chunkedRevMap :: List (List a) -> List a -> List b\n  chunkedRevMap chunksAcc chunk@(_ : _ : _ : xs) =\n    chunkedRevMap (chunk : chunksAcc) xs\n  chunkedRevMap chunksAcc xs =\n    reverseUnrolledMap chunksAcc $ unrolledMap xs\n    where\n    unrolledMap :: List a -> List b\n    unrolledMap (x1 : x2 : Nil) = f x1 : f x2 : Nil\n    unrolledMap (x1 : Nil) = f x1 : Nil\n    unrolledMap _ = Nil\n\n    reverseUnrolledMap :: List (List a) -> List b -> List b\n    reverseUnrolledMap ((x1 : x2 : x3 : _) : cs) acc =\n      reverseUnrolledMap cs (f x1 : f x2 : f x3 : acc)\n    reverseUnrolledMap _ acc = acc\n\ninstance functorWithIndexList :: FunctorWithIndex Int List where\n  mapWithIndex f = foldrWithIndex (\\i x acc -> f i x : acc) Nil\n\ninstance foldableList :: Foldable List where\n  foldr f b = foldl (flip f) b <<< rev\n    where\n    rev = go Nil\n      where\n      go acc Nil = acc\n      go acc (x : xs) = go (x : acc) xs\n  foldl f = go\n    where\n    go b = case _ of\n      Nil -> b\n      a : as -> go (f b a) as\n  foldMap f = foldl (\\acc -> append acc <<< f) mempty\n\ninstance foldableWithIndexList :: FoldableWithIndex Int List where\n  foldrWithIndex f b xs =\n    -- as we climb the reversed list, we decrement the index\n    snd $ foldl\n            (\\(Tuple i b') a -> Tuple (i - 1) (f (i - 1) a b'))\n            (Tuple len b)\n            revList\n    where\n    Tuple len revList = rev (Tuple 0 Nil) xs\n      where\n      -- As we create our reversed list, we count elements.\n      rev = foldl (\\(Tuple i acc) a -> Tuple (i + 1) (a : acc))\n  foldlWithIndex f acc =\n    snd <<< foldl (\\(Tuple i b) a -> Tuple (i + 1) (f i b a)) (Tuple 0 acc)\n  foldMapWithIndex f = foldlWithIndex (\\i acc -> append acc <<< f i) mempty\n\ninstance unfoldable1List :: Unfoldable1 List where\n  unfoldr1 f b = go b Nil\n    where\n    go source memo = case f source of\n      Tuple one (Just rest) -> go rest (one : memo)\n      Tuple one Nothing -> foldl (flip (:)) Nil (one : memo)\n\ninstance unfoldableList :: Unfoldable List where\n  unfoldr f b = go b Nil\n    where\n    go source memo = case f source of\n      Nothing -> (foldl (flip (:)) Nil memo)\n      Just (Tuple one rest) -> go rest (one : memo)\n\ninstance traversableList :: Traversable List where\n  traverse f = map (foldl (flip (:)) Nil) <<< foldl (\\acc -> lift2 (flip (:)) acc <<< f) (pure Nil)\n  sequence = traverse identity\n\ninstance traversableWithIndexList :: TraversableWithIndex Int List where\n  traverseWithIndex f =\n    map rev\n    <<< foldlWithIndex (\\i acc -> lift2 (flip (:)) acc <<< f i) (pure Nil)\n    where\n    rev = foldl (flip Cons) Nil\n\ninstance applyList :: Apply List where\n  apply Nil _ = Nil\n  apply (f : fs) xs = (f <$> xs) <> (fs <*> xs)\n\ninstance applicativeList :: Applicative List where\n  pure a = a : Nil\n\ninstance bindList :: Bind List where\n  bind Nil _ = Nil\n  bind (x : xs) f = f x <> bind xs f\n\ninstance monadList :: Monad List\n\ninstance altList :: Alt List where\n  alt = append\n\ninstance plusList :: Plus List where\n  empty = Nil\n\ninstance alternativeList :: Alternative List\n\ninstance monadPlusList :: MonadPlus List\n\ninstance extendList :: Extend List where\n  extend _ Nil = Nil\n  extend f l@(_ : as) =\n    f l : (foldr go { val: Nil, acc: Nil } as).val\n    where\n    go a' { val, acc } =\n      let acc' = a' : acc\n      in { val: f acc' : val, acc: acc' }\n\nnewtype NonEmptyList a = NonEmptyList (NonEmpty List a)\n\ntoList :: NonEmptyList ~> List\ntoList (NonEmptyList (x :| xs)) = x : xs\n\nnelCons :: forall a. a -> NonEmptyList a -> NonEmptyList a\nnelCons a (NonEmptyList (b :| bs)) = NonEmptyList (a :| b : bs)\n\nderive instance newtypeNonEmptyList :: Newtype (NonEmptyList a) _\n\nderive newtype instance eqNonEmptyList :: Eq a => Eq (NonEmptyList a)\nderive newtype instance ordNonEmptyList :: Ord a => Ord (NonEmptyList a)\n\nderive newtype instance eq1NonEmptyList :: Eq1 NonEmptyList\nderive newtype instance ord1NonEmptyList :: Ord1 NonEmptyList\n\ninstance showNonEmptyList :: Show a => Show (NonEmptyList a) where\n  show (NonEmptyList nel) = \"(NonEmptyList \" <> show nel <> \")\"\n\nderive newtype instance functorNonEmptyList :: Functor NonEmptyList\n\ninstance applyNonEmptyList :: Apply NonEmptyList where\n  apply (NonEmptyList (f :| fs)) (NonEmptyList (a :| as)) =\n    NonEmptyList (f a :| (fs <*> a : Nil) <> ((f : fs) <*> as))\n\ninstance applicativeNonEmptyList :: Applicative NonEmptyList where\n  pure = NonEmptyList <<< NE.singleton\n\ninstance bindNonEmptyList :: Bind NonEmptyList where\n  bind (NonEmptyList (a :| as)) f =\n    case f a of\n      NonEmptyList (b :| bs) ->\n        NonEmptyList (b :| bs <> bind as (toList <<< f))\n\ninstance monadNonEmptyList :: Monad NonEmptyList\n\ninstance altNonEmptyList :: Alt NonEmptyList where\n  alt = append\n\ninstance extendNonEmptyList :: Extend NonEmptyList where\n  extend f w@(NonEmptyList (_ :| as)) =\n    NonEmptyList (f w :| (foldr go { val: Nil, acc: Nil } as).val)\n    where\n    go a { val, acc } = { val: f (NonEmptyList (a :| acc)) : val, acc: a : acc }\n\ninstance comonadNonEmptyList :: Comonad NonEmptyList where\n  extract (NonEmptyList (a :| _)) = a\n\ninstance semigroupNonEmptyList :: Semigroup (NonEmptyList a) where\n  append (NonEmptyList (a :| as)) as' =\n    NonEmptyList (a :| as <> toList as')\n\nderive newtype instance foldableNonEmptyList :: Foldable NonEmptyList\n\nderive newtype instance traversableNonEmptyList :: Traversable NonEmptyList\n\nderive newtype instance foldable1NonEmptyList :: Foldable1 NonEmptyList\n\nderive newtype instance unfoldable1NonEmptyList :: Unfoldable1 NonEmptyList\n\ninstance functorWithIndexNonEmptyList :: FunctorWithIndex Int NonEmptyList where\n  mapWithIndex fn (NonEmptyList ne) = NonEmptyList $ mapWithIndex (fn <<< maybe 0 (add 1)) ne\n\ninstance foldableWithIndexNonEmptyList :: FoldableWithIndex Int NonEmptyList where\n  foldMapWithIndex f (NonEmptyList ne) = foldMapWithIndex (f <<< maybe 0 (add 1)) ne\n  foldlWithIndex f b (NonEmptyList ne) = foldlWithIndex (f <<< maybe 0 (add 1)) b ne\n  foldrWithIndex f b (NonEmptyList ne) = foldrWithIndex (f <<< maybe 0 (add 1)) b ne\n\ninstance traversableWithIndexNonEmptyList :: TraversableWithIndex Int NonEmptyList where\n  traverseWithIndex f (NonEmptyList ne) = NonEmptyList <$> traverseWithIndex (f <<< maybe 0 (add 1)) ne\n\ninstance traversable1NonEmptyList :: Traversable1 NonEmptyList where\n  traverse1 f (NonEmptyList (a :| as)) =\n    foldl (\\acc -> lift2 (flip nelCons) acc <<< f) (pure <$> f a) as\n      <#> case _ of NonEmptyList (x :| xs) \u2192 foldl (flip nelCons) (pure x) xs\n  sequence1 = traverse1 identity\n", "export function typeOf(value) {\n  return typeof value;\n}\n\nexport function tagOf(value) {\n  return Object.prototype.toString.call(value).slice(8, -1);\n}\n\nexport function isNull(value) {\n  return value === null;\n}\n\nexport function isUndefined(value) {\n  return value === undefined;\n}\n\nexport const isArray = Array.isArray || function (value) {\n  return Object.prototype.toString.call(value) === \"[object Array]\";\n};\n", "export const fromNumberImpl = function (just) {\n  return function (nothing) {\n    return function (n) {\n      /* jshint bitwise: false */\n      return (n | 0) === n ? just(n) : nothing;\n    };\n  };\n};\n\nexport const toNumber = function (n) {\n  return n;\n};\n\nexport const fromStringAsImpl = function (just) {\n  return function (nothing) {\n    return function (radix) {\n      var digits;\n      if (radix < 11) {\n        digits = \"[0-\" + (radix - 1).toString() + \"]\";\n      } else if (radix === 11) {\n        digits = \"[0-9a]\";\n      } else {\n        digits = \"[0-9a-\" + String.fromCharCode(86 + radix) + \"]\";\n      }\n      var pattern = new RegExp(\"^[\\\\+\\\\-]?\" + digits + \"+$\", \"i\");\n\n      return function (s) {\n        /* jshint bitwise: false */\n        if (pattern.test(s)) {\n          var i = parseInt(s, radix);\n          return (i | 0) === i ? just(i) : nothing;\n        } else {\n          return nothing;\n        }\n      };\n    };\n  };\n};\n\nexport const toStringAs = function (radix) {\n  return function (i) {\n    return i.toString(radix);\n  };\n};\n\n\nexport const quot = function (x) {\n  return function (y) {\n    /* jshint bitwise: false */\n    return x / y | 0;\n  };\n};\n\nexport const rem = function (x) {\n  return function (y) {\n    return x % y;\n  };\n};\n\nexport const pow = function (x) {\n  return function (y) {\n    /* jshint bitwise: false */\n    return Math.pow(x,y) | 0;\n  };\n};\n", "/* globals exports */\nexport const nan = NaN;\nconst isNaNImpl = isNaN;\nexport { isNaNImpl as isNaN };\nexport const infinity = Infinity;\nconst isFiniteImpl = isFinite;\nexport { isFiniteImpl as isFinite };\n\nexport function fromStringImpl(str, isFinite, just, nothing) {\n  var num = parseFloat(str);\n  if (isFinite(num)) {\n    return just(num);\n  } else {\n    return nothing;\n  }\n}\n\nexport const abs = Math.abs;\n\nexport const acos = Math.acos;\n\nexport const asin = Math.asin;\n\nexport const atan = Math.atan;\n\nexport const atan2 = function (y) {\n  return function (x) {\n    return Math.atan2(y, x);\n  };\n};\n\nexport const ceil = Math.ceil;\n\nexport const cos = Math.cos;\n\nexport const exp = Math.exp;\n\nexport const floor = Math.floor;\n\nexport const log = Math.log;\n\nexport const max = function (n1) {\n  return function (n2) {\n    return Math.max(n1, n2);\n  };\n};\n\nexport const min = function (n1) {\n  return function (n2) {\n    return Math.min(n1, n2);\n  };\n};\n\nexport const pow = function (n) {\n  return function (p) {\n    return Math.pow(n, p);\n  };\n};\n\nexport const remainder = function (n) {\n  return function (m) {\n    return n % m;\n  };\n};\n\nexport const round = Math.round;\n\nexport const sign = Math.sign ? Math.sign : function(x) {\n  return x === 0 || x !== x ? x : (x < 0 ? -1 : 1);\n};\n\nexport const sin = Math.sin;\n\nexport const sqrt = Math.sqrt;\n\nexport const tan = Math.tan;\n\nexport const trunc = Math.trunc ? Math.trunc : function(x) {\n  return x < 0 ? Math.ceil(x) : Math.floor(x);\n}\n", "module Data.Int\n  ( fromNumber\n  , ceil\n  , floor\n  , trunc\n  , round\n  , toNumber\n  , fromString\n  , Radix\n  , radix\n  , binary\n  , octal\n  , decimal\n  , hexadecimal\n  , base36\n  , fromStringAs\n  , toStringAs\n  , Parity(..)\n  , parity\n  , even\n  , odd\n  , quot\n  , rem\n  , pow\n  ) where\n\nimport Prelude\n\nimport Data.Int.Bits ((.&.))\nimport Data.Maybe (Maybe(..), fromMaybe)\nimport Data.Number (isFinite)\nimport Data.Number as Number\n\n-- | Creates an `Int` from a `Number` value. The number must already be an\n-- | integer and fall within the valid range of values for the `Int` type\n-- | otherwise `Nothing` is returned.\nfromNumber :: Number -> Maybe Int\nfromNumber = fromNumberImpl Just Nothing\n\nforeign import fromNumberImpl\n  :: (forall a. a -> Maybe a)\n  -> (forall a. Maybe a)\n  -> Number\n  -> Maybe Int\n\n-- | Convert a `Number` to an `Int`, by taking the closest integer equal to or\n-- | less than the argument. Values outside the `Int` range are clamped, `NaN`\n-- | and `Infinity` values return 0.\nfloor :: Number -> Int\nfloor = unsafeClamp <<< Number.floor\n\n-- | Convert a `Number` to an `Int`, by taking the closest integer equal to or\n-- | greater than the argument. Values outside the `Int` range are clamped,\n-- | `NaN` and `Infinity` values return 0.\nceil :: Number -> Int\nceil = unsafeClamp <<< Number.ceil\n\n-- | Convert a `Number` to an `Int`, by dropping the decimal.\n-- | Values outside the `Int` range are clamped, `NaN` and `Infinity`\n-- | values return 0.\ntrunc :: Number -> Int\ntrunc = unsafeClamp <<< Number.trunc\n\n-- | Convert a `Number` to an `Int`, by taking the nearest integer to the\n-- | argument. Values outside the `Int` range are clamped, `NaN` and `Infinity`\n-- | values return 0.\nround :: Number -> Int\nround = unsafeClamp <<< Number.round\n\n-- | Convert an integral `Number` to an `Int`, by clamping to the `Int` range.\n-- | This function will return 0 if the input is `NaN` or an `Infinity`.\nunsafeClamp :: Number -> Int\nunsafeClamp x\n  | not (isFinite x) = 0\n  | x >= toNumber top = top\n  | x <= toNumber bottom = bottom\n  | otherwise = fromMaybe 0 (fromNumber x)\n\n-- | Converts an `Int` value back into a `Number`. Any `Int` is a valid `Number`\n-- | so there is no loss of precision with this function.\nforeign import toNumber :: Int -> Number\n\n-- | Reads an `Int` from a `String` value. The number must parse as an integer\n-- | and fall within the valid range of values for the `Int` type, otherwise\n-- | `Nothing` is returned.\nfromString :: String -> Maybe Int\nfromString = fromStringAs (Radix 10)\n\n-- | A type for describing whether an integer is even or odd.\n-- |\n-- | The `Ord` instance considers `Even` to be less than `Odd`.\n-- |\n-- | The `Semiring` instance allows you to ask about the parity of the results\n-- | of arithmetical operations, given only the parities of the inputs. For\n-- | example, the sum of an odd number and an even number is odd, so\n-- | `Odd + Even == Odd`. This also works for multiplication, eg. the product\n-- | of two odd numbers is odd, and therefore `Odd * Odd == Odd`.\n-- |\n-- | More generally, we have that\n-- |\n-- | ```purescript\n-- | parity x + parity y == parity (x + y)\n-- | parity x * parity y == parity (x * y)\n-- | ```\n-- |\n-- | for any integers `x`, `y`. (A mathematician would say that `parity` is a\n-- | *ring homomorphism*.)\n-- |\n-- | After defining addition and multiplication on `Parity` in this way, the\n-- | `Semiring` laws now force us to choose `zero = Even` and `one = Odd`.\n-- | This `Semiring` instance actually turns out to be a `Field`.\ndata Parity = Even | Odd\n\nderive instance eqParity :: Eq Parity\nderive instance ordParity :: Ord Parity\n\ninstance showParity :: Show Parity where\n  show Even = \"Even\"\n  show Odd = \"Odd\"\n\ninstance boundedParity :: Bounded Parity where\n  bottom = Even\n  top = Odd\n\ninstance semiringParity :: Semiring Parity where\n  zero = Even\n  add x y = if x == y then Even else Odd\n  one = Odd\n  mul Odd Odd = Odd\n  mul _ _ = Even\n\ninstance ringParity :: Ring Parity where\n  sub = add\n\ninstance commutativeRingParity :: CommutativeRing Parity\n\ninstance euclideanRingParity :: EuclideanRing Parity where\n  degree Even = 0\n  degree Odd = 1\n  div x _ = x\n  mod _ _ = Even\n\ninstance divisionRingParity :: DivisionRing Parity where\n  recip = identity\n\n-- | Returns whether an `Int` is `Even` or `Odd`.\n-- |\n-- | ``` purescript\n-- | parity 0 == Even\n-- | parity 1 == Odd\n-- | ```\nparity :: Int -> Parity\nparity n = if even n then Even else Odd\n\n-- | Returns whether an `Int` is an even number.\n-- |\n-- | ``` purescript\n-- | even 0 == true\n-- | even 1 == false\n-- | ```\neven :: Int -> Boolean\neven x = x .&. 1 == 0\n\n-- | The negation of `even`.\n-- |\n-- | ``` purescript\n-- | odd 0 == false\n-- | odd 1 == true\n-- | ```\nodd :: Int -> Boolean\nodd x = x .&. 1 /= 0\n\n-- | The number of unique digits (including zero) used to represent integers in\n-- | a specific base.\nnewtype Radix = Radix Int\n\n-- | The base-2 system.\nbinary :: Radix\nbinary = Radix 2\n\n-- | The base-8 system.\noctal :: Radix\noctal = Radix 8\n\n-- | The base-10 system.\ndecimal :: Radix\ndecimal = Radix 10\n\n-- | The base-16 system.\nhexadecimal :: Radix\nhexadecimal = Radix 16\n\n-- | The base-36 system.\nbase36 :: Radix\nbase36 = Radix 36\n\n-- | Create a `Radix` from a number between 2 and 36.\nradix :: Int -> Maybe Radix\nradix n | n >= 2 && n <= 36 = Just (Radix n)\n        | otherwise         = Nothing\n\n-- | Like `fromString`, but the integer can be specified in a different base.\n-- |\n-- | Example:\n-- | ``` purs\n-- | fromStringAs binary      \"100\" == Just 4\n-- | fromStringAs hexadecimal \"ff\"  == Just 255\n-- | ```\nfromStringAs :: Radix -> String -> Maybe Int\nfromStringAs = fromStringAsImpl Just Nothing\n\n-- | The `quot` function provides _truncating_ integer division (see the\n-- | documentation for the `EuclideanRing` class). It is identical to `div` in\n-- | the `EuclideanRing Int` instance if the dividend is positive, but will be\n-- | slightly different if the dividend is negative. For example:\n-- |\n-- | ```purescript\n-- | div 2 3 == 0\n-- | quot 2 3 == 0\n-- |\n-- | div (-2) 3 == (-1)\n-- | quot (-2) 3 == 0\n-- |\n-- | div 2 (-3) == 0\n-- | quot 2 (-3) == 0\n-- | ```\nforeign import quot :: Int -> Int -> Int\n\n-- | The `rem` function provides the remainder after _truncating_ integer\n-- | division (see the documentation for the `EuclideanRing` class). It is\n-- | identical to `mod` in the `EuclideanRing Int` instance if the dividend is\n-- | positive, but will be slightly different if the dividend is negative. For\n-- | example:\n-- |\n-- | ```purescript\n-- | mod 2 3 == 2\n-- | rem 2 3 == 2\n-- |\n-- | mod (-2) 3 == 1\n-- | rem (-2) 3 == (-2)\n-- |\n-- | mod 2 (-3) == 2\n-- | rem 2 (-3) == 2\n-- | ```\nforeign import rem :: Int -> Int -> Int\n\n-- | Raise an Int to the power of another Int.\nforeign import pow :: Int -> Int -> Int\n\nforeign import fromStringAsImpl\n  :: (forall a. a -> Maybe a)\n  -> (forall a. Maybe a)\n  -> Radix\n  -> String\n  -> Maybe Int\n\nforeign import toStringAs :: Radix -> Int -> String\n", "-- | This module defines a type of _strict_ linked lists, and associated helper\n-- | functions and type class instances.\n-- |\n-- | _Note_: Depending on your use-case, you may prefer to use\n-- | `Data.Sequence` instead, which might give better performance for certain\n-- | use cases. This module is an improvement over `Data.Array` when working with\n-- | immutable lists of data in a purely-functional setting, but does not have\n-- | good random-access performance.\n\nmodule Data.List\n  ( module Data.List.Types\n  , toUnfoldable\n  , fromFoldable\n\n  , singleton\n  , (..), range\n  , some\n  , someRec\n  , many\n  , manyRec\n\n  , null\n  , length\n\n  , snoc\n  , insert\n  , insertBy\n\n  , head\n  , last\n  , tail\n  , init\n  , uncons\n  , unsnoc\n\n  , (!!), index\n  , elemIndex\n  , elemLastIndex\n  , findIndex\n  , findLastIndex\n  , insertAt\n  , deleteAt\n  , updateAt\n  , modifyAt\n  , alterAt\n\n  , reverse\n  , concat\n  , concatMap\n  , filter\n  , filterM\n  , mapMaybe\n  , catMaybes\n\n  , sort\n  , sortBy\n\n  , Pattern(..)\n  , stripPrefix\n  , slice\n  , take\n  , takeEnd\n  , takeWhile\n  , drop\n  , dropEnd\n  , dropWhile\n  , span\n  , group\n  , groupAll\n  , groupBy\n  , groupAllBy\n  , partition\n\n  , nub\n  , nubBy\n  , nubEq\n  , nubByEq\n  , union\n  , unionBy\n  , delete\n  , deleteBy\n  , (\\\\), difference\n  , intersect\n  , intersectBy\n\n  , zipWith\n  , zipWithA\n  , zip\n  , unzip\n\n  , transpose\n\n  , foldM\n\n  , module Exports\n  ) where\n\nimport Prelude\n\nimport Control.Alt ((<|>))\nimport Control.Alternative (class Alternative)\nimport Control.Lazy (class Lazy, defer)\nimport Control.Monad.Rec.Class (class MonadRec, Step(..), tailRecM, tailRecM2)\nimport Data.Bifunctor (bimap)\nimport Data.Foldable (class Foldable, foldr, any, foldl)\nimport Data.Foldable (foldl, foldr, foldMap, fold, intercalate, elem, notElem, find, findMap, any, all) as Exports\nimport Data.List.Internal (emptySet, insertAndLookupBy)\nimport Data.List.Types (List(..), (:))\nimport Data.List.Types (NonEmptyList(..)) as NEL\nimport Data.Maybe (Maybe(..))\nimport Data.Newtype (class Newtype)\nimport Data.NonEmpty ((:|))\nimport Data.Traversable (scanl, scanr) as Exports\nimport Data.Traversable (sequence)\nimport Data.Tuple (Tuple(..))\nimport Data.Unfoldable (class Unfoldable, unfoldr)\n\n-- | Convert a list into any unfoldable structure.\n-- |\n-- | Running time: `O(n)`\ntoUnfoldable :: forall f. Unfoldable f => List ~> f\ntoUnfoldable = unfoldr (\\xs -> (\\rec -> Tuple rec.head rec.tail) <$> uncons xs)\n\n-- | Construct a list from a foldable structure.\n-- |\n-- | Running time: `O(n)`\nfromFoldable :: forall f. Foldable f => f ~> List\nfromFoldable = foldr Cons Nil\n\n--------------------------------------------------------------------------------\n-- List creation ---------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Create a list with a single element.\n-- |\n-- | Running time: `O(1)`\nsingleton :: forall a. a -> List a\nsingleton a = a : Nil\n\n-- | An infix synonym for `range`.\ninfix 8 range as ..\n\n-- | Create a list containing a range of integers, including both endpoints.\nrange :: Int -> Int -> List Int\nrange start end | start == end = singleton start\n                | otherwise = go end start (if start > end then 1 else -1) Nil\n  where\n  go s e step rest | s == e = s : rest\n                   | otherwise = go (s + step) e step (s : rest)\n\n-- | Attempt a computation multiple times, requiring at least one success.\n-- |\n-- | The `Lazy` constraint is used to generate the result lazily, to ensure\n-- | termination.\nsome :: forall f a. Alternative f => Lazy (f (List a)) => f a -> f (List a)\nsome v = Cons <$> v <*> defer (\\_ -> many v)\n\n-- | A stack-safe version of `some`, at the cost of a `MonadRec` constraint.\nsomeRec :: forall f a. MonadRec f => Alternative f => f a -> f (List a)\nsomeRec v = Cons <$> v <*> manyRec v\n\n-- | Attempt a computation multiple times, returning as many successful results\n-- | as possible (possibly zero).\n-- |\n-- | The `Lazy` constraint is used to generate the result lazily, to ensure\n-- | termination.\nmany :: forall f a. Alternative f => Lazy (f (List a)) => f a -> f (List a)\nmany v = some v <|> pure Nil\n\n-- | A stack-safe version of `many`, at the cost of a `MonadRec` constraint.\nmanyRec :: forall f a. MonadRec f => Alternative f => f a -> f (List a)\nmanyRec p = tailRecM go Nil\n  where\n  go :: List a -> f (Step (List a) (List a))\n  go acc = do\n    aa <- (Loop <$> p) <|> pure (Done unit)\n    pure $ bimap (_ : acc) (\\_ -> reverse acc) aa\n\n--------------------------------------------------------------------------------\n-- List size -------------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Test whether a list is empty.\n-- |\n-- | Running time: `O(1)`\nnull :: forall a. List a -> Boolean\nnull Nil = true\nnull _ = false\n\n-- | Get the length of a list\n-- |\n-- | Running time: `O(n)`\nlength :: forall a. List a -> Int\nlength = foldl (\\acc _ -> acc + 1) 0\n\n--------------------------------------------------------------------------------\n-- Extending lists -------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Append an element to the end of a list, creating a new list.\n-- |\n-- | Running time: `O(n)`\nsnoc :: forall a. List a -> a -> List a\nsnoc xs x = foldr (:) (x : Nil) xs\n\n-- | Insert an element into a sorted list.\n-- |\n-- | Running time: `O(n)`\ninsert :: forall a. Ord a => a -> List a -> List a\ninsert = insertBy compare\n\n-- | Insert an element into a sorted list, using the specified function to\n-- | determine the ordering of elements.\n-- |\n-- | Running time: `O(n)`\ninsertBy :: forall a. (a -> a -> Ordering) -> a -> List a -> List a\ninsertBy _ x Nil = singleton x\ninsertBy cmp x ys@(y : ys') =\n  case cmp x y of\n    GT -> y : (insertBy cmp x ys')\n    _  -> x : ys\n\n--------------------------------------------------------------------------------\n-- Non-indexed reads -----------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Get the first element in a list, or `Nothing` if the list is empty.\n-- |\n-- | Running time: `O(1)`.\nhead :: List ~> Maybe\nhead Nil = Nothing\nhead (x : _) = Just x\n\n-- | Get the last element in a list, or `Nothing` if the list is empty.\n-- |\n-- | Running time: `O(n)`.\nlast :: List ~> Maybe\nlast (x : Nil) = Just x\nlast (_ : xs)  = last xs\nlast _         = Nothing\n\n-- | Get all but the first element of a list, or `Nothing` if the list is empty.\n-- |\n-- | Running time: `O(1)`\ntail :: forall a. List a -> Maybe (List a)\ntail Nil = Nothing\ntail (_ : xs) = Just xs\n\n-- | Get all but the last element of a list, or `Nothing` if the list is empty.\n-- |\n-- | Running time: `O(n)`\ninit :: forall a. List a -> Maybe (List a)\ninit lst = _.init <$> unsnoc lst\n\n-- | Break a list into its first element, and the remaining elements,\n-- | or `Nothing` if the list is empty.\n-- |\n-- | Running time: `O(1)`\nuncons :: forall a. List a -> Maybe { head :: a, tail :: List a }\nuncons Nil = Nothing\nuncons (x : xs) = Just { head: x, tail: xs }\n\n-- | Break a list into its last element, and the preceding elements,\n-- | or `Nothing` if the list is empty.\n-- |\n-- | Running time: `O(n)`\nunsnoc :: forall a. List a -> Maybe { init :: List a, last :: a }\nunsnoc lst = (\\h -> { init: reverse h.revInit, last: h.last }) <$> go lst Nil\n  where\n  go Nil _ = Nothing\n  go (x : Nil) acc = Just { revInit: acc, last: x }\n  go (x : xs) acc = go xs (x : acc)\n\n--------------------------------------------------------------------------------\n-- Indexed operations ----------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Get the element at the specified index, or `Nothing` if the index is out-of-bounds.\n-- |\n-- | Running time: `O(n)` where `n` is the required index.\nindex :: forall a. List a -> Int -> Maybe a\nindex Nil _ = Nothing\nindex (a : _) 0 = Just a\nindex (_ : as) i = index as (i - 1)\n\n-- | An infix synonym for `index`.\ninfixl 8 index as !!\n\n-- | Find the index of the first element equal to the specified element.\nelemIndex :: forall a. Eq a => a -> List a -> Maybe Int\nelemIndex x = findIndex (_ == x)\n\n-- | Find the index of the last element equal to the specified element.\nelemLastIndex :: forall a. Eq a => a -> List a -> Maybe Int\nelemLastIndex x = findLastIndex (_ == x)\n\n-- | Find the first index for which a predicate holds.\nfindIndex :: forall a. (a -> Boolean) -> List a -> Maybe Int\nfindIndex fn = go 0\n  where\n  go :: Int -> List a -> Maybe Int\n  go n (x : xs) | fn x = Just n\n                | otherwise = go (n + 1) xs\n  go _ Nil = Nothing\n\n-- | Find the last index for which a predicate holds.\nfindLastIndex :: forall a. (a -> Boolean) -> List a -> Maybe Int\nfindLastIndex fn xs = ((length xs - 1) - _) <$> findIndex fn (reverse xs)\n\n-- | Insert an element into a list at the specified index, returning a new\n-- | list or `Nothing` if the index is out-of-bounds.\n-- |\n-- | Running time: `O(n)`\ninsertAt :: forall a. Int -> a -> List a -> Maybe (List a)\ninsertAt 0 x xs = Just (x : xs)\ninsertAt n x (y : ys) = (y : _) <$> insertAt (n - 1) x ys\ninsertAt _ _ _  = Nothing\n\n-- | Delete an element from a list at the specified index, returning a new\n-- | list or `Nothing` if the index is out-of-bounds.\n-- |\n-- | Running time: `O(n)`\ndeleteAt :: forall a. Int -> List a -> Maybe (List a)\ndeleteAt 0 (_ : ys) = Just ys\ndeleteAt n (y : ys) = (y : _) <$> deleteAt (n - 1) ys\ndeleteAt _ _  = Nothing\n\n-- | Update the element at the specified index, returning a new\n-- | list or `Nothing` if the index is out-of-bounds.\n-- |\n-- | Running time: `O(n)`\nupdateAt :: forall a. Int -> a -> List a -> Maybe (List a)\nupdateAt 0 x ( _ : xs) = Just (x : xs)\nupdateAt n x (x1 : xs) = (x1 : _) <$> updateAt (n - 1) x xs\nupdateAt _ _ _ = Nothing\n\n-- | Update the element at the specified index by applying a function to\n-- | the current value, returning a new list or `Nothing` if the index is\n-- | out-of-bounds.\n-- |\n-- | Running time: `O(n)`\nmodifyAt :: forall a. Int -> (a -> a) -> List a -> Maybe (List a)\nmodifyAt n f = alterAt n (Just <<< f)\n\n-- | Update or delete the element at the specified index by applying a\n-- | function to the current value, returning a new list or `Nothing` if the\n-- | index is out-of-bounds.\n-- |\n-- | Running time: `O(n)`\nalterAt :: forall a. Int -> (a -> Maybe a) -> List a -> Maybe (List a)\nalterAt 0 f (y : ys) = Just $\n  case f y of\n    Nothing -> ys\n    Just y' -> y' : ys\nalterAt n f (y : ys) = (y : _) <$> alterAt (n - 1) f ys\nalterAt _ _ _  = Nothing\n\n--------------------------------------------------------------------------------\n-- Transformations -------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Reverse a list.\n-- |\n-- | Running time: `O(n)`\nreverse :: List ~> List\nreverse = go Nil\n  where\n  go acc Nil = acc\n  go acc (x : xs) = go (x : acc) xs\n\n-- | Flatten a list of lists.\n-- |\n-- | Running time: `O(n)`, where `n` is the total number of elements.\nconcat :: forall a. List (List a) -> List a\nconcat = (_ >>= identity)\n\n-- | Apply a function to each element in a list, and flatten the results\n-- | into a single, new list.\n-- |\n-- | Running time: `O(n)`, where `n` is the total number of elements.\nconcatMap :: forall a b. (a -> List b) -> List a -> List b\nconcatMap = flip bind\n\n-- | Filter a list, keeping the elements which satisfy a predicate function.\n-- |\n-- | Running time: `O(n)`\nfilter :: forall a. (a -> Boolean) -> List a -> List a\nfilter p = go Nil\n  where\n  go acc Nil = reverse acc\n  go acc (x : xs)\n    | p x = go (x : acc) xs\n    | otherwise = go acc xs\n\n-- | Filter where the predicate returns a monadic `Boolean`.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | powerSet :: forall a. [a] -> [[a]]\n-- | powerSet = filterM (const [true, false])\n-- | ```\nfilterM :: forall a m. Monad m => (a -> m Boolean) -> List a -> m (List a)\nfilterM _ Nil = pure Nil\nfilterM p (x : xs) = do\n  b <- p x\n  xs' <- filterM p xs\n  pure if b then x : xs' else xs'\n\n-- | Apply a function to each element in a list, keeping only the results which\n-- | contain a value.\n-- |\n-- | Running time: `O(n)`\nmapMaybe :: forall a b. (a -> Maybe b) -> List a -> List b\nmapMaybe f = go Nil\n  where\n  go acc Nil = reverse acc\n  go acc (x : xs) =\n    case f x of\n      Nothing -> go acc xs\n      Just y -> go (y : acc) xs\n\n-- | Filter a list of optional values, keeping only the elements which contain\n-- | a value.\ncatMaybes :: forall a. List (Maybe a) -> List a\ncatMaybes = mapMaybe identity\n\n--------------------------------------------------------------------------------\n-- Sorting ---------------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Sort the elements of an list in increasing order.\nsort :: forall a. Ord a => List a -> List a\nsort xs = sortBy compare xs\n\n-- | Sort the elements of a list in increasing order, where elements are\n-- | compared using the specified ordering.\nsortBy :: forall a. (a -> a -> Ordering) -> List a -> List a\nsortBy cmp = mergeAll <<< sequences\n  -- implementation lifted from http://hackage.haskell.org/package/base-4.8.0.0/docs/src/Data-OldList.html#sort\n  where\n  sequences :: List a -> List (List a)\n  sequences (a : b : xs)\n    | a `cmp` b == GT = descending b (singleton a) xs\n    | otherwise = ascending b (a : _) xs\n  sequences xs = singleton xs\n\n  descending :: a -> List a -> List a -> List (List a)\n  descending a as (b : bs)\n    | a `cmp` b == GT = descending b (a : as) bs\n  descending a as bs = (a : as) : sequences bs\n\n  ascending :: a -> (List a -> List a) -> List a -> List (List a)\n  ascending a as (b : bs)\n    | a `cmp` b /= GT = ascending b (\\ys -> as (a : ys)) bs\n  ascending a as bs = ((as $ singleton a) : sequences bs)\n\n  mergeAll :: List (List a) -> List a\n  mergeAll (x : Nil) = x\n  mergeAll xs = mergeAll (mergePairs xs)\n\n  mergePairs :: List (List a) -> List (List a)\n  mergePairs (a : b : xs) = merge a b : mergePairs xs\n  mergePairs xs = xs\n\n  merge :: List a -> List a -> List a\n  merge as@(a : as') bs@(b : bs')\n    | a `cmp` b == GT = b : merge as bs'\n    | otherwise       = a : merge as' bs\n  merge Nil bs = bs\n  merge as Nil = as\n\n--------------------------------------------------------------------------------\n-- Sublists --------------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | A newtype used in cases where there is a list to be matched.\nnewtype Pattern a = Pattern (List a)\n\nderive instance eqPattern :: Eq a => Eq (Pattern a)\nderive instance ordPattern :: Ord a => Ord (Pattern a)\nderive instance newtypePattern :: Newtype (Pattern a) _\n\ninstance showPattern :: Show a => Show (Pattern a) where\n  show (Pattern s) = \"(Pattern \" <> show s <> \")\"\n\n\n-- | If the list starts with the given prefix, return the portion of the\n-- | list left after removing it, as a Just value. Otherwise, return Nothing.\n-- | * `stripPrefix (Pattern (1:Nil)) (1:2:Nil) == Just (2:Nil)`\n-- | * `stripPrefix (Pattern Nil) (1:Nil) == Just (1:Nil)`\n-- | * `stripPrefix (Pattern (2:Nil)) (1:Nil) == Nothing`\n-- |\n-- | Running time: `O(n)` where `n` is the number of elements to strip.\nstripPrefix :: forall a. Eq a => Pattern a -> List a -> Maybe (List a)\nstripPrefix (Pattern p') s = tailRecM2 go p' s\n  where\n  go prefix input = case prefix, input of\n    Cons p ps, Cons i is | p == i -> Just $ Loop { a: ps, b: is }\n    Nil, is -> Just $ Done is\n    _, _ -> Nothing\n\n-- | Extract a sublist by a start and end index.\nslice :: Int -> Int -> List ~> List\nslice start end xs = take (end - start) (drop start xs)\n\n-- | Take the specified number of elements from the front of a list.\n-- |\n-- | Running time: `O(n)` where `n` is the number of elements to take.\ntake :: forall a. Int -> List a -> List a\ntake = go Nil\n  where\n  go acc n _ | n < 1 = reverse acc\n  go acc _ Nil = reverse acc\n  go acc n (x : xs) = go (x : acc) (n - 1) xs\n\n-- | Take the specified number of elements from the end of a list.\n-- |\n-- | Running time: `O(2n - m)` where `n` is the number of elements in list\n-- | and `m` is number of elements to take.\ntakeEnd :: forall a. Int -> List a -> List a\ntakeEnd n xs = drop (length xs - n) xs\n\n-- | Take those elements from the front of a list which match a predicate.\n-- |\n-- | Running time (worst case): `O(n)`\ntakeWhile :: forall a. (a -> Boolean) -> List a -> List a\ntakeWhile p = go Nil\n  where\n  go acc (x : xs) | p x = go (x : acc) xs\n  go acc _ = reverse acc\n\n-- | Drop the specified number of elements from the front of a list.\n-- |\n-- | Running time: `O(n)` where `n` is the number of elements to drop.\ndrop :: forall a. Int -> List a -> List a\ndrop n xs | n < 1 = xs\ndrop _ Nil = Nil\ndrop n (_ : xs) = drop (n - 1) xs\n\n-- | Drop the specified number of elements from the end of a list.\n-- |\n-- | Running time: `O(2n - m)` where `n` is the number of elements in list\n-- | and `m` is number of elements to drop.\ndropEnd :: forall a. Int -> List a -> List a\ndropEnd n xs = take (length xs - n) xs\n\n-- | Drop those elements from the front of a list which match a predicate.\n-- |\n-- | Running time (worst case): `O(n)`\ndropWhile :: forall a. (a -> Boolean) -> List a -> List a\ndropWhile p = go\n  where\n  go (x : xs) | p x = go xs\n  go xs = xs\n\n-- | Split a list into two parts:\n-- |\n-- | 1. the longest initial segment for which all elements satisfy the specified predicate\n-- | 2. the remaining elements\n-- |\n-- | For example,\n-- |\n-- | ```purescript\n-- | span (\\n -> n % 2 == 1) (1 : 3 : 2 : 4 : 5 : Nil) == { init: (1 : 3 : Nil), rest: (2 : 4 : 5 : Nil) }\n-- | ```\n-- |\n-- | Running time: `O(n)`\nspan :: forall a. (a -> Boolean) -> List a -> { init :: List a, rest :: List a }\nspan p (x : xs') | p x = case span p xs' of\n  { init: ys, rest: zs } -> { init: x : ys, rest: zs }\nspan _ xs = { init: Nil, rest: xs }\n\n-- | Group equal, consecutive elements of a list into lists.\n-- |\n-- | For example,\n-- |\n-- | ```purescript\n-- | group (1 : 1 : 2 : 2 : 1 : Nil) ==\n-- |   (NonEmptyList (NonEmpty 1 (1 : Nil))) : (NonEmptyList (NonEmpty 2 (2 : Nil))) : (NonEmptyList (NonEmpty 1 Nil)) : Nil\n-- | ```\n-- |\n-- | Running time: `O(n)`\ngroup :: forall a. Eq a => List a -> List (NEL.NonEmptyList a)\ngroup = groupBy (==)\n\n-- | Group equal elements of a list into lists.\n-- |\n-- | For example,\n-- |\n-- | ```purescript\n-- | groupAll (1 : 1 : 2 : 2 : 1 : Nil) ==\n-- |   (NonEmptyList (NonEmpty 1 (1 : 1 : Nil))) : (NonEmptyList (NonEmpty 2 (2 : Nil))) : Nil\n-- | ```\ngroupAll :: forall a. Ord a => List a -> List (NEL.NonEmptyList a)\ngroupAll = group <<< sort\n\n-- | Group equal, consecutive elements of a list into lists, using the specified\n-- | equivalence relation to determine equality.\n-- |\n-- | For example,\n-- |\n-- | ```purescript\n-- | groupBy (\\a b -> odd a && odd b) (1 : 3 : 2 : 4 : 3 : 3 : Nil) ==\n-- |   (NonEmptyList (NonEmpty 1 (3 : Nil))) : (NonEmptyList (NonEmpty 2 Nil)) : (NonEmptyList (NonEmpty 4 Nil)) : (NonEmptyList (NonEmpty 3 (3 : Nil))) : Nil\n-- | ```\n-- |\n-- | Running time: `O(n)`\ngroupBy :: forall a. (a -> a -> Boolean) -> List a -> List (NEL.NonEmptyList a)\ngroupBy _ Nil = Nil\ngroupBy eq (x : xs) = case span (eq x) xs of\n  { init: ys, rest: zs } -> NEL.NonEmptyList (x :| ys) : groupBy eq zs\n\n-- | Sort, then group equal elements of a list into lists, using the provided comparison function.\n-- |\n-- | ```purescript\n-- | groupAllBy (compare `on` (_ `div` 10)) (32 : 31 : 21 : 22 : 11 : 33 : Nil) ==\n-- |   NonEmptyList (11 :| Nil) : NonEmptyList (21 :| 22 : Nil) : NonEmptyList (32 :| 31 : 33) : Nil\n-- | ```\n-- |\n-- | Running time: `O(n log n)`\ngroupAllBy :: forall a. (a -> a -> Ordering) -> List a -> List (NEL.NonEmptyList a)\ngroupAllBy p = groupBy (\\x y -> p x y == EQ) <<< sortBy p\n\n-- | Returns a lists of elements which do and do not satisfy a predicate.\n-- |\n-- | Running time: `O(n)`\npartition :: forall a. (a -> Boolean) -> List a -> { yes :: List a, no :: List a }\npartition p xs = foldr select { no: Nil, yes: Nil } xs\n  where\n    select x { no, yes } = if p x\n                           then { no, yes: x : yes }\n                           else { no: x : no, yes }\n\n-- | Returns all final segments of the argument, longest first. For example,\n-- |\n-- | ```purescript\n-- | tails (1 : 2 : 3 : Nil) == ((1 : 2 : 3 : Nil) : (2 : 3 : Nil) : (3 : Nil) : (Nil) : Nil)\n-- | ```\n-- | Running time: `O(n)`\ntails :: forall a. List a -> List (List a)\ntails Nil = singleton Nil\ntails list@(Cons _ tl)= list : tails tl\n\n--------------------------------------------------------------------------------\n-- Set-like operations ---------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Remove duplicate elements from a list.\n-- | Keeps the first occurrence of each element in the input list,\n-- | in the same order they appear in the input list.\n-- |\n-- | ```purescript\n-- | nub 1:2:1:3:3:Nil == 1:2:3:Nil\n-- | ```\n-- |\n-- | Running time: `O(n log n)`\nnub :: forall a. Ord a => List a -> List a\nnub = nubBy compare\n\n-- | Remove duplicate elements from a list based on the provided comparison function.\n-- | Keeps the first occurrence of each element in the input list,\n-- | in the same order they appear in the input list.\n-- |\n-- | ```purescript\n-- | nubBy (compare `on` Array.length) ([1]:[2]:[3,4]:Nil) == [1]:[3,4]:Nil\n-- | ```\n-- |\n-- | Running time: `O(n log n)`\nnubBy :: forall a. (a -> a -> Ordering) -> List a -> List a\nnubBy p = reverse <<< go emptySet Nil\n  where\n    go _ acc Nil = acc\n    go s acc (a : as) =\n      let { found, result: s' } = insertAndLookupBy p a s\n      in if found\n        then go s' acc as\n        else go s' (a : acc) as\n\n-- | Remove duplicate elements from a list.\n-- | Keeps the first occurrence of each element in the input list,\n-- | in the same order they appear in the input list.\n-- | This less efficient version of `nub` only requires an `Eq` instance.\n-- |\n-- | ```purescript\n-- | nubEq 1:2:1:3:3:Nil == 1:2:3:Nil\n-- | ```\n-- |\n-- | Running time: `O(n^2)`\nnubEq :: forall a. Eq a => List a -> List a\nnubEq = nubByEq eq\n\n-- | Remove duplicate elements from a list, using the provided equivalence function.\n-- | Keeps the first occurrence of each element in the input list,\n-- | in the same order they appear in the input list.\n-- | This less efficient version of `nubBy` only requires an equivalence\n-- | function, rather than an ordering function.\n-- |\n-- | ```purescript\n-- | mod3eq = eq `on` \\n -> mod n 3\n-- | nubByEq mod3eq 1:3:4:5:6:Nil == 1:3:5:Nil\n-- | ```\n-- |\n-- | Running time: `O(n^2)`\nnubByEq :: forall a. (a -> a -> Boolean) -> List a -> List a\nnubByEq _     Nil = Nil\nnubByEq eq' (x : xs) = x : nubByEq eq' (filter (\\y -> not (eq' x y)) xs)\n\n-- | Calculate the union of two lists.\n-- |\n-- | Running time: `O(n^2)`\nunion :: forall a. Eq a => List a -> List a -> List a\nunion = unionBy (==)\n\n-- | Calculate the union of two lists, using the specified\n-- | function to determine equality of elements.\n-- |\n-- | Running time: `O(n^2)`\nunionBy :: forall a. (a -> a -> Boolean) -> List a -> List a -> List a\nunionBy eq xs ys = xs <> foldl (flip (deleteBy eq)) (nubByEq eq ys) xs\n\n-- | Delete the first occurrence of an element from a list.\n-- |\n-- | Running time: `O(n)`\ndelete :: forall a. Eq a => a -> List a -> List a\ndelete = deleteBy (==)\n\n-- | Delete the first occurrence of an element from a list, using the specified\n-- | function to determine equality of elements.\n-- |\n-- | Running time: `O(n)`\ndeleteBy :: forall a. (a -> a -> Boolean) -> a -> List a -> List a\ndeleteBy _ _ Nil = Nil\ndeleteBy eq' x (y : ys) | eq' x y = ys\ndeleteBy eq' x (y : ys) = y : deleteBy eq' x ys\n\ninfix 5 difference as \\\\\n\n-- | Delete the first occurrence of each element in the second list from the first list.\n-- |\n-- | Running time: `O(n^2)`\ndifference :: forall a. Eq a => List a -> List a -> List a\ndifference = foldl (flip delete)\n\n-- | Calculate the intersection of two lists.\n-- |\n-- | Running time: `O(n^2)`\nintersect :: forall a. Eq a => List a -> List a -> List a\nintersect = intersectBy (==)\n\n-- | Calculate the intersection of two lists, using the specified\n-- | function to determine equality of elements.\n-- |\n-- | Running time: `O(n^2)`\nintersectBy :: forall a. (a -> a -> Boolean) -> List a -> List a -> List a\nintersectBy _  Nil _   = Nil\nintersectBy _  _   Nil = Nil\nintersectBy eq xs  ys  = filter (\\x -> any (eq x) ys) xs\n\n--------------------------------------------------------------------------------\n-- Zipping ---------------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Apply a function to pairs of elements at the same positions in two lists,\n-- | collecting the results in a new list.\n-- |\n-- | If one list is longer, elements will be discarded from the longer list.\n-- |\n-- | For example\n-- |\n-- | ```purescript\n-- | zipWith (*) (1 : 2 : 3 : Nil) (4 : 5 : 6 : 7 Nil) == 4 : 10 : 18 : Nil\n-- | ```\n-- |\n-- | Running time: `O(min(m, n))`\nzipWith :: forall a b c. (a -> b -> c) -> List a -> List b -> List c\nzipWith f xs ys = reverse $ go xs ys Nil\n  where\n  go Nil _ acc = acc\n  go _ Nil acc = acc\n  go (a : as) (b : bs) acc = go as bs $ f a b : acc\n\n-- | A generalization of `zipWith` which accumulates results in some `Applicative`\n-- | functor.\nzipWithA :: forall m a b c. Applicative m => (a -> b -> m c) -> List a -> List b -> m (List c)\nzipWithA f xs ys = sequence (zipWith f xs ys)\n\n-- | Collect pairs of elements at the same positions in two lists.\n-- |\n-- | Running time: `O(min(m, n))`\nzip :: forall a b. List a -> List b -> List (Tuple a b)\nzip = zipWith Tuple\n\n-- | Transforms a list of pairs into a list of first components and a list of\n-- | second components.\nunzip :: forall a b. List (Tuple a b) -> Tuple (List a) (List b)\nunzip = foldr (\\(Tuple a b) (Tuple as bs) -> Tuple (a : as) (b : bs)) (Tuple Nil Nil)\n\n--------------------------------------------------------------------------------\n-- Transpose -------------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | The 'transpose' function transposes the rows and columns of its argument.\n-- | For example,\n-- |\n-- |     transpose ((1:2:3:Nil) : (4:5:6:Nil) : Nil) ==\n-- |       ((1:4:Nil) : (2:5:Nil) : (3:6:Nil) : Nil)\n-- |\n-- | If some of the rows are shorter than the following rows, their elements are skipped:\n-- |\n-- |     transpose ((10:11:Nil) : (20:Nil) : Nil : (30:31:32:Nil) : Nil) ==\n-- |       ((10:20:30:Nil) : (11:31:Nil) : (32:Nil) : Nil)\ntranspose :: forall a. List (List a) -> List (List a)\ntranspose Nil = Nil\ntranspose (Nil : xss) = transpose xss\ntranspose ((x : xs) : xss) =\n  (x : mapMaybe head xss) : transpose (xs : mapMaybe tail xss)\n\n--------------------------------------------------------------------------------\n-- Folding ---------------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Perform a fold using a monadic step function.\nfoldM :: forall m a b. Monad m => (b -> a -> m b) -> b -> List a -> m b\nfoldM _ b Nil = pure b\nfoldM f b (a : as) = f b a >>= \\b' -> foldM f b' as\n", "module Data.List.NonEmpty\n  ( module Data.List.Types\n  , toUnfoldable\n  , fromFoldable\n  , fromList\n  , toList\n  , singleton\n  , length\n  , cons\n  , cons'\n  , snoc\n  , snoc'\n  , head\n  , last\n  , tail\n  , init\n  , uncons\n  , unsnoc\n  , (!!), index\n  , elemIndex\n  , elemLastIndex\n  , findIndex\n  , findLastIndex\n  , insertAt\n  , updateAt\n  , modifyAt\n  , reverse\n  , concat\n  , concatMap\n  , filter\n  , filterM\n  , mapMaybe\n  , catMaybes\n  , appendFoldable\n  , sort\n  , sortBy\n  , take\n  , takeWhile\n  , drop\n  , dropWhile\n  , span\n  , group\n  , groupAll\n  , groupBy\n  , groupAllBy\n  , partition\n  , nub\n  , nubBy\n  , nubEq\n  , nubByEq\n  , union\n  , unionBy\n  , intersect\n  , intersectBy\n  , zipWith\n  , zipWithA\n  , zip\n  , unzip\n  , foldM\n  , module Exports\n  ) where\n\nimport Prelude\n\nimport Data.Foldable (class Foldable)\nimport Data.List ((:))\nimport Data.List as L\nimport Data.List.Types (NonEmptyList(..))\nimport Data.Maybe (Maybe(..), fromMaybe, maybe)\nimport Data.NonEmpty ((:|))\nimport Data.NonEmpty as NE\nimport Data.Semigroup.Traversable (sequence1)\nimport Data.Tuple (Tuple(..), fst, snd)\nimport Data.Unfoldable (class Unfoldable, unfoldr)\nimport Partial.Unsafe (unsafeCrashWith)\n\nimport Data.Foldable (foldl, foldr, foldMap, fold, intercalate, elem, notElem, find, findMap, any, all) as Exports\nimport Data.Semigroup.Foldable (fold1, foldMap1, for1_, sequence1_, traverse1_) as Exports\nimport Data.Semigroup.Traversable (sequence1, traverse1, traverse1Default) as Exports\nimport Data.Traversable (scanl, scanr) as Exports\n\n-- | Internal function: any operation on a list that is guaranteed not to delete\n-- | all elements also applies to a NEL, this function is a helper for defining\n-- | those cases.\nwrappedOperation\n  :: forall a b\n   . String\n  -> (L.List a -> L.List b)\n  -> NonEmptyList a\n  -> NonEmptyList b\nwrappedOperation name f (NonEmptyList (x :| xs)) =\n  case f (x : xs) of\n    x' : xs' -> NonEmptyList (x' :| xs')\n    L.Nil -> unsafeCrashWith (\"Impossible: empty list in NonEmptyList \" <> name)\n\n-- | Like `wrappedOperation`, but for functions that operate on 2 lists.\nwrappedOperation2\n  :: forall a b c\n   . String\n  -> (L.List a -> L.List b -> L.List c)\n  -> NonEmptyList a\n  -> NonEmptyList b\n  -> NonEmptyList c\nwrappedOperation2 name f (NonEmptyList (x :| xs)) (NonEmptyList (y :| ys)) =\n  case f (x : xs) (y : ys) of\n    x' : xs' -> NonEmptyList (x' :| xs')\n    L.Nil -> unsafeCrashWith (\"Impossible: empty list in NonEmptyList \" <> name)\n\n-- | Lifts a function that operates on a list to work on a NEL. This does not\n-- | preserve the non-empty status of the result.\nlift :: forall a b. (L.List a -> b) -> NonEmptyList a -> b\nlift f (NonEmptyList (x :| xs)) = f (x : xs)\n\ntoUnfoldable :: forall f. Unfoldable f => NonEmptyList ~> f\ntoUnfoldable =\n  unfoldr (\\xs -> (\\rec -> Tuple rec.head rec.tail) <$> L.uncons xs) <<< toList\n\nfromFoldable :: forall f a. Foldable f => f a -> Maybe (NonEmptyList a)\nfromFoldable = fromList <<< L.fromFoldable\n\nfromList :: forall a. L.List a -> Maybe (NonEmptyList a)\nfromList L.Nil = Nothing\nfromList (x : xs) = Just (NonEmptyList (x :| xs))\n\ntoList :: NonEmptyList ~> L.List\ntoList (NonEmptyList (x :| xs)) = x : xs\n\nsingleton :: forall a. a -> NonEmptyList a\nsingleton = NonEmptyList <<< NE.singleton\n\ncons :: forall a. a -> NonEmptyList a -> NonEmptyList a\ncons y (NonEmptyList (x :| xs)) = NonEmptyList (y :| x : xs)\n\ncons' :: forall a. a -> L.List a -> NonEmptyList a\ncons' x xs = NonEmptyList (x :| xs)\n\nsnoc :: forall a. NonEmptyList a -> a -> NonEmptyList a\nsnoc (NonEmptyList (x :| xs)) y = NonEmptyList (x :| L.snoc xs y)\n\nsnoc' :: forall a. L.List a -> a -> NonEmptyList a\nsnoc' (x : xs) y = NonEmptyList (x :| L.snoc xs y)\nsnoc' L.Nil y = singleton y\n\nhead :: forall a. NonEmptyList a -> a\nhead (NonEmptyList (x :| _)) = x\n\nlast :: forall a. NonEmptyList a -> a\nlast (NonEmptyList (x :| xs)) = fromMaybe x (L.last xs)\n\ntail :: NonEmptyList ~> L.List\ntail (NonEmptyList (_ :| xs)) = xs\n\ninit :: NonEmptyList ~> L.List\ninit (NonEmptyList (x :| xs)) = maybe L.Nil (x : _) (L.init xs)\n\nuncons :: forall a. NonEmptyList a -> { head :: a, tail :: L.List a }\nuncons (NonEmptyList (x :| xs)) = { head: x, tail: xs }\n\nunsnoc :: forall a. NonEmptyList a -> { init :: L.List a, last :: a }\nunsnoc (NonEmptyList (x :| xs)) = case L.unsnoc xs of\n  Nothing -> { init: L.Nil, last: x }\n  Just un -> { init: x : un.init, last: un.last }\n\nlength :: forall a. NonEmptyList a -> Int\nlength (NonEmptyList (_ :| xs)) = 1 + L.length xs\n\nindex :: forall a. NonEmptyList a -> Int -> Maybe a\nindex (NonEmptyList (x :| xs)) i\n  | i == 0 = Just x\n  | otherwise = L.index xs (i - 1)\n\ninfixl 8 index as !!\n\nelemIndex :: forall a. Eq a => a -> NonEmptyList a -> Maybe Int\nelemIndex x = findIndex (_ == x)\n\nelemLastIndex :: forall a. Eq a => a -> NonEmptyList a -> Maybe Int\nelemLastIndex x = findLastIndex (_ == x)\n\nfindIndex :: forall a. (a -> Boolean) -> NonEmptyList a -> Maybe Int\nfindIndex f (NonEmptyList (x :| xs))\n  | f x = Just 0\n  | otherwise = (_ + 1) <$> L.findIndex f xs\n\nfindLastIndex :: forall a. (a -> Boolean) -> NonEmptyList a -> Maybe Int\nfindLastIndex f (NonEmptyList (x :| xs)) =\n  case L.findLastIndex f xs of\n    Just i -> Just (i + 1)\n    Nothing\n      | f x -> Just 0\n      | otherwise -> Nothing\n\ninsertAt :: forall a. Int -> a -> NonEmptyList a -> Maybe (NonEmptyList a)\ninsertAt i a (NonEmptyList (x :| xs))\n  | i == 0 = Just (NonEmptyList (a :| x : xs))\n  | otherwise = NonEmptyList <<< (x :| _) <$> L.insertAt (i - 1) a xs\n\nupdateAt :: forall a. Int -> a -> NonEmptyList a -> Maybe (NonEmptyList a)\nupdateAt i a (NonEmptyList (x :| xs))\n  | i == 0 = Just (NonEmptyList (a :| xs))\n  | otherwise = NonEmptyList <<< (x :| _) <$> L.updateAt (i - 1) a xs\n\nmodifyAt :: forall a. Int -> (a -> a) -> NonEmptyList a -> Maybe (NonEmptyList a)\nmodifyAt i f (NonEmptyList (x :| xs))\n  | i == 0 = Just (NonEmptyList (f x :| xs))\n  | otherwise = NonEmptyList <<< (x :| _) <$> L.modifyAt (i - 1) f xs\n\nreverse :: forall a. NonEmptyList a -> NonEmptyList a\nreverse = wrappedOperation \"reverse\" L.reverse\n\nfilter :: forall a. (a -> Boolean) -> NonEmptyList a -> L.List a\nfilter = lift <<< L.filter\n\nfilterM :: forall m a. Monad m => (a -> m Boolean) -> NonEmptyList a -> m (L.List a)\nfilterM = lift <<< L.filterM\n\nmapMaybe :: forall a b. (a -> Maybe b) -> NonEmptyList a -> L.List b\nmapMaybe = lift <<< L.mapMaybe\n\ncatMaybes :: forall a. NonEmptyList (Maybe a) -> L.List a\ncatMaybes = lift L.catMaybes\n\nconcat :: forall a. NonEmptyList (NonEmptyList a) -> NonEmptyList a\nconcat = (_ >>= identity)\n\nconcatMap :: forall a b. (a -> NonEmptyList b) -> NonEmptyList a -> NonEmptyList b\nconcatMap = flip bind\n\nappendFoldable :: forall t a. Foldable t => NonEmptyList a -> t a -> NonEmptyList a\nappendFoldable (NonEmptyList (x :| xs)) ys =\n  NonEmptyList (x :| (xs <> L.fromFoldable ys))\n\nsort :: forall a. Ord a => NonEmptyList a -> NonEmptyList a\nsort xs = sortBy compare xs\n\nsortBy :: forall a. (a -> a -> Ordering) -> NonEmptyList a -> NonEmptyList a\nsortBy = wrappedOperation \"sortBy\" <<< L.sortBy\n\ntake :: forall a. Int -> NonEmptyList a -> L.List a\ntake = lift <<< L.take\n\ntakeWhile :: forall a. (a -> Boolean) -> NonEmptyList a -> L.List a\ntakeWhile = lift <<< L.takeWhile\n\ndrop :: forall a. Int -> NonEmptyList a -> L.List a\ndrop = lift <<< L.drop\n\ndropWhile :: forall a. (a -> Boolean) -> NonEmptyList a -> L.List a\ndropWhile = lift <<< L.dropWhile\n\nspan :: forall a. (a -> Boolean) -> NonEmptyList a -> { init :: L.List a, rest :: L.List a }\nspan = lift <<< L.span\n\ngroup :: forall a. Eq a => NonEmptyList a -> NonEmptyList (NonEmptyList a)\ngroup = wrappedOperation \"group\" L.group\n\ngroupAll :: forall a. Ord a => NonEmptyList a -> NonEmptyList (NonEmptyList a)\ngroupAll = wrappedOperation \"groupAll\" L.groupAll\n\ngroupBy :: forall a. (a -> a -> Boolean) -> NonEmptyList a -> NonEmptyList (NonEmptyList a)\ngroupBy = wrappedOperation \"groupBy\" <<< L.groupBy\n\ngroupAllBy :: forall a. (a -> a -> Ordering) -> NonEmptyList a -> NonEmptyList (NonEmptyList a)\ngroupAllBy = wrappedOperation \"groupAllBy\" <<< L.groupAllBy\n\npartition :: forall a. (a -> Boolean) -> NonEmptyList a -> { yes :: L.List a, no :: L.List a }\npartition = lift <<< L.partition\n\nnub :: forall a. Ord a => NonEmptyList a -> NonEmptyList a\nnub = wrappedOperation \"nub\" L.nub\n\nnubBy :: forall a. (a -> a -> Ordering) -> NonEmptyList a -> NonEmptyList a\nnubBy = wrappedOperation \"nubBy\" <<< L.nubBy\n\nnubEq :: forall a. Eq a => NonEmptyList a -> NonEmptyList a\nnubEq = wrappedOperation \"nubEq\" L.nubEq\n\nnubByEq :: forall a. (a -> a -> Boolean) -> NonEmptyList a -> NonEmptyList a\nnubByEq = wrappedOperation \"nubByEq\" <<< L.nubByEq\n\nunion :: forall a. Eq a => NonEmptyList a -> NonEmptyList a -> NonEmptyList a\nunion = wrappedOperation2 \"union\" L.union\n\nunionBy :: forall a. (a -> a -> Boolean) -> NonEmptyList a -> NonEmptyList a -> NonEmptyList a\nunionBy = wrappedOperation2 \"unionBy\" <<< L.unionBy\n\nintersect :: forall a. Eq a => NonEmptyList a -> NonEmptyList a -> NonEmptyList a\nintersect = wrappedOperation2 \"intersect\" L.intersect\n\nintersectBy :: forall a. (a -> a -> Boolean) -> NonEmptyList a -> NonEmptyList a -> NonEmptyList a\nintersectBy = wrappedOperation2 \"intersectBy\" <<< L.intersectBy\n\nzipWith :: forall a b c. (a -> b -> c) -> NonEmptyList a -> NonEmptyList b -> NonEmptyList c\nzipWith f (NonEmptyList (x :| xs)) (NonEmptyList (y :| ys)) =\n  NonEmptyList (f x y :| L.zipWith f xs ys)\n\nzipWithA :: forall m a b c. Applicative m => (a -> b -> m c) -> NonEmptyList a -> NonEmptyList b -> m (NonEmptyList c)\nzipWithA f xs ys = sequence1 (zipWith f xs ys)\n\nzip :: forall a b. NonEmptyList a -> NonEmptyList b -> NonEmptyList (Tuple a b)\nzip = zipWith Tuple\n\nunzip :: forall a b. NonEmptyList (Tuple a b) -> Tuple (NonEmptyList a) (NonEmptyList b)\nunzip ts = Tuple (map fst ts) (map snd ts)\n\nfoldM :: forall m a b. Monad m => (b -> a -> m b) -> b -> NonEmptyList a -> m b\nfoldM f b (NonEmptyList (a :| as)) = f b a >>= \\b' -> L.foldM f b' as\n", "module Control.Promise (fromAff, toAff, toAff', toAffE, Promise()) where\n\nimport Prelude\n\nimport Control.Alt ((<|>))\nimport Control.Monad.Except (runExcept)\nimport Data.Either (Either(..), either)\nimport Effect (Effect)\nimport Effect.Aff (Aff, makeAff, runAff_)\nimport Effect.Class (liftEffect)\nimport Effect.Exception (Error, error)\nimport Effect.Uncurried (EffectFn1, mkEffectFn1)\nimport Foreign (Foreign, readString, unsafeReadTagged)\n\n-- | Type of JavaScript Promises (with particular return type)\n-- | Effects are not traced in the Promise type, as they form part of the Effect that\n-- | results in the promise.\nforeign import data Promise :: Type -> Type\n\ntype role Promise representational\n\nforeign import promise :: forall a b.\n  ((a -> Effect Unit) -> (b -> Effect Unit) -> Effect Unit) -> Effect (Promise a)\nforeign import thenImpl :: forall a b.\n  Promise a -> (EffectFn1 Foreign b) -> (EffectFn1 a b) -> Effect Unit\n\n-- | Convert an Aff into a Promise.\nfromAff :: forall a. Aff a -> Effect (Promise a)\nfromAff aff = promise (\\succ err -> runAff_ (either err succ) aff)\n\ncoerce :: Foreign -> Error\ncoerce fn =\n  either (\\_ -> error \"Promise failed, couldn't extract JS Error or String\")\n         identity\n         (runExcept ((unsafeReadTagged \"Error\" fn) <|> (error <$> readString fn)))\n\n-- | Convert a Promise into an Aff.\n-- | When the promise rejects, we attempt to\n-- | coerce the error value into an actual JavaScript Error object. We can do this\n-- | with Error objects or Strings. Anything else gets a \"dummy\" Error object.\ntoAff :: forall a. Promise a -> Aff a\ntoAff = toAff' coerce\n\n-- | Convert a Promise into an Aff with custom Error coercion.\n-- | When the promise rejects, we attempt to coerce the error value into an\n-- | actual JavaScript Error object using the provided function.\ntoAff' :: forall a. (Foreign -> Error) -> Promise a -> Aff a\ntoAff' customCoerce p = makeAff\n  (\\cb -> mempty <$ thenImpl\n    p\n    (mkEffectFn1 $ cb <<< Left <<< customCoerce)\n    (mkEffectFn1 $ cb <<< Right))\n\n-- | Utility to convert an Effect returning a Promise into an Aff (i.e. the inverse of fromAff)\ntoAffE :: forall a. Effect (Promise a) -> Aff a\ntoAffE f = liftEffect f >>= toAff\n", "//------------------------------------------------------------------------------\n// Array creation --------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexport const rangeImpl = function (start, end) {\n  var step = start > end ? -1 : 1;\n  var result = new Array(step * (end - start) + 1);\n  var i = start, n = 0;\n  while (i !== end) {\n    result[n++] = i;\n    i += step;\n  }\n  result[n] = i;\n  return result;\n};\n\nvar replicateFill = function (count, value) {\n  if (count < 1) {\n    return [];\n  }\n  var result = new Array(count);\n  return result.fill(value);\n};\n\nvar replicatePolyfill = function (count, value) {\n  var result = [];\n  var n = 0;\n  for (var i = 0; i < count; i++) {\n    result[n++] = value;\n  }\n  return result;\n};\n\n// In browsers that have Array.prototype.fill we use it, as it's faster.\nexport const replicateImpl = typeof Array.prototype.fill === \"function\" ? replicateFill : replicatePolyfill;\n\nexport const fromFoldableImpl = (function () {\n  function Cons(head, tail) {\n    this.head = head;\n    this.tail = tail;\n  }\n  var emptyList = {};\n\n  function curryCons(head) {\n    return function (tail) {\n      return new Cons(head, tail);\n    };\n  }\n\n  function listToArray(list) {\n    var result = [];\n    var count = 0;\n    var xs = list;\n    while (xs !== emptyList) {\n      result[count++] = xs.head;\n      xs = xs.tail;\n    }\n    return result;\n  }\n\n  return function (foldr, xs) {\n    return listToArray(foldr(curryCons)(emptyList)(xs));\n  };\n})();\n\n//------------------------------------------------------------------------------\n// Array size ------------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexport const length = function (xs) {\n  return xs.length;\n};\n\n//------------------------------------------------------------------------------\n// Non-indexed reads -----------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexport const unconsImpl = function (empty, next, xs) {\n  return xs.length === 0 ? empty({}) : next(xs[0])(xs.slice(1));\n};\n\n//------------------------------------------------------------------------------\n// Indexed operations ----------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexport const indexImpl = function (just, nothing, xs, i) {\n  return i < 0 || i >= xs.length ? nothing :  just(xs[i]);\n};\n\nexport const findMapImpl = function (nothing, isJust, f, xs) {\n  for (var i = 0; i < xs.length; i++) {\n    var result = f(xs[i]);\n    if (isJust(result)) return result;\n  }\n  return nothing;\n};\n\nexport const findIndexImpl = function (just, nothing, f, xs) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (f(xs[i])) return just(i);\n  }\n  return nothing;\n};\n\nexport const findLastIndexImpl = function (just, nothing, f, xs) {\n  for (var i = xs.length - 1; i >= 0; i--) {\n    if (f(xs[i])) return just(i);\n  }\n  return nothing;\n};\n\nexport const _insertAt = function (just, nothing, i, a, l) {\n  if (i < 0 || i > l.length) return nothing;\n  var l1 = l.slice();\n  l1.splice(i, 0, a);\n  return just(l1);\n};\n\nexport const _deleteAt = function (just, nothing, i, l) {\n  if (i < 0 || i >= l.length) return nothing;\n  var l1 = l.slice();\n  l1.splice(i, 1);\n  return just(l1);\n};\n\nexport const _updateAt = function (just, nothing, i, a, l) {\n  if (i < 0 || i >= l.length) return nothing;\n  var l1 = l.slice();\n  l1[i] = a;\n  return just(l1);\n};\n\n//------------------------------------------------------------------------------\n// Transformations -------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexport const reverse = function (l) {\n  return l.slice().reverse();\n};\n\nexport const concat = function (xss) {\n  if (xss.length <= 10000) {\n    // This method is faster, but it crashes on big arrays.\n    // So we use it when can and fallback to simple variant otherwise.\n    return Array.prototype.concat.apply([], xss);\n  }\n\n  var result = [];\n  for (var i = 0, l = xss.length; i < l; i++) {\n    var xs = xss[i];\n    for (var j = 0, m = xs.length; j < m; j++) {\n      result.push(xs[j]);\n    }\n  }\n  return result;\n};\n\nexport const filterImpl = function (f, xs) {\n  return xs.filter(f);\n};\n\nexport const partitionImpl = function (f, xs) {\n  var yes = [];\n  var no  = [];\n  for (var i = 0; i < xs.length; i++) {\n    var x = xs[i];\n    if (f(x))\n      yes.push(x);\n    else\n      no.push(x);\n  }\n  return { yes: yes, no: no };\n};\n\nexport const scanlImpl = function (f, b, xs) {\n  var len = xs.length;\n  var acc = b;\n  var out = new Array(len);\n  for (var i = 0; i < len; i++) {\n    acc = f(acc)(xs[i]);\n    out[i] = acc;\n  }\n  return out;\n};\n\nexport const scanrImpl = function (f, b, xs) {\n  var len = xs.length;\n  var acc = b;\n  var out = new Array(len);\n  for (var i = len - 1; i >= 0; i--) {\n    acc = f(xs[i])(acc);\n    out[i] = acc;\n  }\n  return out;\n};\n\n//------------------------------------------------------------------------------\n// Sorting ---------------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexport const sortByImpl = (function () {\n  function mergeFromTo(compare, fromOrdering, xs1, xs2, from, to) {\n    var mid;\n    var i;\n    var j;\n    var k;\n    var x;\n    var y;\n    var c;\n\n    mid = from + ((to - from) >> 1);\n    if (mid - from > 1) mergeFromTo(compare, fromOrdering, xs2, xs1, from, mid);\n    if (to - mid > 1) mergeFromTo(compare, fromOrdering, xs2, xs1, mid, to);\n\n    i = from;\n    j = mid;\n    k = from;\n    while (i < mid && j < to) {\n      x = xs2[i];\n      y = xs2[j];\n      c = fromOrdering(compare(x)(y));\n      if (c > 0) {\n        xs1[k++] = y;\n        ++j;\n      }\n      else {\n        xs1[k++] = x;\n        ++i;\n      }\n    }\n    while (i < mid) {\n      xs1[k++] = xs2[i++];\n    }\n    while (j < to) {\n      xs1[k++] = xs2[j++];\n    }\n  }\n\n  return function (compare, fromOrdering, xs) {\n    var out;\n\n    if (xs.length < 2) return xs;\n\n    out = xs.slice(0);\n    mergeFromTo(compare, fromOrdering, out, xs.slice(0), 0, xs.length);\n\n    return out;\n  };\n})();\n\n//------------------------------------------------------------------------------\n// Subarrays -------------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexport const sliceImpl = function (s, e, l) {\n  return l.slice(s, e);\n};\n\n//------------------------------------------------------------------------------\n// Zipping ---------------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexport const zipWithImpl = function (f, xs, ys) {\n  var l = xs.length < ys.length ? xs.length : ys.length;\n  var result = new Array(l);\n  for (var i = 0; i < l; i++) {\n    result[i] = f(xs[i])(ys[i]);\n  }\n  return result;\n};\n\n//------------------------------------------------------------------------------\n// Folding ---------------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexport const anyImpl = function (p, xs) {\n  var len = xs.length;\n  for (var i = 0; i < len; i++) {\n    if (p(xs[i])) return true;\n  }\n  return false;\n};\n\nexport const allImpl = function (p, xs) {\n  var len = xs.length;\n  for (var i = 0; i < len; i++) {\n    if (!p(xs[i])) return false;\n  }\n  return true;\n};\n\n//------------------------------------------------------------------------------\n// Partial ---------------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexport const unsafeIndexImpl = function (xs, n) {\n  return xs[n];\n};\n", "function newSTArray() {\n  return [];\n}\nexport { newSTArray as new };\n\nexport const peekImpl = function (just, nothing, i, xs) {\n  return i >= 0 && i < xs.length ? just(xs[i]) : nothing;\n};\n\nexport const pokeImpl = function (i, a, xs) {\n  var ret = i >= 0 && i < xs.length;\n  if (ret) xs[i] = a;\n  return ret;\n};\n\nexport const lengthImpl = function (xs) {\n  return xs.length;\n};\n\nexport const popImpl = function (just, nothing, xs) {\n  return xs.length > 0 ? just(xs.pop()) : nothing;\n};\n\nexport const pushAllImpl = function (as, xs) {\n  return xs.push.apply(xs, as);\n};\n\nexport const shiftImpl = function (just, nothing, xs) {\n  return xs.length > 0 ? just(xs.shift()) : nothing;\n};\n\nexport const unshiftAllImpl = function (as, xs) {\n  return xs.unshift.apply(xs, as);\n};\n\nexport const spliceImpl = function (i, howMany, bs, xs) {\n  return xs.splice.apply(xs, [i, howMany].concat(bs));\n};\n\nfunction unsafeFreezeThawImpl(xs) {\n  return xs;\n}\n\nexport const unsafeFreezeImpl = unsafeFreezeThawImpl;\n\nexport const unsafeThawImpl = unsafeFreezeThawImpl;\n\nfunction copyImpl(xs) {\n  return xs.slice();\n}\n\nexport const freezeImpl = copyImpl;\n\nexport const thawImpl = copyImpl;\n\nexport const cloneImpl = copyImpl;\n\nexport const sortByImpl = (function () {\n  function mergeFromTo(compare, fromOrdering, xs1, xs2, from, to) {\n    var mid;\n    var i;\n    var j;\n    var k;\n    var x;\n    var y;\n    var c;\n\n    mid = from + ((to - from) >> 1);\n    if (mid - from > 1) mergeFromTo(compare, fromOrdering, xs2, xs1, from, mid);\n    if (to - mid > 1) mergeFromTo(compare, fromOrdering, xs2, xs1, mid, to);\n\n    i = from;\n    j = mid;\n    k = from;\n    while (i < mid && j < to) {\n      x = xs2[i];\n      y = xs2[j];\n      c = fromOrdering(compare(x)(y));\n      if (c > 0) {\n        xs1[k++] = y;\n        ++j;\n      } else {\n        xs1[k++] = x;\n        ++i;\n      }\n    }\n    while (i < mid) {\n      xs1[k++] = xs2[i++];\n    }\n    while (j < to) {\n      xs1[k++] = xs2[j++];\n    }\n  }\n\n  return function (compare, fromOrdering, xs) {\n    if (xs.length < 2) return xs;\n\n    mergeFromTo(compare, fromOrdering, xs, xs.slice(0), 0, xs.length);\n\n    return xs;\n  };\n})();\n\nexport const toAssocArrayImpl = function (xs) {\n  var n = xs.length;\n  var as = new Array(n);\n  for (var i = 0; i < n; i++) as[i] = { value: xs[i], index: i };\n  return as;\n};\n\nexport const pushImpl = function (a, xs) {\n  return xs.push(a);\n};\n", "export const mkSTFn1 = function mkSTFn1(fn) {\n  return function(x) {\n    return fn(x)();\n  };\n};\n  \nexport const mkSTFn2 = function mkSTFn2(fn) {\n  return function(a, b) {\n    return fn(a)(b)();\n  };\n};\n  \nexport const mkSTFn3 = function mkSTFn3(fn) {\n  return function(a, b, c) {\n    return fn(a)(b)(c)();\n  };\n};\n  \nexport const mkSTFn4 = function mkSTFn4(fn) {\n  return function(a, b, c, d) {\n    return fn(a)(b)(c)(d)();\n  };\n};\n  \nexport const mkSTFn5 = function mkSTFn5(fn) {\n  return function(a, b, c, d, e) {\n    return fn(a)(b)(c)(d)(e)();\n  };\n};\n  \nexport const mkSTFn6 = function mkSTFn6(fn) {\n  return function(a, b, c, d, e, f) {\n    return fn(a)(b)(c)(d)(e)(f)();\n  };\n};\n  \nexport const mkSTFn7 = function mkSTFn7(fn) {\n  return function(a, b, c, d, e, f, g) {\n    return fn(a)(b)(c)(d)(e)(f)(g)();\n  };\n};\n  \nexport const mkSTFn8 = function mkSTFn8(fn) {\n  return function(a, b, c, d, e, f, g, h) {\n    return fn(a)(b)(c)(d)(e)(f)(g)(h)();\n  };\n};\n  \nexport const mkSTFn9 = function mkSTFn9(fn) {\n  return function(a, b, c, d, e, f, g, h, i) {\n    return fn(a)(b)(c)(d)(e)(f)(g)(h)(i)();\n  };\n};\n  \nexport const mkSTFn10 = function mkSTFn10(fn) {\n  return function(a, b, c, d, e, f, g, h, i, j) {\n    return fn(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)();\n  };\n};\n  \nexport const runSTFn1 = function runSTFn1(fn) {\n  return function(a) {\n    return function() {\n      return fn(a);\n    };\n  };\n};\n  \nexport const runSTFn2 = function runSTFn2(fn) {\n  return function(a) {\n    return function(b) {\n      return function() {\n        return fn(a, b);\n      };\n    };\n  };\n};\n  \nexport const runSTFn3 = function runSTFn3(fn) {\n  return function(a) {\n    return function(b) {\n      return function(c) {\n        return function() {\n          return fn(a, b, c);\n        };\n      };\n    };\n  };\n};\n  \nexport const runSTFn4 = function runSTFn4(fn) {\n  return function(a) {\n    return function(b) {\n      return function(c) {\n        return function(d) {\n          return function() {\n            return fn(a, b, c, d);\n          };\n        };\n      };\n    };\n  };\n};\n  \nexport const runSTFn5 = function runSTFn5(fn) {\n  return function(a) {\n    return function(b) {\n      return function(c) {\n        return function(d) {\n          return function(e) {\n            return function() {\n              return fn(a, b, c, d, e);\n            };\n          };\n        };\n      };\n    };\n  };\n};\n  \nexport const runSTFn6 = function runSTFn6(fn) {\n  return function(a) {\n    return function(b) {\n      return function(c) {\n        return function(d) {\n          return function(e) {\n            return function(f) {\n              return function() {\n                return fn(a, b, c, d, e, f);\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n};\n  \nexport const runSTFn7 = function runSTFn7(fn) {\n  return function(a) {\n    return function(b) {\n      return function(c) {\n        return function(d) {\n          return function(e) {\n            return function(f) {\n              return function(g) {\n                return function() {\n                  return fn(a, b, c, d, e, f, g);\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n};\n  \nexport const runSTFn8 = function runSTFn8(fn) {\n  return function(a) {\n    return function(b) {\n      return function(c) {\n        return function(d) {\n          return function(e) {\n            return function(f) {\n              return function(g) {\n                return function(h) {\n                  return function() {\n                    return fn(a, b, c, d, e, f, g, h);\n                  };\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n};\n  \nexport const runSTFn9 = function runSTFn9(fn) {\n  return function(a) {\n    return function(b) {\n      return function(c) {\n        return function(d) {\n          return function(e) {\n            return function(f) {\n              return function(g) {\n                return function(h) {\n                  return function(i) {\n                    return function() {\n                      return fn(a, b, c, d, e, f, g, h, i);\n                    };\n                  };\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n};\n  \nexport const runSTFn10 = function runSTFn10(fn) {\n  return function(a) {\n    return function(b) {\n      return function(c) {\n        return function(d) {\n          return function(e) {\n            return function(f) {\n              return function(g) {\n                return function(h) {\n                  return function(i) {\n                    return function(j) {\n                      return function() {\n                        return fn(a, b, c, d, e, f, g, h, i, j);\n                      };\n                    };\n                  };\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n};", "-- | Helper functions for working with mutable arrays using the `ST` effect.\n-- |\n-- | This module can be used when performance is important and mutation is a local effect.\n\nmodule Data.Array.ST\n  ( STArray(..)\n  , Assoc\n  , run\n  , withArray\n  , new\n  , peek\n  , poke\n  , modify\n  , length\n  , pop\n  , push\n  , pushAll\n  , shift\n  , unshift\n  , unshiftAll\n  , splice\n  , sort\n  , sortBy\n  , sortWith\n  , freeze\n  , thaw\n  , clone\n  , unsafeFreeze\n  , unsafeThaw\n  , toAssocArray\n  ) where\n\nimport Prelude\n\nimport Control.Monad.ST (ST, Region)\nimport Control.Monad.ST as ST\nimport Control.Monad.ST.Uncurried (STFn1, STFn2, STFn3, STFn4, runSTFn1, runSTFn2, runSTFn3, runSTFn4)\nimport Data.Maybe (Maybe(..))\n\n-- | A reference to a mutable array.\n-- |\n-- | The first type parameter represents the memory region which the array belongs to.\n-- | The second type parameter defines the type of elements of the mutable array.\n-- |\n-- | The runtime representation of a value of type `STArray h a` is the same as that of `Array a`,\n-- | except that mutation is allowed.\nforeign import data STArray :: Region -> Type -> Type\n\ntype role STArray nominal representational\n\n-- | An element and its index.\ntype Assoc a = { value :: a, index :: Int }\n\n-- | A safe way to create and work with a mutable array before returning an\n-- | immutable array for later perusal. This function avoids copying the array\n-- | before returning it - it uses unsafeFreeze internally, but this wrapper is\n-- | a safe interface to that function.\nrun :: forall a. (forall h. ST h (STArray h a)) -> Array a\nrun st = ST.run (st >>= unsafeFreeze)\n\n-- | Perform an effect requiring a mutable array on a copy of an immutable array,\n-- | safely returning the result as an immutable array.\nwithArray\n  :: forall h a b\n   . (STArray h a -> ST h b)\n  -> Array a\n  -> ST h (Array a)\nwithArray f xs = do\n  result <- thaw xs\n  _ <- f result\n  unsafeFreeze result\n\n-- | O(1). Convert a mutable array to an immutable array, without copying. The mutable\n-- | array must not be mutated afterwards.\nunsafeFreeze :: forall h a. STArray h a -> ST h (Array a)\nunsafeFreeze = runSTFn1 unsafeFreezeImpl\n\nforeign import unsafeFreezeImpl :: forall h a. STFn1 (STArray h a) h (Array a)\n\n-- | O(1) Convert an immutable array to a mutable array, without copying. The input\n-- | array must not be used afterward.\nunsafeThaw :: forall h a. Array a -> ST h (STArray h a)\nunsafeThaw = runSTFn1 unsafeThawImpl\n\nforeign import unsafeThawImpl :: forall h a. STFn1 (Array a) h (STArray h a)\n\n-- | Create a new, empty mutable array.\nforeign import new :: forall h a. ST h (STArray h a)\n\nthaw\n  :: forall h a\n   . Array a\n  -> ST h (STArray h a)\nthaw = runSTFn1 thawImpl\n\n-- | Create a mutable copy of an immutable array.\nforeign import thawImpl :: forall h a. STFn1 (Array a) h (STArray h a)\n\n-- | Make a mutable copy of a mutable array.\nclone\n  :: forall h a\n   . STArray h a\n  -> ST h (STArray h a)\nclone = runSTFn1 cloneImpl\n\nforeign import cloneImpl :: forall h a. STFn1 (STArray h a) h (STArray h a)\n\n-- | Sort a mutable array in place. Sorting is stable: the order of equal\n-- | elements is preserved.\nsort :: forall a h. Ord a => STArray h a -> ST h (STArray h a)\nsort = sortBy compare\n\n-- | Remove the first element from an array and return that element.\nshift :: forall h a. STArray h a -> ST h (Maybe a)\nshift = runSTFn3 shiftImpl Just Nothing\n\nforeign import shiftImpl\n  :: forall h a\n   . STFn3 (forall b. b -> Maybe b) (forall b. Maybe b) (STArray h a) h (Maybe a)\n\n-- | Sort a mutable array in place using a comparison function. Sorting is\n-- | stable: the order of elements is preserved if they are equal according to\n-- | the comparison function.\nsortBy\n  :: forall a h\n   . (a -> a -> Ordering)\n  -> STArray h a\n  -> ST h (STArray h a)\nsortBy comp = runSTFn3 sortByImpl comp case _ of\n  GT -> 1\n  EQ -> 0\n  LT -> -1\n\nforeign import sortByImpl\n  :: forall a h\n   . STFn3 (a -> a -> Ordering) (Ordering -> Int) (STArray h a) h (STArray h a)\n\n-- | Sort a mutable array in place based on a projection. Sorting is stable: the\n-- | order of elements is preserved if they are equal according to the projection.\nsortWith\n  :: forall a b h\n   . Ord b\n  => (a -> b)\n  -> STArray h a\n  -> ST h (STArray h a)\nsortWith f = sortBy (comparing f)\n\n-- | Create an immutable copy of a mutable array.\nfreeze\n  :: forall h a\n   . STArray h a\n  -> ST h (Array a)\nfreeze = runSTFn1 freezeImpl\n\nforeign import freezeImpl :: forall h a. STFn1 (STArray h a) h (Array a)\n\n-- | Read the value at the specified index in a mutable array.\npeek\n  :: forall h a\n   . Int\n  -> STArray h a\n  -> ST h (Maybe a)\npeek = runSTFn4 peekImpl Just Nothing\n\nforeign import peekImpl :: forall h a r. STFn4 (a -> r) r Int (STArray h a) h r\n\npoke\n  :: forall h a\n   . Int\n  -> a\n  -> STArray h a\n  -> ST h Boolean\npoke = runSTFn3 pokeImpl\n\n-- | Change the value at the specified index in a mutable array.\nforeign import pokeImpl :: forall h a. STFn3 Int a (STArray h a) h Boolean\n\nforeign import lengthImpl :: forall h a. STFn1 (STArray h a) h Int\n\n-- | Get the number of elements in a mutable array.\nlength :: forall h a. STArray h a -> ST h Int\nlength = runSTFn1 lengthImpl\n\n-- | Remove the last element from an array and return that element.\npop :: forall h a. STArray h a -> ST h (Maybe a)\npop = runSTFn3 popImpl Just Nothing\n\nforeign import popImpl\n  :: forall h a\n   . STFn3 (forall b. b -> Maybe b) (forall b. Maybe b) (STArray h a) h (Maybe a)\n\n-- | Append an element to the end of a mutable array. Returns the new length of\n-- | the array.\npush :: forall h a. a -> (STArray h a) -> ST h Int\npush = runSTFn2 pushImpl\n\nforeign import pushImpl :: forall h a. STFn2 a (STArray h a) h Int\n\n-- | Append the values in an immutable array to the end of a mutable array.\n-- | Returns the new length of the mutable array.\npushAll\n  :: forall h a\n   . Array a\n  -> STArray h a\n  -> ST h Int\npushAll = runSTFn2 pushAllImpl\n\nforeign import pushAllImpl\n  :: forall h a\n   . STFn2 (Array a) (STArray h a) h Int\n\n-- | Append an element to the front of a mutable array. Returns the new length of\n-- | the array.\nunshift :: forall h a. a -> STArray h a -> ST h Int\nunshift a = runSTFn2 unshiftAllImpl [ a ]\n\n-- | Append the values in an immutable array to the front of a mutable array.\n-- | Returns the new length of the mutable array.\nunshiftAll\n  :: forall h a\n   . Array a\n  -> STArray h a\n  -> ST h Int\nunshiftAll = runSTFn2 unshiftAllImpl\n\nforeign import unshiftAllImpl\n  :: forall h a\n   . STFn2 (Array a) (STArray h a) h Int\n\n-- | Mutate the element at the specified index using the supplied function.\nmodify :: forall h a. Int -> (a -> a) -> STArray h a -> ST h Boolean\nmodify i f xs = do\n  entry <- peek i xs\n  case entry of\n    Just x -> poke i (f x) xs\n    Nothing -> pure false\n\n-- | Remove and/or insert elements from/into a mutable array at the specified index.\nsplice\n  :: forall h a\n   . Int\n  -> Int\n  -> Array a\n  -> STArray h a\n  -> ST h (Array a)\nsplice = runSTFn4 spliceImpl\n\nforeign import spliceImpl\n  :: forall h a\n   . STFn4 Int Int (Array a) (STArray h a) h (Array a)\n\n-- | Create an immutable copy of a mutable array, where each element\n-- | is labelled with its index in the original array.\ntoAssocArray\n  :: forall h a\n   . STArray h a\n  -> ST h (Array (Assoc a))\ntoAssocArray = runSTFn1 toAssocArrayImpl\n\nforeign import toAssocArrayImpl\n  :: forall h a\n   . STFn1 (STArray h a) h (Array (Assoc a))\n", "module Data.Array.ST.Iterator\n  ( Iterator\n  , iterator\n  , iterate\n  , next\n  , peek\n  , exhausted\n  , pushWhile\n  , pushAll\n  ) where\n\nimport Prelude\nimport Control.Monad.ST (ST)\nimport Control.Monad.ST as ST\nimport Control.Monad.ST.Ref (STRef)\nimport Control.Monad.ST.Ref as STRef\nimport Data.Array.ST (STArray)\nimport Data.Array.ST as STA\n\nimport Data.Maybe (Maybe(..), isNothing)\n\n-- | This type provides a slightly easier way of iterating over an array's\n-- | elements in an STArray computation, without having to keep track of\n-- | indices.\ndata Iterator r a = Iterator (Int -> Maybe a) (STRef r Int)\n\n-- | Make an Iterator given an indexing function into an array (or anything\n-- | else). If `xs :: Array a`, the standard way to create an iterator over\n-- | `xs` is to use `iterator (xs !! _)`, where `(!!)` comes from `Data.Array`.\niterator :: forall r a. (Int -> Maybe a) -> ST r (Iterator r a)\niterator f =\n  Iterator f <$> STRef.new 0\n\n-- | Perform an action once for each item left in an iterator. If the action\n-- | itself also advances the same iterator, `iterate` will miss those items\n-- | out.\niterate :: forall r a. Iterator r a -> (a -> ST r Unit) -> ST r Unit\niterate iter f = do\n  break <- STRef.new false\n  ST.while (not <$> STRef.read break) do\n    mx <- next iter\n    case mx of\n      Just x -> f x\n      Nothing -> void $ STRef.write true break\n\n-- | Get the next item out of an iterator, advancing it. Returns Nothing if the\n-- | Iterator is exhausted.\nnext :: forall r a. Iterator r a -> ST r (Maybe a)\nnext (Iterator f currentIndex) = do\n  i <- STRef.read currentIndex\n  _ <- STRef.modify (_ + 1) currentIndex\n  pure (f i)\n\n-- | Get the next item out of an iterator without advancing it.\npeek :: forall r a. Iterator r a -> ST r (Maybe a)\npeek (Iterator f currentIndex) = do\n  i <- STRef.read currentIndex\n  pure (f i)\n\n-- | Check whether an iterator has been exhausted.\nexhausted :: forall r a. Iterator r a -> ST r Boolean\nexhausted = map isNothing <<< peek\n\n-- | Extract elements from an iterator and push them on to an STArray for as\n-- | long as those elements satisfy a given predicate.\npushWhile :: forall r a. (a -> Boolean) -> Iterator r a -> STArray r a -> ST r Unit\npushWhile p iter array = do\n  break <- STRef.new false\n  ST.while (not <$> STRef.read break) do\n    mx <- peek iter\n    case mx of\n      Just x | p x -> do\n        _ <- STA.push x array\n        void $ next iter\n      _ ->\n        void $ STRef.write true break\n\n-- | Push the entire remaining contents of an iterator onto an STArray.\npushAll :: forall r a. Iterator r a -> STArray r a -> ST r Unit\npushAll = pushWhile (const true)\n", "// module Data.Function.Uncurried\n\nexport const mkFn0 = function (fn) {\n  return function () {\n    return fn();\n  };\n};\n\nexport const mkFn2 = function (fn) {\n  /* jshint maxparams: 2 */\n  return function (a, b) {\n    return fn(a)(b);\n  };\n};\n\nexport const mkFn3 = function (fn) {\n  /* jshint maxparams: 3 */\n  return function (a, b, c) {\n    return fn(a)(b)(c);\n  };\n};\n\nexport const mkFn4 = function (fn) {\n  /* jshint maxparams: 4 */\n  return function (a, b, c, d) {\n    return fn(a)(b)(c)(d);\n  };\n};\n\nexport const mkFn5 = function (fn) {\n  /* jshint maxparams: 5 */\n  return function (a, b, c, d, e) {\n    return fn(a)(b)(c)(d)(e);\n  };\n};\n\nexport const mkFn6 = function (fn) {\n  /* jshint maxparams: 6 */\n  return function (a, b, c, d, e, f) {\n    return fn(a)(b)(c)(d)(e)(f);\n  };\n};\n\nexport const mkFn7 = function (fn) {\n  /* jshint maxparams: 7 */\n  return function (a, b, c, d, e, f, g) {\n    return fn(a)(b)(c)(d)(e)(f)(g);\n  };\n};\n\nexport const mkFn8 = function (fn) {\n  /* jshint maxparams: 8 */\n  return function (a, b, c, d, e, f, g, h) {\n    return fn(a)(b)(c)(d)(e)(f)(g)(h);\n  };\n};\n\nexport const mkFn9 = function (fn) {\n  /* jshint maxparams: 9 */\n  return function (a, b, c, d, e, f, g, h, i) {\n    return fn(a)(b)(c)(d)(e)(f)(g)(h)(i);\n  };\n};\n\nexport const mkFn10 = function (fn) {\n  /* jshint maxparams: 10 */\n  return function (a, b, c, d, e, f, g, h, i, j) {\n    return fn(a)(b)(c)(d)(e)(f)(g)(h)(i)(j);\n  };\n};\n\nexport const runFn0 = function (fn) {\n  return fn();\n};\n\nexport const runFn2 = function (fn) {\n  return function (a) {\n    return function (b) {\n      return fn(a, b);\n    };\n  };\n};\n\nexport const runFn3 = function (fn) {\n  return function (a) {\n    return function (b) {\n      return function (c) {\n        return fn(a, b, c);\n      };\n    };\n  };\n};\n\nexport const runFn4 = function (fn) {\n  return function (a) {\n    return function (b) {\n      return function (c) {\n        return function (d) {\n          return fn(a, b, c, d);\n        };\n      };\n    };\n  };\n};\n\nexport const runFn5 = function (fn) {\n  return function (a) {\n    return function (b) {\n      return function (c) {\n        return function (d) {\n          return function (e) {\n            return fn(a, b, c, d, e);\n          };\n        };\n      };\n    };\n  };\n};\n\nexport const runFn6 = function (fn) {\n  return function (a) {\n    return function (b) {\n      return function (c) {\n        return function (d) {\n          return function (e) {\n            return function (f) {\n              return fn(a, b, c, d, e, f);\n            };\n          };\n        };\n      };\n    };\n  };\n};\n\nexport const runFn7 = function (fn) {\n  return function (a) {\n    return function (b) {\n      return function (c) {\n        return function (d) {\n          return function (e) {\n            return function (f) {\n              return function (g) {\n                return fn(a, b, c, d, e, f, g);\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n};\n\nexport const runFn8 = function (fn) {\n  return function (a) {\n    return function (b) {\n      return function (c) {\n        return function (d) {\n          return function (e) {\n            return function (f) {\n              return function (g) {\n                return function (h) {\n                  return fn(a, b, c, d, e, f, g, h);\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n};\n\nexport const runFn9 = function (fn) {\n  return function (a) {\n    return function (b) {\n      return function (c) {\n        return function (d) {\n          return function (e) {\n            return function (f) {\n              return function (g) {\n                return function (h) {\n                  return function (i) {\n                    return fn(a, b, c, d, e, f, g, h, i);\n                  };\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n};\n\nexport const runFn10 = function (fn) {\n  return function (a) {\n    return function (b) {\n      return function (c) {\n        return function (d) {\n          return function (e) {\n            return function (f) {\n              return function (g) {\n                return function (h) {\n                  return function (i) {\n                    return function (j) {\n                      return fn(a, b, c, d, e, f, g, h, i, j);\n                    };\n                  };\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n};\n", "-- | Helper functions for working with immutable Javascript arrays.\n-- |\n-- | _Note_: Depending on your use-case, you may prefer to use `Data.List` or\n-- | `Data.Sequence` instead, which might give better performance for certain\n-- | use cases. This module is useful when integrating with JavaScript libraries\n-- | which use arrays, but immutable arrays are not a practical data structure\n-- | for many use cases due to their poor asymptotics.\n-- |\n-- | In addition to the functions in this module, Arrays have a number of\n-- | useful instances:\n-- |\n-- | * `Functor`, which provides `map :: forall a b. (a -> b) -> Array a ->\n-- |   Array b`\n-- | * `Apply`, which provides `(<*>) :: forall a b. Array (a -> b) -> Array a\n-- |   -> Array b`. This function works a bit like a Cartesian product; the\n-- |   result array is constructed by applying each function in the first\n-- |   array to each value in the second, so that the result array ends up with\n-- |   a length equal to the product of the two arguments' lengths.\n-- | * `Bind`, which provides `(>>=) :: forall a b. (a -> Array b) -> Array a\n-- |   -> Array b` (this is the same as `concatMap`).\n-- | * `Semigroup`, which provides `(<>) :: forall a. Array a -> Array a ->\n-- |   Array a`, for concatenating arrays.\n-- | * `Foldable`, which provides a slew of functions for *folding* (also known\n-- |   as *reducing*) arrays down to one value. For example,\n-- |   `Data.Foldable.or` tests whether an array of `Boolean` values contains\n-- |   at least one `true` value.\n-- | * `Traversable`, which provides the PureScript version of a for-loop,\n-- |   allowing you to STAI.iterate over an array and accumulate effects.\n-- |\nmodule Data.Array\n  ( fromFoldable\n  , toUnfoldable\n  , singleton\n  , (..)\n  , range\n  , replicate\n  , some\n  , many\n\n  , null\n  , length\n\n  , (:)\n  , cons\n  , snoc\n  , insert\n  , insertBy\n\n  , head\n  , last\n  , tail\n  , init\n  , uncons\n  , unsnoc\n\n  , (!!)\n  , index\n  , elem\n  , notElem\n  , elemIndex\n  , elemLastIndex\n  , find\n  , findMap\n  , findIndex\n  , findLastIndex\n  , insertAt\n  , deleteAt\n  , updateAt\n  , updateAtIndices\n  , modifyAt\n  , modifyAtIndices\n  , alterAt\n\n  , intersperse\n  , reverse\n  , concat\n  , concatMap\n  , filter\n  , partition\n  , splitAt\n  , filterA\n  , mapMaybe\n  , catMaybes\n  , mapWithIndex\n  , foldl\n  , foldr\n  , foldMap\n  , fold\n  , intercalate\n  , transpose\n  , scanl\n  , scanr\n\n  , sort\n  , sortBy\n  , sortWith\n  , slice\n  , take\n  , takeEnd\n  , takeWhile\n  , drop\n  , dropEnd\n  , dropWhile\n  , span\n  , group\n  , groupAll\n  , groupBy\n  , groupAllBy\n\n  , nub\n  , nubEq\n  , nubBy\n  , nubByEq\n  , union\n  , unionBy\n  , delete\n  , deleteBy\n\n  , (\\\\)\n  , difference\n  , intersect\n  , intersectBy\n\n  , zipWith\n  , zipWithA\n  , zip\n  , unzip\n\n  , any\n  , all\n\n  , foldM\n  , foldRecM\n\n  , unsafeIndex\n  ) where\n\nimport Prelude\n\nimport Control.Alt ((<|>))\nimport Control.Alternative (class Alternative)\nimport Control.Lazy (class Lazy, defer)\nimport Control.Monad.Rec.Class (class MonadRec, Step(..), tailRecM2)\nimport Control.Monad.ST as ST\nimport Data.Array.NonEmpty.Internal (NonEmptyArray(..))\nimport Data.Array.ST as STA\nimport Data.Array.ST.Iterator as STAI\nimport Data.Foldable (class Foldable, traverse_)\nimport Data.Foldable as F\nimport Data.Function.Uncurried (Fn2, Fn3, Fn4, Fn5, runFn2, runFn3, runFn4, runFn5)\nimport Data.FunctorWithIndex as FWI\nimport Data.Maybe (Maybe(..), maybe, isJust, fromJust, isNothing)\nimport Data.Traversable (sequence, traverse)\nimport Data.Tuple (Tuple(..), fst, snd)\nimport Data.Unfoldable (class Unfoldable, unfoldr)\nimport Partial.Unsafe (unsafePartial)\n\n-- | Convert an `Array` into an `Unfoldable` structure.\ntoUnfoldable :: forall f. Unfoldable f => Array ~> f\ntoUnfoldable xs = unfoldr f 0\n  where\n  len = length xs\n  f i\n    | i < len = Just (Tuple (unsafePartial (unsafeIndex xs i)) (i + 1))\n    | otherwise = Nothing\n\n-- | Convert a `Foldable` structure into an `Array`.\n-- |\n-- | ```purescript\n-- | fromFoldable (Just 1) = [1]\n-- | fromFoldable (Nothing) = []\n-- | ```\n-- |\nfromFoldable :: forall f. Foldable f => f ~> Array\nfromFoldable = runFn2 fromFoldableImpl F.foldr\n\nforeign import fromFoldableImpl\n  :: forall f a\n   . Fn2 (forall b. (a -> b -> b) -> b -> f a -> b) (f a) (Array a)\n\n-- | Create an array of one element\n-- | ```purescript\n-- | singleton 2 = [2]\n-- | ```\nsingleton :: forall a. a -> Array a\nsingleton a = [ a ]\n\n-- | Create an array containing a range of integers, including both endpoints.\n-- | ```purescript\n-- | range 2 5 = [2, 3, 4, 5]\n-- | ```\nrange :: Int -> Int -> Array Int\nrange = runFn2 rangeImpl\n\nforeign import rangeImpl :: Fn2 Int Int (Array Int)\n\n-- | Create an array containing a value repeated the specified number of times.\n-- | ```purescript\n-- | replicate 2 \"Hi\" = [\"Hi\", \"Hi\"]\n-- | ```\nreplicate :: forall a. Int -> a -> Array a\nreplicate = runFn2 replicateImpl\n\nforeign import replicateImpl :: forall a. Fn2 Int a (Array a)\n\n-- | An infix synonym for `range`.\n-- | ```purescript\n-- | 2 .. 5 = [2, 3, 4, 5]\n-- | ```\ninfix 8 range as ..\n\n-- | Attempt a computation multiple times, requiring at least one success.\n-- |\n-- | The `Lazy` constraint is used to generate the result lazily, to ensure\n-- | termination.\nsome :: forall f a. Alternative f => Lazy (f (Array a)) => f a -> f (Array a)\nsome v = (:) <$> v <*> defer (\\_ -> many v)\n\n-- | Attempt a computation multiple times, returning as many successful results\n-- | as possible (possibly zero).\n-- |\n-- | The `Lazy` constraint is used to generate the result lazily, to ensure\n-- | termination.\nmany :: forall f a. Alternative f => Lazy (f (Array a)) => f a -> f (Array a)\nmany v = some v <|> pure []\n\n--------------------------------------------------------------------------------\n-- Array size ------------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Test whether an array is empty.\n-- | ```purescript\n-- | null [] = true\n-- | null [1, 2] = false\n-- | ```\nnull :: forall a. Array a -> Boolean\nnull xs = length xs == 0\n\n-- | Get the number of elements in an array.\n-- | ```purescript\n-- | length [\"Hello\", \"World\"] = 2\n-- | ```\nforeign import length :: forall a. Array a -> Int\n\n--------------------------------------------------------------------------------\n-- Extending arrays ------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Attaches an element to the front of an array, creating a new array.\n-- |\n-- | ```purescript\n-- | cons 1 [2, 3, 4] = [1, 2, 3, 4]\n-- | ```\n-- |\n-- | Note, the running time of this function is `O(n)`.\ncons :: forall a. a -> Array a -> Array a\ncons x xs = [ x ] <> xs\n\n-- | An infix alias for `cons`.\n-- |\n-- | ```purescript\n-- | 1 : [2, 3, 4] = [1, 2, 3, 4]\n-- | ```\n-- |\n-- | Note, the running time of this function is `O(n)`.\ninfixr 6 cons as :\n\n-- | Append an element to the end of an array, creating a new array.\n-- |\n-- | ```purescript\n-- | snoc [1, 2, 3] 4 = [1, 2, 3, 4]\n-- | ```\n-- |\nsnoc :: forall a. Array a -> a -> Array a\nsnoc xs x = ST.run (STA.withArray (STA.push x) xs)\n\n-- | Insert an element into a sorted array.\n-- |\n-- | ```purescript\n-- | insert 10 [1, 2, 20, 21] = [1, 2, 10, 20, 21]\n-- | ```\n-- |\ninsert :: forall a. Ord a => a -> Array a -> Array a\ninsert = insertBy compare\n\n-- | Insert an element into a sorted array, using the specified function to\n-- | determine the ordering of elements.\n-- |\n-- | ```purescript\n-- | invertCompare a b = invert $ compare a b\n-- |\n-- | insertBy invertCompare 10 [21, 20, 2, 1] = [21, 20, 10, 2, 1]\n-- | ```\n-- |\ninsertBy :: forall a. (a -> a -> Ordering) -> a -> Array a -> Array a\ninsertBy cmp x ys =\n  let\n    i = maybe 0 (_ + 1) (findLastIndex (\\y -> cmp x y == GT) ys)\n  in\n    unsafePartial (fromJust (insertAt i x ys))\n\n--------------------------------------------------------------------------------\n-- Non-indexed reads -----------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Get the first element in an array, or `Nothing` if the array is empty\n-- |\n-- | Running time: `O(1)`.\n-- |\n-- | ```purescript\n-- | head [1, 2] = Just 1\n-- | head [] = Nothing\n-- | ```\n-- |\nhead :: forall a. Array a -> Maybe a\nhead xs = xs !! 0\n\n-- | Get the last element in an array, or `Nothing` if the array is empty\n-- |\n-- | Running time: `O(1)`.\n-- |\n-- | ```purescript\n-- | last [1, 2] = Just 2\n-- | last [] = Nothing\n-- | ```\n-- |\nlast :: forall a. Array a -> Maybe a\nlast xs = xs !! (length xs - 1)\n\n-- | Get all but the first element of an array, creating a new array, or\n-- | `Nothing` if the array is empty\n-- |\n-- | ```purescript\n-- | tail [1, 2, 3, 4] = Just [2, 3, 4]\n-- | tail [] = Nothing\n-- | ```\n-- |\n-- | Running time: `O(n)` where `n` is the length of the array\ntail :: forall a. Array a -> Maybe (Array a)\ntail = runFn3 unconsImpl (const Nothing) (\\_ xs -> Just xs)\n\n-- | Get all but the last element of an array, creating a new array, or\n-- | `Nothing` if the array is empty.\n-- |\n-- | ```purescript\n-- | init [1, 2, 3, 4] = Just [1, 2, 3]\n-- | init [] = Nothing\n-- | ```\n-- |\n-- | Running time: `O(n)` where `n` is the length of the array\ninit :: forall a. Array a -> Maybe (Array a)\ninit xs\n  | null xs = Nothing\n  | otherwise = Just (slice zero (length xs - one) xs)\n\n-- | Break an array into its first element and remaining elements.\n-- |\n-- | Using `uncons` provides a way of writing code that would use cons patterns\n-- | in Haskell or pre-PureScript 0.7:\n-- | ``` purescript\n-- | f (x : xs) = something\n-- | f [] = somethingElse\n-- | ```\n-- | Becomes:\n-- | ``` purescript\n-- | f arr = case uncons arr of\n-- |   Just { head: x, tail: xs } -> something\n-- |   Nothing -> somethingElse\n-- | ```\nuncons :: forall a. Array a -> Maybe { head :: a, tail :: Array a }\nuncons = runFn3 unconsImpl (const Nothing) \\x xs -> Just { head: x, tail: xs }\n\nforeign import unconsImpl\n  :: forall a b\n   . Fn3 (Unit -> b) (a -> Array a -> b) (Array a) b\n\n-- | Break an array into its last element and all preceding elements.\n-- |\n-- | ```purescript\n-- | unsnoc [1, 2, 3] = Just {init: [1, 2], last: 3}\n-- | unsnoc [] = Nothing\n-- | ```\n-- |\n-- | Running time: `O(n)` where `n` is the length of the array\nunsnoc :: forall a. Array a -> Maybe { init :: Array a, last :: a }\nunsnoc xs = { init: _, last: _ } <$> init xs <*> last xs\n\n--------------------------------------------------------------------------------\n-- Indexed operations ----------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | This function provides a safe way to read a value at a particular index\n-- | from an array.\n-- |\n-- | ```purescript\n-- | sentence = [\"Hello\", \"World\", \"!\"]\n-- |\n-- | index sentence 0 = Just \"Hello\"\n-- | index sentence 7 = Nothing\n-- | ```\n-- |\nindex :: forall a. Array a -> Int -> Maybe a\nindex = runFn4 indexImpl Just Nothing\n\nforeign import indexImpl\n  :: forall a\n   . Fn4 (forall r. r -> Maybe r) (forall r. Maybe r) (Array a) Int (Maybe a)\n\n-- | An infix version of `index`.\n-- |\n-- | ```purescript\n-- | sentence = [\"Hello\", \"World\", \"!\"]\n-- |\n-- | sentence !! 0 = Just \"Hello\"\n-- | sentence !! 7 = Nothing\n-- | ```\n-- |\ninfixl 8 index as !!\n\n-- | Returns true if the array has the given element.\nelem :: forall a. Eq a => a -> Array a -> Boolean\nelem a arr = isJust $ elemIndex a arr\n\n-- | Returns true if the array does not have the given element.\nnotElem :: forall a. Eq a => a -> Array a -> Boolean\nnotElem a arr = isNothing $ elemIndex a arr\n\n-- | Find the index of the first element equal to the specified element.\n-- |\n-- | ```purescript\n-- | elemIndex \"a\" [\"a\", \"b\", \"a\", \"c\"] = Just 0\n-- | elemIndex \"Earth\" [\"Hello\", \"World\", \"!\"] = Nothing\n-- | ```\n-- |\nelemIndex :: forall a. Eq a => a -> Array a -> Maybe Int\nelemIndex x = findIndex (_ == x)\n\n-- | Find the index of the last element equal to the specified element.\n-- |\n-- | ```purescript\n-- | elemLastIndex \"a\" [\"a\", \"b\", \"a\", \"c\"] = Just 2\n-- | elemLastIndex \"Earth\" [\"Hello\", \"World\", \"!\"] = Nothing\n-- | ```\n-- |\nelemLastIndex :: forall a. Eq a => a -> Array a -> Maybe Int\nelemLastIndex x = findLastIndex (_ == x)\n\n-- | Find the first element for which a predicate holds.\n-- |\n-- | ```purescript\n-- | find (contains $ Pattern \"b\") [\"a\", \"bb\", \"b\", \"d\"] = Just \"bb\"\n-- | find (contains $ Pattern \"x\") [\"a\", \"bb\", \"b\", \"d\"] = Nothing\n-- | ```\nfind :: forall a. (a -> Boolean) -> Array a -> Maybe a\nfind f xs = unsafePartial (unsafeIndex xs) <$> findIndex f xs\n\n-- | Find the first element in a data structure which satisfies\n-- | a predicate mapping.\nfindMap :: forall a b. (a -> Maybe b) -> Array a -> Maybe b\nfindMap = runFn4 findMapImpl Nothing isJust\n\nforeign import findMapImpl\n  :: forall a b\n   . Fn4\n       (forall c. Maybe c)\n       (forall c. Maybe c -> Boolean)\n       (a -> Maybe b)\n       (Array a)\n       (Maybe b)\n\n-- | Find the first index for which a predicate holds.\n-- |\n-- | ```purescript\n-- | findIndex (contains $ Pattern \"b\") [\"a\", \"bb\", \"b\", \"d\"] = Just 1\n-- | findIndex (contains $ Pattern \"x\") [\"a\", \"bb\", \"b\", \"d\"] = Nothing\n-- | ```\n-- |\nfindIndex :: forall a. (a -> Boolean) -> Array a -> Maybe Int\nfindIndex = runFn4 findIndexImpl Just Nothing\n\nforeign import findIndexImpl\n  :: forall a\n   . Fn4\n       (forall b. b -> Maybe b)\n       (forall b. Maybe b)\n       (a -> Boolean)\n       (Array a)\n       (Maybe Int)\n\n-- | Find the last index for which a predicate holds.\n-- |\n-- | ```purescript\n-- | findLastIndex (contains $ Pattern \"b\") [\"a\", \"bb\", \"b\", \"d\"] = Just 2\n-- | findLastIndex (contains $ Pattern \"x\") [\"a\", \"bb\", \"b\", \"d\"] = Nothing\n-- | ```\n-- |\nfindLastIndex :: forall a. (a -> Boolean) -> Array a -> Maybe Int\nfindLastIndex = runFn4 findLastIndexImpl Just Nothing\n\nforeign import findLastIndexImpl\n  :: forall a\n   . Fn4\n       (forall b. b -> Maybe b)\n       (forall b. Maybe b)\n       (a -> Boolean)\n       (Array a)\n       (Maybe Int)\n\n-- | Insert an element at the specified index, creating a new array, or\n-- | returning `Nothing` if the index is out of bounds.\n-- |\n-- | ```purescript\n-- | insertAt 2 \"!\" [\"Hello\", \"World\"] = Just [\"Hello\", \"World\", \"!\"]\n-- | insertAt 10 \"!\" [\"Hello\"] = Nothing\n-- | ```\n-- |\ninsertAt :: forall a. Int -> a -> Array a -> Maybe (Array a)\ninsertAt = runFn5 _insertAt Just Nothing\n\nforeign import _insertAt\n  :: forall a\n   . Fn5\n       (forall b. b -> Maybe b)\n       (forall b. Maybe b)\n       Int\n       a\n       (Array a)\n       (Maybe (Array a))\n\n-- | Delete the element at the specified index, creating a new array, or\n-- | returning `Nothing` if the index is out of bounds.\n-- |\n-- | ```purescript\n-- | deleteAt 0 [\"Hello\", \"World\"] = Just [\"World\"]\n-- | deleteAt 10 [\"Hello\", \"World\"] = Nothing\n-- | ```\n-- |\ndeleteAt :: forall a. Int -> Array a -> Maybe (Array a)\ndeleteAt = runFn4 _deleteAt Just Nothing\n\nforeign import _deleteAt\n  :: forall a\n   . Fn4\n       (forall b. b -> Maybe b)\n       (forall b. Maybe b)\n       Int\n       (Array a)\n       (Maybe (Array a))\n\n-- | Change the element at the specified index, creating a new array, or\n-- | returning `Nothing` if the index is out of bounds.\n-- |\n-- | ```purescript\n-- | updateAt 1 \"World\" [\"Hello\", \"Earth\"] = Just [\"Hello\", \"World\"]\n-- | updateAt 10 \"World\" [\"Hello\", \"Earth\"] = Nothing\n-- | ```\n-- |\nupdateAt :: forall a. Int -> a -> Array a -> Maybe (Array a)\nupdateAt = runFn5 _updateAt Just Nothing\n\nforeign import _updateAt\n  :: forall a\n   . Fn5\n       (forall b. b -> Maybe b)\n       (forall b. Maybe b)\n       Int\n       a\n       (Array a)\n       (Maybe (Array a))\n\n-- | Apply a function to the element at the specified index, creating a new\n-- | array, or returning `Nothing` if the index is out of bounds.\n-- |\n-- | ```purescript\n-- | modifyAt 1 toUpper [\"Hello\", \"World\"] = Just [\"Hello\", \"WORLD\"]\n-- | modifyAt 10 toUpper [\"Hello\", \"World\"] = Nothing\n-- | ```\n-- |\nmodifyAt :: forall a. Int -> (a -> a) -> Array a -> Maybe (Array a)\nmodifyAt i f xs = maybe Nothing go (xs !! i)\n  where\n  go x = updateAt i (f x) xs\n\n-- | Update or delete the element at the specified index by applying a\n-- | function to the current value, returning a new array or `Nothing` if the\n-- | index is out-of-bounds.\n-- |\n-- | ```purescript\n-- | alterAt 1 (stripSuffix $ Pattern \"!\") [\"Hello\", \"World!\"]\n-- |    = Just [\"Hello\", \"World\"]\n-- |\n-- | alterAt 1 (stripSuffix $ Pattern \"!!!!!\") [\"Hello\", \"World!\"]\n-- |    = Just [\"Hello\"]\n-- |\n-- | alterAt 10 (stripSuffix $ Pattern \"!\") [\"Hello\", \"World!\"] = Nothing\n-- | ```\n-- |\nalterAt :: forall a. Int -> (a -> Maybe a) -> Array a -> Maybe (Array a)\nalterAt i f xs = maybe Nothing go (xs !! i)\n  where\n  go x = case f x of\n    Nothing -> deleteAt i xs\n    Just x' -> updateAt i x' xs\n\n--------------------------------------------------------------------------------\n-- Transformations -------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Inserts the given element in between each element in the array. The array\n-- | must have two or more elements for this operation to take effect.\n-- |\n-- | ```purescript\n-- | intersperse \" \" [ \"a\", \"b\" ] == [ \"a\", \" \", \"b\" ]\n-- | intersperse 0 [ 1, 2, 3, 4, 5 ] == [ 1, 0, 2, 0, 3, 0, 4, 0, 5 ]\n-- | ```\n-- |\n-- | If the array has less than two elements, the input array is returned.\n-- | ```purescript\n-- | intersperse \" \" [] == []\n-- | intersperse \" \" [\"a\"] == [\"a\"]\n-- | ```\nintersperse :: forall a. a -> Array a -> Array a\nintersperse a arr = case length arr of\n  len\n    | len < 2 -> arr\n    | otherwise -> STA.run do\n        let unsafeGetElem idx = unsafePartial (unsafeIndex arr idx)\n        out <- STA.new\n        _ <- STA.push (unsafeGetElem 0) out\n        ST.for 1 len \\idx -> do\n          _ <- STA.push a out\n          void (STA.push (unsafeGetElem idx) out)\n        pure out\n\n-- | Reverse an array, creating a new array.\n-- |\n-- | ```purescript\n-- | reverse [] = []\n-- | reverse [1, 2, 3] = [3, 2, 1]\n-- | ```\n-- |\nforeign import reverse :: forall a. Array a -> Array a\n\n-- | Flatten an array of arrays, creating a new array.\n-- |\n-- | ```purescript\n-- | concat [[1, 2, 3], [], [4, 5, 6]] = [1, 2, 3, 4, 5, 6]\n-- | ```\n-- |\nforeign import concat :: forall a. Array (Array a) -> Array a\n\n-- | Apply a function to each element in an array, and flatten the results\n-- | into a single, new array.\n-- |\n-- | ```purescript\n-- | concatMap (split $ Pattern \" \") [\"Hello World\", \"other thing\"]\n-- |    = [\"Hello\", \"World\", \"other\", \"thing\"]\n-- | ```\n-- |\nconcatMap :: forall a b. (a -> Array b) -> Array a -> Array b\nconcatMap = flip bind\n\n-- | Filter an array, keeping the elements which satisfy a predicate function,\n-- | creating a new array.\n-- |\n-- | ```purescript\n-- | filter (_ > 0) [-1, 4, -5, 7] = [4, 7]\n-- | ```\n-- |\nfilter :: forall a. (a -> Boolean) -> Array a -> Array a\nfilter = runFn2 filterImpl\n\nforeign import filterImpl\n  :: forall a\n   . Fn2 (a -> Boolean) (Array a) (Array a)\n\n-- | Partition an array using a predicate function, creating a set of\n-- | new arrays. One for the values satisfying the predicate function\n-- | and one for values that don't.\n-- |\n-- | ```purescript\n-- | partition (_ > 0) [-1, 4, -5, 7] = { yes: [4, 7], no: [-1, -5] }\n-- | ```\n-- |\npartition\n  :: forall a\n   . (a -> Boolean)\n  -> Array a\n  -> { yes :: Array a, no :: Array a }\npartition = runFn2 partitionImpl\n\nforeign import partitionImpl\n  :: forall a\n   . Fn2 (a -> Boolean) (Array a) { yes :: Array a, no :: Array a }\n\n-- | Splits an array into two subarrays, where `before` contains the elements\n-- | up to (but not including) the given index, and `after` contains the rest\n-- | of the elements, from that index on.\n-- |\n-- | ```purescript\n-- | >>> splitAt 3 [1, 2, 3, 4, 5]\n-- | { before: [1, 2, 3], after: [4, 5] }\n-- | ```\n-- |\n-- | Thus, the length of `(splitAt i arr).before` will equal either `i` or\n-- | `length arr`, if that is shorter. (Or if `i` is negative the length will\n-- | be 0.)\n-- |\n-- | ```purescript\n-- | splitAt 2 ([] :: Array Int) == { before: [], after: [] }\n-- | splitAt 3 [1, 2, 3, 4, 5] == { before: [1, 2, 3], after: [4, 5] }\n-- | ```\nsplitAt :: forall a. Int -> Array a -> { before :: Array a, after :: Array a }\nsplitAt i xs | i <= 0 = { before: [], after: xs }\nsplitAt i xs = { before: slice 0 i xs, after: slice i (length xs) xs }\n\n-- | Filter where the predicate returns a `Boolean` in some `Applicative`.\n-- |\n-- | ```purescript\n-- | powerSet :: forall a. Array a -> Array (Array a)\n-- | powerSet = filterA (const [true, false])\n-- | ```\nfilterA :: forall a f. Applicative f => (a -> f Boolean) -> Array a -> f (Array a)\nfilterA p =\n  traverse (\\x -> Tuple x <$> p x)\n    >>> map (mapMaybe (\\(Tuple x b) -> if b then Just x else Nothing))\n\n-- | Apply a function to each element in an array, keeping only the results\n-- | which contain a value, creating a new array.\n-- |\n-- | ```purescript\n-- | parseEmail :: String -> Maybe Email\n-- | parseEmail = ...\n-- |\n-- | mapMaybe parseEmail [\"a.com\", \"hello@example.com\", \"--\"]\n-- |    = [Email {user: \"hello\", domain: \"example.com\"}]\n-- | ```\n-- |\nmapMaybe :: forall a b. (a -> Maybe b) -> Array a -> Array b\nmapMaybe f = concatMap (maybe [] singleton <<< f)\n\n-- | Filter an array of optional values, keeping only the elements which contain\n-- | a value, creating a new array.\n-- |\n-- | ```purescript\n-- | catMaybes [Nothing, Just 2, Nothing, Just 4] = [2, 4]\n-- | ```\n-- |\ncatMaybes :: forall a. Array (Maybe a) -> Array a\ncatMaybes = mapMaybe identity\n\n-- | Apply a function to each element in an array, supplying a generated\n-- | zero-based index integer along with the element, creating an array\n-- | with the new elements.\n-- |\n-- | ```purescript\n-- | prefixIndex index element = show index <> element\n-- |\n-- | mapWithIndex prefixIndex [\"Hello\", \"World\"] = [\"0Hello\", \"1World\"]\n-- | ```\n-- |\nmapWithIndex :: forall a b. (Int -> a -> b) -> Array a -> Array b\nmapWithIndex = FWI.mapWithIndex\n\n-- | Change the elements at the specified indices in index/value pairs.\n-- | Out-of-bounds indices will have no effect.\n-- |\n-- | ```purescript\n-- | updates = [Tuple 0 \"Hi\", Tuple 2 \".\" , Tuple 10 \"foobar\"]\n-- |\n-- | updateAtIndices updates [\"Hello\", \"World\", \"!\"] = [\"Hi\", \"World\", \".\"]\n-- | ```\n-- |\nupdateAtIndices :: forall t a. Foldable t => t (Tuple Int a) -> Array a -> Array a\nupdateAtIndices us xs =\n  ST.run (STA.withArray (\\res -> traverse_ (\\(Tuple i a) -> STA.poke i a res) us) xs)\n\n-- | Apply a function to the element at the specified indices,\n-- | creating a new array. Out-of-bounds indices will have no effect.\n-- |\n-- | ```purescript\n-- | indices = [1, 3]\n-- | modifyAtIndices indices toUpper [\"Hello\", \"World\", \"and\", \"others\"]\n-- |    = [\"Hello\", \"WORLD\", \"and\", \"OTHERS\"]\n-- | ```\n-- |\nmodifyAtIndices :: forall t a. Foldable t => t Int -> (a -> a) -> Array a -> Array a\nmodifyAtIndices is f xs =\n  ST.run (STA.withArray (\\res -> traverse_ (\\i -> STA.modify i f res) is) xs)\n\nfoldl :: forall a b. (b -> a -> b) -> b -> Array a -> b\nfoldl = F.foldl\n\nfoldr :: forall a b. (a -> b -> b) -> b -> Array a -> b\nfoldr = F.foldr\n\nfoldMap :: forall a m. Monoid m => (a -> m) -> Array a -> m\nfoldMap = F.foldMap\n\nfold :: forall m. Monoid m => Array m -> m\nfold = F.fold\n\nintercalate :: forall a. Monoid a => a -> Array a -> a\nintercalate = F.intercalate\n\n-- | The 'transpose' function transposes the rows and columns of its argument.\n-- | For example,\n-- |\n-- | ```purescript\n-- | transpose \n-- |   [ [1, 2, 3]\n-- |   , [4, 5, 6]\n-- |   ] == \n-- |   [ [1, 4]\n-- |   , [2, 5]\n-- |   , [3, 6]\n-- |   ]\n-- | ```\n-- |\n-- | If some of the rows are shorter than the following rows, their elements are skipped:\n-- |\n-- | ```purescript\n-- | transpose \n-- |   [ [10, 11]\n-- |   , [20]\n-- |   , [30, 31, 32]\n-- |   ] == \n-- |   [ [10, 20, 30]\n-- |   , [11, 31]\n-- |   , [32]\n-- |   ]\n-- | ```\ntranspose :: forall a. Array (Array a) -> Array (Array a)\ntranspose xs = go 0 []\n  where\n  go :: Int -> Array (Array a) -> Array (Array a)\n  go idx allArrays = case buildNext idx of\n    Nothing -> allArrays\n    Just next -> go (idx + 1) (snoc allArrays next)\n\n  buildNext :: Int -> Maybe (Array a)\n  buildNext idx = do\n    xs # flip foldl Nothing \\acc nextArr -> do\n      maybe acc (\\el -> Just $ maybe [ el ] (flip snoc el) acc) $ index nextArr idx\n\n-- | Fold a data structure from the left, keeping all intermediate results\n-- | instead of only the final result. Note that the initial value does not\n-- | appear in the result (unlike Haskell's `Prelude.scanl`).\n-- |\n-- | ```\n-- | scanl (+) 0  [1,2,3] = [1,3,6]\n-- | scanl (-) 10 [1,2,3] = [9,7,4]\n-- | ```\nscanl :: forall a b. (b -> a -> b) -> b -> Array a -> Array b\nscanl = runFn3 scanlImpl\n\nforeign import scanlImpl :: forall a b. Fn3 (b -> a -> b) b (Array a) (Array b)\n\n-- | Fold a data structure from the right, keeping all intermediate results\n-- | instead of only the final result. Note that the initial value does not\n-- | appear in the result (unlike Haskell's `Prelude.scanr`).\n-- |\n-- | ```\n-- | scanr (+) 0 [1,2,3] = [6,5,3]\n-- | scanr (flip (-)) 10 [1,2,3] = [4,5,7]\n-- | ```\nscanr :: forall a b. (a -> b -> b) -> b -> Array a -> Array b\nscanr = runFn3 scanrImpl\n\nforeign import scanrImpl :: forall a b. Fn3 (a -> b -> b) b (Array a) (Array b)\n\n--------------------------------------------------------------------------------\n-- Sorting ---------------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Sort the elements of an array in increasing order, creating a new array.\n-- | Sorting is stable: the order of equal elements is preserved.\n-- |\n-- | ```purescript\n-- | sort [2, -3, 1] = [-3, 1, 2]\n-- | ```\n-- |\nsort :: forall a. Ord a => Array a -> Array a\nsort xs = sortBy compare xs\n\n-- | Sort the elements of an array in increasing order, where elements are\n-- | compared using the specified partial ordering, creating a new array.\n-- | Sorting is stable: the order of elements is preserved if they are equal\n-- | according to the specified partial ordering.\n-- |\n-- | ```purescript\n-- | compareLength a b = compare (length a) (length b)\n-- | sortBy compareLength [[1, 2, 3], [7, 9], [-2]] = [[-2],[7,9],[1,2,3]]\n-- | ```\n-- |\nsortBy :: forall a. (a -> a -> Ordering) -> Array a -> Array a\nsortBy comp = runFn3 sortByImpl comp case _ of\n  GT -> 1\n  EQ -> 0\n  LT -> -1\n\n-- | Sort the elements of an array in increasing order, where elements are\n-- | sorted based on a projection. Sorting is stable: the order of elements is\n-- | preserved if they are equal according to the projection.\n-- |\n-- | ```purescript\n-- | sortWith (_.age) [{name: \"Alice\", age: 42}, {name: \"Bob\", age: 21}]\n-- |    = [{name: \"Bob\", age: 21}, {name: \"Alice\", age: 42}]\n-- | ```\n-- |\nsortWith :: forall a b. Ord b => (a -> b) -> Array a -> Array a\nsortWith f = sortBy (comparing f)\n\nforeign import sortByImpl :: forall a. Fn3 (a -> a -> Ordering) (Ordering -> Int) (Array a) (Array a)\n\n--------------------------------------------------------------------------------\n-- Subarrays -------------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Extract a subarray by a start and end index.\n-- |\n-- | ```purescript\n-- | letters = [\"a\", \"b\", \"c\"]\n-- | slice 1 3 letters = [\"b\", \"c\"]\n-- | slice 5 7 letters = []\n-- | slice 4 1 letters = []\n-- | ```\n-- |\nslice :: forall a. Int -> Int -> Array a -> Array a\nslice = runFn3 sliceImpl\n\nforeign import sliceImpl :: forall a. Fn3 Int Int (Array a) (Array a)\n\n-- | Keep only a number of elements from the start of an array, creating a new\n-- | array.\n-- |\n-- | ```purescript\n-- | letters = [\"a\", \"b\", \"c\"]\n-- |\n-- | take 2 letters = [\"a\", \"b\"]\n-- | take 100 letters = [\"a\", \"b\", \"c\"]\n-- | ```\n-- |\ntake :: forall a. Int -> Array a -> Array a\ntake n xs = if n < 1 then [] else slice 0 n xs\n\n-- | Keep only a number of elements from the end of an array, creating a new\n-- | array.\n-- |\n-- | ```purescript\n-- | letters = [\"a\", \"b\", \"c\"]\n-- |\n-- | takeEnd 2 letters = [\"b\", \"c\"]\n-- | takeEnd 100 letters = [\"a\", \"b\", \"c\"]\n-- | ```\n-- |\ntakeEnd :: forall a. Int -> Array a -> Array a\ntakeEnd n xs = drop (length xs - n) xs\n\n-- | Calculate the longest initial subarray for which all element satisfy the\n-- | specified predicate, creating a new array.\n-- |\n-- | ```purescript\n-- | takeWhile (_ > 0) [4, 1, 0, -4, 5] = [4, 1]\n-- | takeWhile (_ > 0) [-1, 4] = []\n-- | ```\n-- |\ntakeWhile :: forall a. (a -> Boolean) -> Array a -> Array a\ntakeWhile p xs = (span p xs).init\n\n-- | Drop a number of elements from the start of an array, creating a new array.\n-- |\n-- | ```purescript\n-- | letters = [\"a\", \"b\", \"c\", \"d\"]\n-- |\n-- | drop 2 letters = [\"c\", \"d\"]\n-- | drop 10 letters = []\n-- | ```\n-- |\ndrop :: forall a. Int -> Array a -> Array a\ndrop n xs = if n < 1 then xs else slice n (length xs) xs\n\n-- | Drop a number of elements from the end of an array, creating a new array.\n-- |\n-- | ```purescript\n-- | letters = [\"a\", \"b\", \"c\", \"d\"]\n-- |\n-- | dropEnd 2 letters = [\"a\", \"b\"]\n-- | dropEnd 10 letters = []\n-- | ```\n-- |\ndropEnd :: forall a. Int -> Array a -> Array a\ndropEnd n xs = take (length xs - n) xs\n\n-- | Remove the longest initial subarray for which all element satisfy the\n-- | specified predicate, creating a new array.\n-- |\n-- | ```purescript\n-- | dropWhile (_ < 0) [-3, -1, 0, 4, -6] = [0, 4, -6]\n-- | ```\n-- |\ndropWhile :: forall a. (a -> Boolean) -> Array a -> Array a\ndropWhile p xs = (span p xs).rest\n\n-- | Split an array into two parts:\n-- |\n-- | 1. the longest initial subarray for which all elements satisfy the\n-- |    specified predicate\n-- | 2. the remaining elements\n-- |\n-- | ```purescript\n-- | span (\\n -> n % 2 == 1) [1,3,2,4,5] == { init: [1,3], rest: [2,4,5] }\n-- | ```\n-- |\n-- | Running time: `O(n)`.\nspan\n  :: forall a\n   . (a -> Boolean)\n  -> Array a\n  -> { init :: Array a, rest :: Array a }\nspan p arr =\n  case breakIndex of\n    Just 0 ->\n      { init: [], rest: arr }\n    Just i ->\n      { init: slice 0 i arr, rest: slice i (length arr) arr }\n    Nothing ->\n      { init: arr, rest: [] }\n  where\n  breakIndex = go 0\n  go i =\n    -- This looks like a good opportunity to use the Monad Maybe instance,\n    -- but it's important to write out an explicit case expression here in\n    -- order to ensure that TCO is triggered.\n    case index arr i of\n      Just x -> if p x then go (i + 1) else Just i\n      Nothing -> Nothing\n\n-- | Group equal, consecutive elements of an array into arrays.\n-- |\n-- | ```purescript\n-- | group [1, 1, 2, 2, 1] == [NonEmptyArray [1, 1], NonEmptyArray [2, 2], NonEmptyArray [1]]\n-- | ```\ngroup :: forall a. Eq a => Array a -> Array (NonEmptyArray a)\ngroup xs = groupBy eq xs\n\n-- | Group equal elements of an array into arrays.\n-- |\n-- | ```purescript\n-- | groupAll [1, 1, 2, 2, 1] == [NonEmptyArray [1, 1, 1], NonEmptyArray [2, 2]]\n-- | ```\ngroupAll :: forall a. Ord a => Array a -> Array (NonEmptyArray a)\ngroupAll = groupAllBy compare\n\n-- | Group equal, consecutive elements of an array into arrays, using the\n-- | specified equivalence relation to determine equality.\n-- |\n-- | ```purescript\n-- | groupBy (\\a b -> odd a && odd b) [1, 3, 2, 4, 3, 3]\n-- |    = [NonEmptyArray [1, 3], NonEmptyArray [2], NonEmptyArray [4], NonEmptyArray [3, 3]]\n-- | ```\n-- |\ngroupBy :: forall a. (a -> a -> Boolean) -> Array a -> Array (NonEmptyArray a)\ngroupBy op xs =\n  ST.run do\n    result <- STA.new\n    iter <- STAI.iterator (xs !! _)\n    STAI.iterate iter \\x -> void do\n      sub <- STA.new\n      _ <- STA.push x sub\n      STAI.pushWhile (op x) iter sub\n      grp <- STA.unsafeFreeze sub\n      STA.push (NonEmptyArray grp) result\n    STA.unsafeFreeze result\n\n-- | Group equal elements of an array into arrays, using the specified\n-- | comparison function to determine equality.\n-- |\n-- | ```purescript\n-- | groupAllBy (comparing Down) [1, 3, 2, 4, 3, 3]\n-- |    = [NonEmptyArray [4], NonEmptyArray [3, 3, 3], NonEmptyArray [2], NonEmptyArray [1]]\n-- | ```\n-- |\ngroupAllBy :: forall a. (a -> a -> Ordering) -> Array a -> Array (NonEmptyArray a)\ngroupAllBy cmp = groupBy (\\x y -> cmp x y == EQ) <<< sortBy cmp\n\n-- | Remove the duplicates from an array, creating a new array.\n-- |\n-- | ```purescript\n-- | nub [1, 2, 1, 3, 3] = [1, 2, 3]\n-- | ```\n-- |\nnub :: forall a. Ord a => Array a -> Array a\nnub = nubBy compare\n\n-- | Remove the duplicates from an array, creating a new array.\n-- |\n-- | This less efficient version of `nub` only requires an `Eq` instance.\n-- |\n-- | ```purescript\n-- | nubEq [1, 2, 1, 3, 3] = [1, 2, 3]\n-- | ```\n-- |\nnubEq :: forall a. Eq a => Array a -> Array a\nnubEq = nubByEq eq\n\n-- | Remove the duplicates from an array, where element equality is determined\n-- | by the specified ordering, creating a new array.\n-- |\n-- | ```purescript\n-- | nubBy compare [1, 3, 4, 2, 2, 1] == [1, 3, 4, 2]\n-- | ```\n-- |\nnubBy :: forall a. (a -> a -> Ordering) -> Array a -> Array a\nnubBy comp xs = case head indexedAndSorted of\n  Nothing -> []\n  Just x -> map snd $ sortWith fst $ ST.run do\n    -- TODO: use NonEmptyArrays here to avoid partial functions\n    result <- STA.unsafeThaw $ singleton x\n    ST.foreach indexedAndSorted \\pair@(Tuple _ x') -> do\n      lst <- snd <<< unsafePartial (fromJust <<< last) <$> STA.unsafeFreeze result\n      when (comp lst x' /= EQ) $ void $ STA.push pair result\n    STA.unsafeFreeze result\n  where\n  indexedAndSorted :: Array (Tuple Int a)\n  indexedAndSorted = sortBy (\\x y -> comp (snd x) (snd y))\n    (mapWithIndex Tuple xs)\n\n-- | Remove the duplicates from an array, where element equality is determined\n-- | by the specified equivalence relation, creating a new array.\n-- |\n-- | This less efficient version of `nubBy` only requires an equivalence\n-- | relation.\n-- |\n-- | ```purescript\n-- | mod3eq a b = a `mod` 3 == b `mod` 3\n-- | nubByEq mod3eq [1, 3, 4, 5, 6] = [1, 3, 5]\n-- | ```\n-- |\nnubByEq :: forall a. (a -> a -> Boolean) -> Array a -> Array a\nnubByEq eq xs = ST.run do\n  arr <- STA.new\n  ST.foreach xs \\x -> do\n    e <- not <<< any (_ `eq` x) <$> (STA.unsafeFreeze arr)\n    when e $ void $ STA.push x arr\n  STA.unsafeFreeze arr\n\n-- | Calculate the union of two arrays. Note that duplicates in the first array\n-- | are preserved while duplicates in the second array are removed.\n-- |\n-- | Running time: `O(n^2)`\n-- |\n-- | ```purescript\n-- | union [1, 2, 1, 1] [3, 3, 3, 4] = [1, 2, 1, 1, 3, 4]\n-- | ```\n-- |\nunion :: forall a. Eq a => Array a -> Array a -> Array a\nunion = unionBy (==)\n\n-- | Calculate the union of two arrays, using the specified function to\n-- | determine equality of elements. Note that duplicates in the first array\n-- | are preserved while duplicates in the second array are removed.\n-- |\n-- | ```purescript\n-- | mod3eq a b = a `mod` 3 == b `mod` 3\n-- | unionBy mod3eq [1, 5, 1, 2] [3, 4, 3, 3] = [1, 5, 1, 2, 3]\n-- | ```\n-- |\nunionBy :: forall a. (a -> a -> Boolean) -> Array a -> Array a -> Array a\nunionBy eq xs ys = xs <> foldl (flip (deleteBy eq)) (nubByEq eq ys) xs\n\n-- | Delete the first element of an array which is equal to the specified value,\n-- | creating a new array.\n-- |\n-- | ```purescript\n-- | delete 7 [1, 7, 3, 7] = [1, 3, 7]\n-- | delete 7 [1, 2, 3] = [1, 2, 3]\n-- | ```\n-- |\n-- | Running time: `O(n)`\ndelete :: forall a. Eq a => a -> Array a -> Array a\ndelete = deleteBy eq\n\n-- | Delete the first element of an array which matches the specified value,\n-- | under the equivalence relation provided in the first argument, creating a\n-- | new array.\n-- |\n-- | ```purescript\n-- | mod3eq a b = a `mod` 3 == b `mod` 3\n-- | deleteBy mod3eq 6 [1, 3, 4, 3] = [1, 4, 3]\n-- | ```\n-- |\ndeleteBy :: forall a. (a -> a -> Boolean) -> a -> Array a -> Array a\ndeleteBy _ _ [] = []\ndeleteBy eq x ys = maybe ys (\\i -> unsafePartial $ fromJust (deleteAt i ys)) (findIndex (eq x) ys)\n\n-- | Delete the first occurrence of each element in the second array from the\n-- | first array, creating a new array.\n-- |\n-- | ```purescript\n-- | difference [2, 1] [2, 3] = [1]\n-- | ```\n-- |\n-- | Running time: `O(n*m)`, where n is the length of the first array, and m is\n-- | the length of the second.\ndifference :: forall a. Eq a => Array a -> Array a -> Array a\ndifference = foldr delete\n\ninfix 5 difference as \\\\\n\n-- | Calculate the intersection of two arrays, creating a new array. Note that\n-- | duplicates in the first array are preserved while duplicates in the second\n-- | array are removed.\n-- |\n-- | ```purescript\n-- | intersect [1, 1, 2] [2, 2, 1] = [1, 1, 2]\n-- | ```\n-- |\nintersect :: forall a. Eq a => Array a -> Array a -> Array a\nintersect = intersectBy eq\n\n-- | Calculate the intersection of two arrays, using the specified equivalence\n-- | relation to compare elements, creating a new array. Note that duplicates\n-- | in the first array are preserved while duplicates in the second array are\n-- | removed.\n-- |\n-- | ```purescript\n-- | mod3eq a b = a `mod` 3 == b `mod` 3\n-- | intersectBy mod3eq [1, 2, 3] [4, 6, 7] = [1, 3]\n-- | ```\n-- |\nintersectBy :: forall a. (a -> a -> Boolean) -> Array a -> Array a -> Array a\nintersectBy eq xs ys = filter (\\x -> isJust (findIndex (eq x) ys)) xs\n\n-- | Apply a function to pairs of elements at the same index in two arrays,\n-- | collecting the results in a new array.\n-- |\n-- | If one array is longer, elements will be discarded from the longer array.\n-- |\n-- | For example\n-- |\n-- | ```purescript\n-- | zipWith (*) [1, 2, 3] [4, 5, 6, 7] == [4, 10, 18]\n-- | ```\nzipWith\n  :: forall a b c\n   . (a -> b -> c)\n  -> Array a\n  -> Array b\n  -> Array c\nzipWith = runFn3 zipWithImpl\n\nforeign import zipWithImpl\n  :: forall a b c\n   . Fn3\n       (a -> b -> c)\n       (Array a)\n       (Array b)\n       (Array c)\n\n-- | A generalization of `zipWith` which accumulates results in some\n-- | `Applicative` functor.\n-- |\n-- | ```purescript\n-- | sndChars = zipWithA (\\a b -> charAt 2 (a <> b))\n-- | sndChars [\"a\", \"b\"] [\"A\", \"B\"] = Nothing -- since \"aA\" has no 3rd char\n-- | sndChars [\"aa\", \"b\"] [\"AA\", \"BBB\"] = Just ['A', 'B']\n-- | ```\n-- |\nzipWithA\n  :: forall m a b c\n   . Applicative m\n  => (a -> b -> m c)\n  -> Array a\n  -> Array b\n  -> m (Array c)\nzipWithA f xs ys = sequence (zipWith f xs ys)\n\n-- | Takes two arrays and returns an array of corresponding pairs.\n-- | If one input array is short, excess elements of the longer array are\n-- | discarded.\n-- |\n-- | ```purescript\n-- | zip [1, 2, 3] [\"a\", \"b\"] = [Tuple 1 \"a\", Tuple 2 \"b\"]\n-- | ```\n-- |\nzip :: forall a b. Array a -> Array b -> Array (Tuple a b)\nzip = zipWith Tuple\n\n-- | Transforms an array of pairs into an array of first components and an\n-- | array of second components.\n-- |\n-- | ```purescript\n-- | unzip [Tuple 1 \"a\", Tuple 2 \"b\"] = Tuple [1, 2] [\"a\", \"b\"]\n-- | ```\n-- |\nunzip :: forall a b. Array (Tuple a b) -> Tuple (Array a) (Array b)\nunzip xs =\n  ST.run do\n    fsts <- STA.new\n    snds <- STA.new\n    iter <- STAI.iterator (xs !! _)\n    STAI.iterate iter \\(Tuple fst snd) -> do\n      void $ STA.push fst fsts\n      void $ STA.push snd snds\n    fsts' <- STA.unsafeFreeze fsts\n    snds' <- STA.unsafeFreeze snds\n    pure $ Tuple fsts' snds'\n\n-- | Returns true if at least one array element satisfies the given predicate,\n-- | iterating the array only as necessary and stopping as soon as the predicate\n-- | yields true.\n-- |\n-- | ```purescript\n-- | any (_ > 0) [] = False\n-- | any (_ > 0) [-1, 0, 1] = True\n-- | any (_ > 0) [-1, -2, -3] = False\n-- | ```\nany :: forall a. (a -> Boolean) -> Array a -> Boolean\nany = runFn2 anyImpl\n\nforeign import anyImpl :: forall a. Fn2 (a -> Boolean) (Array a) Boolean\n\n-- | Returns true if all the array elements satisfy the given predicate.\n-- | iterating the array only as necessary and stopping as soon as the predicate\n-- | yields false.\n-- |\n-- | ```purescript\n-- | all (_ > 0) [] = True\n-- | all (_ > 0) [1, 2, 3] = True\n-- | all (_ > 0) [-1, -2, -3] = False\n-- | ```\nall :: forall a. (a -> Boolean) -> Array a -> Boolean\nall = runFn2 allImpl\n\nforeign import allImpl :: forall a. Fn2 (a -> Boolean) (Array a) Boolean\n\n-- | Perform a fold using a monadic step function.\n-- |\n-- | ```purescript\n-- | foldM (\\x y -> Just (x + y)) 0 [1, 4] = Just 5\n-- | ```\nfoldM :: forall m a b. Monad m => (b -> a -> m b) -> b -> Array a -> m b\nfoldM f b = runFn3 unconsImpl (\\_ -> pure b) (\\a as -> f b a >>= \\b' -> foldM f b' as)\n\nfoldRecM :: forall m a b. MonadRec m => (b -> a -> m b) -> b -> Array a -> m b\nfoldRecM f b array = tailRecM2 go b 0\n  where\n  go res i\n    | i >= length array = pure (Done res)\n    | otherwise = do\n        res' <- f res (unsafePartial (unsafeIndex array i))\n        pure (Loop { a: res', b: i + 1 })\n\n-- | Find the element of an array at the specified index.\n-- |\n-- | ```purescript\n-- | unsafePartial $ unsafeIndex [\"a\", \"b\", \"c\"] 1 = \"b\"\n-- | ```\n-- |\n-- | Using `unsafeIndex` with an out-of-range index will not immediately raise a runtime error.\n-- | Instead, the result will be undefined. Most attempts to subsequently use the result will\n-- | cause a runtime error, of course, but this is not guaranteed, and is dependent on the backend;\n-- | some programs will continue to run as if nothing is wrong. For example, in the JavaScript backend,\n-- | the expression `unsafePartial (unsafeIndex [true] 1)` has type `Boolean`;\n-- | since this expression evaluates to `undefined`, attempting to use it in an `if` statement will cause\n-- | the else branch to be taken.\nunsafeIndex :: forall a. Partial => Array a -> Int -> a\nunsafeIndex = runFn2 unsafeIndexImpl\n\nforeign import unsafeIndexImpl :: forall a. Fn2 (Array a) Int a\n", "export const mkEffectFn1 = function mkEffectFn1(fn) {\n  return function(x) {\n    return fn(x)();\n  };\n};\n\nexport const mkEffectFn2 = function mkEffectFn2(fn) {\n  return function(a, b) {\n    return fn(a)(b)();\n  };\n};\n\nexport const mkEffectFn3 = function mkEffectFn3(fn) {\n  return function(a, b, c) {\n    return fn(a)(b)(c)();\n  };\n};\n\nexport const mkEffectFn4 = function mkEffectFn4(fn) {\n  return function(a, b, c, d) {\n    return fn(a)(b)(c)(d)();\n  };\n};\n\nexport const mkEffectFn5 = function mkEffectFn5(fn) {\n  return function(a, b, c, d, e) {\n    return fn(a)(b)(c)(d)(e)();\n  };\n};\n\nexport const mkEffectFn6 = function mkEffectFn6(fn) {\n  return function(a, b, c, d, e, f) {\n    return fn(a)(b)(c)(d)(e)(f)();\n  };\n};\n\nexport const mkEffectFn7 = function mkEffectFn7(fn) {\n  return function(a, b, c, d, e, f, g) {\n    return fn(a)(b)(c)(d)(e)(f)(g)();\n  };\n};\n\nexport const mkEffectFn8 = function mkEffectFn8(fn) {\n  return function(a, b, c, d, e, f, g, h) {\n    return fn(a)(b)(c)(d)(e)(f)(g)(h)();\n  };\n};\n\nexport const mkEffectFn9 = function mkEffectFn9(fn) {\n  return function(a, b, c, d, e, f, g, h, i) {\n    return fn(a)(b)(c)(d)(e)(f)(g)(h)(i)();\n  };\n};\n\nexport const mkEffectFn10 = function mkEffectFn10(fn) {\n  return function(a, b, c, d, e, f, g, h, i, j) {\n    return fn(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)();\n  };\n};\n\nexport const runEffectFn1 = function runEffectFn1(fn) {\n  return function(a) {\n    return function() {\n      return fn(a);\n    };\n  };\n};\n\nexport const runEffectFn2 = function runEffectFn2(fn) {\n  return function(a) {\n    return function(b) {\n      return function() {\n        return fn(a, b);\n      };\n    };\n  };\n};\n\nexport const runEffectFn3 = function runEffectFn3(fn) {\n  return function(a) {\n    return function(b) {\n      return function(c) {\n        return function() {\n          return fn(a, b, c);\n        };\n      };\n    };\n  };\n};\n\nexport const runEffectFn4 = function runEffectFn4(fn) {\n  return function(a) {\n    return function(b) {\n      return function(c) {\n        return function(d) {\n          return function() {\n            return fn(a, b, c, d);\n          };\n        };\n      };\n    };\n  };\n};\n\nexport const runEffectFn5 = function runEffectFn5(fn) {\n  return function(a) {\n    return function(b) {\n      return function(c) {\n        return function(d) {\n          return function(e) {\n            return function() {\n              return fn(a, b, c, d, e);\n            };\n          };\n        };\n      };\n    };\n  };\n};\n\nexport const runEffectFn6 = function runEffectFn6(fn) {\n  return function(a) {\n    return function(b) {\n      return function(c) {\n        return function(d) {\n          return function(e) {\n            return function(f) {\n              return function() {\n                return fn(a, b, c, d, e, f);\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n};\n\nexport const runEffectFn7 = function runEffectFn7(fn) {\n  return function(a) {\n    return function(b) {\n      return function(c) {\n        return function(d) {\n          return function(e) {\n            return function(f) {\n              return function(g) {\n                return function() {\n                  return fn(a, b, c, d, e, f, g);\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n};\n\nexport const runEffectFn8 = function runEffectFn8(fn) {\n  return function(a) {\n    return function(b) {\n      return function(c) {\n        return function(d) {\n          return function(e) {\n            return function(f) {\n              return function(g) {\n                return function(h) {\n                  return function() {\n                    return fn(a, b, c, d, e, f, g, h);\n                  };\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n};\n\nexport const runEffectFn9 = function runEffectFn9(fn) {\n  return function(a) {\n    return function(b) {\n      return function(c) {\n        return function(d) {\n          return function(e) {\n            return function(f) {\n              return function(g) {\n                return function(h) {\n                  return function(i) {\n                    return function() {\n                      return fn(a, b, c, d, e, f, g, h, i);\n                    };\n                  };\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n};\n\nexport const runEffectFn10 = function runEffectFn10(fn) {\n  return function(a) {\n    return function(b) {\n      return function(c) {\n        return function(d) {\n          return function(e) {\n            return function(f) {\n              return function(g) {\n                return function(h) {\n                  return function(i) {\n                    return function(j) {\n                      return function() {\n                        return fn(a, b, c, d, e, f, g, h, i, j);\n                      };\n                    };\n                  };\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n};\n", "import EventEmitter from \"node:events\";\n\nconst newImpl = function () {\n  return new EventEmitter();\n}\nexport { newImpl as new };\n\n// addEventListener - not implemented; alias to `on`\nexport const unsafeEmitFn = (emitter) => emitter.emit.bind(emitter);\nexport const eventNamesImpl = (emitter) => emitter.eventNames();\nexport const symbolOrStr = (left, right, sym) => typeof sym == \"symbol\" ? left(sym) : right(sym);\nexport const getMaxListenersImpl = (emitter) => emitter.getMaxListeners();\nexport const listenerCountImpl = (emitter, eventName) => emitter.listenerCount(eventName);\n// listeners - not implemented; returned functions cannot be used in type-safe way.\nexport const unsafeOff = (emitter, eventName, cb) => emitter.off(eventName, cb);\nexport const unsafeOn = (emitter, eventName, cb) => emitter.on(eventName, cb);\nexport const unsafeOnce = (emitter, eventName, cb) => emitter.once(eventName, cb);\nexport const unsafePrependListener = (emitter, eventName, cb) => emitter.prependListener(eventName, cb);\nexport const unsafePrependOnceListener = (emitter, eventName, cb) => emitter.prependOnceListener(eventName, cb);\n// removeAllListeners - not implemented; bad practice\n// removeEventListener - not implemented; alias to `off`\nexport const setMaxListenersImpl = (emitter, max) => emitter.setMaxListeners(max);\n// rawListeners - not implemented; returned functions cannot be used in type-safe way.\n\n", "-- | ## Handling events emitted by an `EventEmitter`\n-- |\n-- | One can add callbacks to an `EventEmitter` on two major axes:\n-- | - whether listener is added to the **end** (i.e. `on`) or **start** (i.e. `prependListener`) of the array\n-- | - whether a listener is automatically removed after the first event (i.e. `once` or `prependOnceListener`).\n-- |\n-- | This module provides functions for each of the above 4 callback-adding functions\n-- | If `<fn>` is either `on`, `once`, `prependListener`, or `prependOnceListener`, then this module exposes\n-- | 1. `<fn>` - returns a callback that removes the listener\n-- | 2. `<fn>_` - does not return a callback that can remove the listener\n-- |\n-- | ## Defining events emitted by an `EventEmitter`\n-- |\n-- | Below, we'll provide an example for how to define an event handler for a type. Let's assume the following:\n-- | - There is a type `Foo` that exends `EventEmitter`\n-- | - `Foo` values can handle \"bar\" events\n-- | - a \"bar\" event takes the following callback: `EffectFn2 (Nullable Error) String Unit`\n-- | - the `String` value is always either \"red\", \"green\", or \"blue\"\n-- |\n-- | Then we would write\n-- | ```\n-- | data Color \n-- |   = Red \n-- |   | Green \n-- |   | Blue\n-- |\n-- | -- Note: see docs on `EventHandle` \n-- | -- for the below naming convention justification \n-- | -- of suffixing an event name with `H`.\n-- | barH \n-- |   :: EventHandle \n-- |        Foo \n-- |        (Maybe Error -> Color -> Effect Unit) \n-- |        (EffectFn1 (Nullable Error) String Unit)\n-- | barH = EventHandle \"bar\" $ \\psCb -> \n-- |   mkEffectFn2 \\nullableError str ->\n-- |     psCb (toMaybe nullableError) case str of\n-- |       \"red\" -> Red\n-- |       \"green\" -> Green\n-- |       \"blue\" -> Blue\n-- |       _ -> \n-- |         unsafeCrashWith $ \n-- |           \"Impossible String value for event 'bar': \" <> show str\n-- | ```\n-- |\n-- | ## Emitting events via an `EventEmitter`\n-- |\n-- | Unfortunately, there isn't a good way to emit events safely in PureScript. If one wants to emit an event\n-- | in PureScript code that will be consumed by PureScript code, there are better abstractions to use than `EventEmitter`.\n-- | If one wants to emit an event in PureScript code that will be consumed by JavaScript code, then\n-- | the `unsafeEmitFn` function can be used to call n-ary functions. However, this is very unsafe. See its docs for more context.\nmodule Node.EventEmitter\n  ( EventEmitter\n  , new\n  , SymbolOrStr\n  , eventNames\n  , getMaxListeners\n  , listenerCount\n  , setMaxListeners\n  , setUnlimitedListeners\n  , unsafeEmitFn\n  , EventHandle(..)\n  , newListenerH\n  , removeListenerH\n  , on\n  , on_\n  , once\n  , once_\n  , prependListener\n  , prependListener_\n  , prependOnceListener\n  , prependOnceListener_\n  ) where\n\nimport Prelude\n\nimport Data.Either (Either(..))\nimport Data.Function.Uncurried (Fn3, runFn3)\nimport Effect (Effect)\nimport Effect.Uncurried (EffectFn1, EffectFn2, EffectFn3, EffectFn4, mkEffectFn1, mkEffectFn4, runEffectFn1, runEffectFn2, runEffectFn3, runEffectFn4)\nimport Node.Symbol (JsSymbol)\nimport Unsafe.Coerce (unsafeCoerce)\n\nforeign import data EventEmitter :: Type\n\n-- | Create a new event emitter\nforeign import new :: Effect EventEmitter\n\nforeign import data SymbolOrStr :: Type\n\nforeign import eventNamesImpl :: EventEmitter -> Array SymbolOrStr\n\neventNames :: EventEmitter -> Array (Either JsSymbol String)\neventNames ee = map (\\x -> runFn3 symbolOrStr Left Right x) $ eventNamesImpl ee\n\nforeign import symbolOrStr\n  :: Fn3\n       (forall a. JsSymbol -> Either JsSymbol a)\n       (forall b. String -> Either b String)\n       SymbolOrStr\n       (Either JsSymbol String)\n\nforeign import getMaxListenersImpl :: EffectFn1 EventEmitter Int\n\n-- | By default, an event emitter can only have a maximum of 10 listeners\n-- | for a given event.\ngetMaxListeners :: EventEmitter -> Effect Int\ngetMaxListeners = runEffectFn1 getMaxListenersImpl\n\nforeign import listenerCountImpl :: EffectFn2 EventEmitter String Int\n\nlistenerCount :: EventEmitter -> String -> Effect Int\nlistenerCount emitter eventName = runEffectFn2 listenerCountImpl emitter eventName\n\nforeign import setMaxListenersImpl :: EffectFn2 EventEmitter Int Unit\n\nsetMaxListeners :: Int -> EventEmitter -> Effect Unit\nsetMaxListeners max emitter = runEffectFn2 setMaxListenersImpl emitter max\n\nsetUnlimitedListeners :: EventEmitter -> Effect Unit\nsetUnlimitedListeners = setMaxListeners 0\n\n-- | THIS IS UNSAFE! REALLY UNSAFE!\n-- | Gets the `emit` function for a particular `EventEmitter`, so that one can call n-ary functions.\n-- |\n-- | Given `http2session.goaway([code[, lastStreamID[, opaqueData]]])` as an example...\n-- | - https://nodejs.org/dist/latest-v18.x/docs/api/http2.html#event-goaway\n-- | - https://nodejs.org/dist/latest-v18.x/docs/api/http2.html#http2sessiongoawaycode-laststreamid-opaquedata\n-- |\n-- | We can then write a single function that handles all four cases:\n-- | ```\n-- | goAway\n-- |   :: Http2Session\n-- |   -> Maybe Code\n-- |   -> Maybe LastStreamId\n-- |   -> Maybe OpaqueData\n-- |   -> Effect Unit\n-- | goAway h2s = case _, _, _ of\n-- |   Just c, Just id, Just d ->\n-- |     runEffectFn4 (unsafeEmitFn h2s :: EffectFn4 String Code LastStreamId OpaqueData Unit) \"goaway\" c id d\n-- |   Just c, Just id, Nothing ->\n-- |     -- If you're feeling lucky, omit the type annotations completely\n-- |     runEffectFn3 (unsafeEmitFn h2s) \"goaway\" c id\n-- |   Just c, Nothing, Nothing ->\n-- |     runEffectFn2 (unsafeEmitFn h2s :: EffectFn2 String Code LastStreamId Unit) \"goaway\" c\n-- |   _, _, _ ->\n-- |     runEffectFn1 (unsafeEmitFn h2s :: EffectFn1 String Unit) \"goaway\"\n-- | ```\n-- | \n-- | Synchronously calls each of the listeners registered for the event named `eventName`, \n-- | in the order they were registered, passing the supplied arguments to each.\n-- | Returns `true` if the event had listeners, `false` otherwise.\nforeign import unsafeEmitFn :: forall f. EventEmitter -> f Boolean\n\n-- | Packs all the type information we need to call `on`/`once`/`prependListener`/`prependOnceListener`\n-- | with the correct callback function type.\n-- |\n-- | **Naming convention**: \n-- | If the name of an event is `foo`, \n-- | the corresponding PureScript `EventHandle` value should be called `fooH`.\n-- | The `H` suffix is what prevent name conflicts in two situations:\n-- | 1. similarly-named methods (e.g. the `\"close\"` event and the `close` method)\n-- | 2. PureScript keywords (e.g. the `\"data\"` event)\n-- |\n-- | If an event, `foo`, can have two different kinds of callbacks, (e.g. See `Node.Stream`'s `data` event),\n-- | one of two things should happen:\n-- | 1. a suffix should follow the `H` to distinguish between the two (e.g. `dataHString`/`dataHBuffer`)\n-- | 2. a prime character (i.e. `'`) should follow the `H` to distinguish between the two (e.g. `dataH`/`dataH'`)\ndata EventHandle :: Type -> Type -> Type -> Type\ndata EventHandle emitterType pureScriptCallback javaScriptCallback =\n  EventHandle String (pureScriptCallback -> javaScriptCallback)\n\ntype role EventHandle representational representational representational\n\nnewListenerH :: EventHandle EventEmitter (Either JsSymbol String -> Effect Unit) (EffectFn1 SymbolOrStr Unit)\nnewListenerH = EventHandle \"newListener\" $ \\cb -> mkEffectFn1 \\jsSymbol ->\n  cb $ runFn3 symbolOrStr Left Right jsSymbol\n\nremoveListenerH :: EventHandle EventEmitter (Either JsSymbol String -> Effect Unit) (EffectFn1 SymbolOrStr Unit)\nremoveListenerH = EventHandle \"removeListener\" $ \\cb -> mkEffectFn1 \\jsSymbol ->\n  cb $ runFn3 symbolOrStr Left Right jsSymbol\n\n-- | Adds the listener to the **end** of the `listeners` array.\n-- | Returns a callback that will remove the listener from the event emitter's `listeners` array.\n-- | If the listener removal callback isn't needed, use `on_`.\n-- |\n-- | Intended usage:\n-- | ```\n-- | removeLoggerCallback <- eventEmitter # on errorHandle \\error -> do\n-- |   log $ \"Got error: \" <> Exception.message error\n-- |   log $ \"This listener will now be removed.\"\n-- | -- sometime later...\n-- | removeLoggerCallback\n-- | ```\non\n  :: forall emitter psCb jsCb\n   . EventHandle emitter psCb jsCb\n  -> psCb\n  -> emitter\n  -> Effect (Effect Unit)\non (EventHandle eventName toJsCb) psCb eventEmitter =\n  runEffectFn4 subscribeSameFunction unsafeOn (unsafeCoerce eventEmitter) eventName $ toJsCb psCb\n\n-- | Adds the callback to the **end** of the `listeners` array and provides no way to remove the listener in the future.\n-- | If you need a callback to remove the listener in the future, use `on`.\n-- | Intended usage:\n-- | ```\n-- | eventEmitter # on_ errorHandle  \\error -> do\n-- |   log $ \"Got error: \" <> Exception.message error\n-- | ```\non_\n  :: forall emitter psCb jsCb\n   . EventHandle emitter psCb jsCb\n  -> psCb\n  -> emitter\n  -> Effect Unit\non_ (EventHandle eventName toJsCb) psCb eventEmitter =\n  runEffectFn3 unsafeOn (unsafeCoerce eventEmitter) eventName $ toJsCb psCb\n\n-- | Adds the listener to the **end** of the `listeners` array. The listener will be removed after it is invoked once.\n-- | Returns a callback that will remove the listener from the event emitter's listeners array.\n-- | If the listener removal callback isn't needed, use `once_`.\n-- |\n-- | Intended usage:\n-- | ```\n-- | removeLoggerCallback <- eventEmitter # once errorHandle \\error -> do\n-- |   log $ \"Got error: \" <> Exception.message error\n-- |   log $ \"This listener will now be removed.\"\n-- | -- sometime later...\n-- | removeLoggerCallback\n-- | ```\nonce\n  :: forall emitter psCb jsCb\n   . EventHandle emitter psCb jsCb\n  -> psCb\n  -> emitter\n  -> Effect (Effect Unit)\nonce (EventHandle eventName toJsCb) psCb eventEmitter =\n  runEffectFn4 subscribeSameFunction unsafeOnce (unsafeCoerce eventEmitter) eventName $ toJsCb psCb\n\n-- | Adds the listener to the **end** of the `listeners` array. The listener will be removed after it is invoked once.\n-- | Returns a callback that will remove the listener from the event emitter's listeners array.\n-- | If you need a callback to remove the listener in the future, use `once`.\n-- |\n-- | Intended usage:\n-- | ```\n-- | eventEmitter # once_ errorHandle \\error -> do\n-- |   log $ \"Got error: \" <> Exception.message error\n-- | ```\nonce_\n  :: forall emitter psCb jsCb\n   . EventHandle emitter psCb jsCb\n  -> psCb\n  -> emitter\n  -> Effect Unit\nonce_ (EventHandle eventName toJsCb) psCb eventEmitter =\n  runEffectFn3 unsafeOnce (unsafeCoerce eventEmitter) eventName $ toJsCb psCb\n\n-- | Adds the listener to the **start** of the `listeners` array.\n-- | Returns a callback that will remove the listener from the event emitter's listeners array.\n-- | If the listener removal callback isn't needed, use `prependListener_`.\n-- |\n-- | Intended usage:\n-- | ```\n-- | removeLoggerCallback <- eventEmitter # prependListener errorHandle \\error -> do\n-- |   log $ \"Got error: \" <> Exception.message error\n-- |   log $ \"This listener will now be removed.\"\n-- | -- sometime later...\n-- | removeLoggerCallback\n-- | ```\nprependListener\n  :: forall emitter psCb jsCb\n   . EventHandle emitter psCb jsCb\n  -> psCb\n  -> emitter\n  -> Effect (Effect Unit)\nprependListener (EventHandle eventName toJsCb) psCb eventEmitter =\n  runEffectFn4 subscribeSameFunction unsafePrependListener (unsafeCoerce eventEmitter) eventName $ toJsCb psCb\n\n-- | Adds the listener to the **start** of the `listeners` array.\n-- | Returns a callback that will remove the listener from the event emitter's listeners array.\n-- | If the listener removal callback isn't needed, use `prependListener`.\n-- |\n-- | Intended usage:\n-- | ```\n-- | eventEmitter # prependListener_ errorHandle \\error -> do\n-- |   log $ \"Got error: \" <> Exception.message error\n-- | ```\nprependListener_\n  :: forall emitter psCb jsCb\n   . EventHandle emitter psCb jsCb\n  -> psCb\n  -> emitter\n  -> Effect Unit\nprependListener_ (EventHandle eventName toJsCb) psCb eventEmitter =\n  runEffectFn3 unsafePrependListener (unsafeCoerce eventEmitter) eventName $ toJsCb psCb\n\n-- | Adds the listener to the **start** of the `listeners` array. The listener will be removed after it is invoked once.\n-- | Returns a callback that will remove the listener from the event emitter's listeners array.\n-- | If the listener removal callback isn't needed, use `prependOnceListener_`.\n-- |\n-- | Intended usage:\n-- | ```\n-- | removeLoggerCallback <- eventEmitter # prependOnceListener errorHandle \\error -> do\n-- |   log $ \"Got error: \" <> Exception.message error\n-- |   log $ \"This listener will now be removed.\"\n-- | -- sometime later...\n-- | removeLoggerCallback\n-- | ```\nprependOnceListener\n  :: forall emitter psCb jsCb\n   . EventHandle emitter psCb jsCb\n  -> psCb\n  -> emitter\n  -> Effect (Effect Unit)\nprependOnceListener (EventHandle eventName toJsCb) psCb eventEmitter =\n  runEffectFn4 subscribeSameFunction unsafePrependOnceListener (unsafeCoerce eventEmitter) eventName $ toJsCb psCb\n\n-- | Adds the listener to the **start** of the `listeners` array. The listener will be removed after it is invoked once.\n-- | Returns a callback that will remove the listener from the event emitter's listeners array.\n-- | If you need a callback to remove the listener in the future, use `prependOnceListener`.\n-- |\n-- | Intended usage:\n-- | ```\n-- | eventEmitter # prependOnceListener_ errorHandle \\error -> do\n-- |   log $ \"Got error: \" <> Exception.message error\n-- | ```\nprependOnceListener_\n  :: forall emitter psCb jsCb\n   . EventHandle emitter psCb jsCb\n  -> psCb\n  -> emitter\n  -> Effect Unit\nprependOnceListener_ (EventHandle eventName toJsCb) psCb eventEmitter =\n  runEffectFn3 unsafePrependOnceListener (unsafeCoerce eventEmitter) eventName $ toJsCb psCb\n\n-- | Internal function that ensures the JS callback function is the same one\n-- | used when both adding it and removing it from the listeners array.\n-- | Do not export this.\nsubscribeSameFunction\n  :: forall emitter jsCb\n   . EffectFn4\n       (EffectFn3 emitter String jsCb Unit)\n       emitter\n       String\n       jsCb\n       (Effect Unit)\nsubscribeSameFunction = mkEffectFn4 \\onXFn eventEmitter eventName jsCb -> do\n  runEffectFn3 onXFn (unsafeCoerce eventEmitter) eventName jsCb\n  pure $ runEffectFn3 unsafeOff (unsafeCoerce eventEmitter) eventName jsCb\n\nforeign import unsafeOn :: forall f. EffectFn3 EventEmitter String f Unit\nforeign import unsafeOff :: forall f. EffectFn3 EventEmitter String f Unit\nforeign import unsafeOnce :: forall f. EffectFn3 EventEmitter String f Unit\nforeign import unsafePrependListener :: forall f. EffectFn3 EventEmitter String f Unit\nforeign import unsafePrependOnceListener :: forall f. EffectFn3 EventEmitter String f Unit\n", "module Node.Stream.Object where\n\nimport Prelude\n\nimport Control.Monad.Rec.Class (untilJust)\nimport Control.Monad.ST.Global as ST\nimport Control.Monad.ST.Ref as STRef\nimport Control.Promise (Promise)\nimport Control.Promise as Promise\nimport Data.Array as Array\nimport Data.Array.ST as Array.ST\nimport Data.Either (Either(..))\nimport Data.Maybe (Maybe(..))\nimport Data.Newtype (class Newtype, unwrap, wrap)\nimport Data.Profunctor (class Profunctor)\nimport Data.Traversable (class Traversable, traverse)\nimport Effect (Effect)\nimport Effect.Aff (Aff, delay, effectCanceler, launchAff_, makeAff)\nimport Effect.Aff.Class (class MonadAff)\nimport Effect.Class (class MonadEffect, liftEffect)\nimport Effect.Exception (Error)\nimport Effect.Uncurried (mkEffectFn1)\nimport Node.Buffer (Buffer)\nimport Node.EventEmitter (EventHandle(..))\nimport Node.EventEmitter as Event\nimport Node.EventEmitter.UtilTypes (EventHandle1, EventHandle0)\nimport Node.Stream (Readable, Writable)\nimport Unsafe.Coerce (unsafeCoerce)\n\nforeign import data Stream :: Type -> Type -> Type\n\nnewtype ObjectStream :: Type -> Type -> Type\nnewtype ObjectStream i o = ObjectStream (Effect (Stream i o))\n\nderive instance Newtype (ObjectStream i o) _\n\ninstance Functor (ObjectStream i) where\n  map :: forall a b. (a -> b) -> ObjectStream i a -> ObjectStream i b\n  map ab (ObjectStream ia) = wrap $ join $ pure pipeImpl <*> ia <*> mapImpl ab\n\ninstance Apply (ObjectStream i) where\n  apply :: forall a b. ObjectStream i (a -> b) -> ObjectStream i a -> ObjectStream i b\n  apply (ObjectStream iab) (ObjectStream ia) = wrap $ join $ pure applyImpl <*> iab <*> ia\n\ninstance Applicative (ObjectStream i) where\n  pure = once\n\ninstance Monad (ObjectStream i)\n\ninstance MonadEffect (ObjectStream Unit) where\n  liftEffect = wrap <<< flip bind onceImpl\n\ninstance MonadAff (ObjectStream Unit) where\n  liftAff = wrap <<< fromPromiseImpl <<< Promise.fromAff\n\ninstance Bind (ObjectStream i) where\n  bind (ObjectStream sia') asb = wrap do\n    sia <- sia'\n    sab <- bindImpl (unwrap <<< asb)\n    pipeImpl sia sab\n\ninstance Profunctor ObjectStream where\n  dimap ab cd (ObjectStream sbc') = wrap do\n    sbc <- sbc'\n    sab <- mapImpl ab\n    scd <- mapImpl cd\n    sac <- pipeImpl sab sbc\n    pipeImpl sac scd\n\n-- | A stream that will emit the value `a` exactly once, and ignores any written chunks.\nonce :: forall i a. a -> ObjectStream i a\nonce = wrap <<< onceImpl\n\n-- | A stream that will immediately emit `close` and `end` events.\nnever :: forall a. ObjectStream Unit a\nnever = wrap neverImpl\n\n-- | A stream that for all input chunks, emits `unit`.\nsink :: forall a. ObjectStream a Unit\nsink = pure unit\n\n-- | Create a stream from a `Foldable` of `a`s\nfromFoldable :: forall f a. Traversable f => f a -> ObjectStream Unit a\nfromFoldable = chainMany <<< map once\n\n-- | Convert a `Readable` stream emitting `Buffer` chunks to an `ObjectStream`\nfromBufferReadable :: forall r. Readable r -> ObjectStream Unit Buffer\nfromBufferReadable r = wrap $ pure $ (unsafeCoerce :: Readable r -> Stream Unit Buffer) r\n\n-- | Convert a `Readable` stream emitting `String` chunks to an `ObjectStream`\nfromStringReadable :: forall r. Readable r -> ObjectStream Unit String\nfromStringReadable r = wrap $ pure $ (unsafeCoerce :: Readable r -> Stream Unit String) r\n\n-- | Convert a `Writable` stream accepting `Buffer` chunks to an `ObjectStream`\nfromBufferWritable :: forall r. Writable r -> ObjectStream Buffer Unit\nfromBufferWritable r = wrap $ pure $ (unsafeCoerce :: Writable r -> Stream Buffer Unit) r\n\n-- | Convert a `Writable` stream accepting `String` chunks to an `ObjectStream`\nfromStringWritable :: forall r. Writable r -> ObjectStream String Unit\nfromStringWritable r = wrap $ pure $ (unsafeCoerce :: Writable r -> Stream String Unit) r\n\n-- | Emit chunks from the first stream, then when exhausted emit chunks from the second.\nchain :: forall a. ObjectStream Unit a -> ObjectStream Unit a -> ObjectStream Unit a\nchain a b = chainMany [ a, b ]\n\n-- | `chain` for an arbitrary number of streams.\nchainMany :: forall f a. Traversable f => f (ObjectStream Unit a) -> ObjectStream Unit a\nchainMany as' = wrap do\n  as <- Array.fromFoldable <$> traverse unwrap as'\n  chainImpl as\n\nrun_ :: forall a. ObjectStream Unit a -> Aff Unit\nrun_ = void <<< run\n\nrun :: forall a. ObjectStream Unit a -> Aff (Array a)\nrun (ObjectStream s') = do\n  runningCount <- liftEffect $ ST.toEffect $ STRef.new 0\n  values <- liftEffect $ ST.toEffect $ Array.ST.new\n  s <- liftEffect s'\n  makeAff \\res ->\n    let\n      onData a = ST.toEffect do\n        void $ STRef.modify (_ + 1) runningCount\n        void $ Array.ST.push a values\n        void $ STRef.modify (_ - 1) runningCount\n      onError e = res $ Left e\n      onEnd = launchAff_ do\n        untilJust do\n          delay $ wrap $ 1.0\n          running <- liftEffect $ ST.toEffect $ STRef.read runningCount\n          pure $ if running == 0 then Just unit else Nothing\n        values' <- liftEffect $ ST.toEffect $ Array.ST.unsafeFreeze values\n        liftEffect $ res $ Right values'\n    in\n      do\n        cancelData <- Event.on dataH onData s\n        cancelError <- Event.on errorH onError s\n        cancelEnd <- Event.on endH onEnd s\n        pure $ effectCanceler do\n          cancelData\n          cancelError\n          cancelEnd\n\n-- | Constructs a Stream that re-emits the outputs from each stream, in order.\nforeign import chainImpl :: forall a. Array (Stream Unit a) -> Effect (Stream Unit a)\n\n-- | Pipes a stream's output into another's input, returning the new composite stream.\n-- |\n-- | Note that this differs from `Readable#pipe`, which returns the destination stream\n-- | verbatim to allow chained piping of only _outputs_.\nforeign import pipeImpl :: forall a b c. Stream a b -> Stream b c -> Effect (Stream a c)\n\n-- | A readable stream that immediately closes without emitting any chunks.\nforeign import neverImpl :: forall a. Effect (Stream Unit a)\n\n-- | Constructs a readable stream from an asynchronous value.\nforeign import fromPromiseImpl :: forall a. Effect (Promise a) -> Effect (Stream Unit a)\n\n-- | Constructs a readable stream that emits a single value then closes.\nforeign import onceImpl :: forall i a. a -> Effect (Stream i a)\n\n-- | Constructs a `Transform` applying the given function to chunks.\nforeign import mapImpl :: forall a b. (a -> b) -> Effect (Stream a b)\n\n-- | Constructs a `Transform` zipping functions from the left stream with values from the right stream.\n-- |\n-- | Closes when either stream closes.\nforeign import applyImpl :: forall i a b. Stream i (a -> b) -> Stream i a -> Effect (Stream i b)\n\n-- | Constructs a `Transform` which applies a function to each written chunk.\n-- |\n-- | The values emitted by the stream returned by this function are then emitted\n-- | until the temporary stream closes.\nforeign import bindImpl :: forall a _x b. (a -> Effect (Stream _x b)) -> Effect (Stream a b)\n\ndataH :: forall i o. EventHandle1 (Stream i o) o\ndataH = EventHandle \"data\" mkEffectFn1\n\nreadableH :: forall i o. EventHandle0 (Stream i o)\nreadableH = EventHandle \"readable\" identity\n\ncloseH :: forall i o. EventHandle0 (Stream i o)\ncloseH = EventHandle \"close\" identity\n\nendH :: forall i o. EventHandle0 (Stream i o)\nendH = EventHandle \"end\" identity\n\nerrorH :: forall i o. EventHandle1 (Stream i o) Error\nerrorH = EventHandle \"error\" mkEffectFn1\n", "var AVar = function () {\n\n  function MutableQueue () {\n    this.head = null;\n    this.last = null;\n    this.size = 0;\n  }\n\n  function MutableCell (queue, value) {\n    this.queue = queue;\n    this.value = value;\n    this.next  = null;\n    this.prev  = null;\n  }\n\n  function AVar (value) {\n    this.draining = false;\n    this.error    = null;\n    this.value    = value;\n    this.takes    = new MutableQueue();\n    this.reads    = new MutableQueue();\n    this.puts     = new MutableQueue();\n  }\n\n  var EMPTY = {};\n\n  function runEff(eff) {\n    try {\n      eff();\n    } catch (error) {\n      setTimeout(function () {\n        throw error;\n      }, 0);\n    }\n  }\n\n  function putLast (queue, value) {\n    var cell = new MutableCell(queue, value);\n    switch (queue.size) {\n      case 0:\n        queue.head = cell;\n        break;\n      case 1:\n        cell.prev = queue.head;\n        queue.head.next = cell;\n        queue.last = cell;\n        break;\n      default:\n        cell.prev = queue.last;\n        queue.last.next = cell;\n        queue.last = cell;\n    }\n    queue.size++;\n    return cell;\n  }\n\n  function takeLast (queue) {\n    var cell;\n    switch (queue.size) {\n      case 0:\n        return null;\n      case 1:\n        cell = queue.head;\n        queue.head = null;\n        break;\n      case 2:\n        cell = queue.last;\n        queue.head.next = null;\n        queue.last = null;\n        break;\n      default:\n        cell = queue.last;\n        queue.last = cell.prev;\n        queue.last.next = null;\n    }\n    cell.prev = null;\n    cell.queue = null;\n    queue.size--;\n    return cell.value;\n  }\n\n  function takeHead (queue) {\n    var cell;\n    switch (queue.size) {\n      case 0:\n        return null;\n      case 1:\n        cell = queue.head;\n        queue.head = null;\n        break;\n      case 2:\n        cell = queue.head;\n        queue.last.prev = null;\n        queue.head = queue.last;\n        queue.last = null;\n        break;\n      default:\n        cell = queue.head;\n        queue.head = cell.next;\n        queue.head.prev = null;\n    }\n    cell.next = null;\n    cell.queue = null;\n    queue.size--;\n    return cell.value;\n  }\n\n  function deleteCell (cell) {\n    if (cell.queue === null) {\n      return;\n    }\n    if (cell.queue.last === cell) {\n      takeLast(cell.queue);\n      return;\n    }\n    if (cell.queue.head === cell) {\n      takeHead(cell.queue);\n      return;\n    }\n    if (cell.prev) {\n      cell.prev.next = cell.next;\n    }\n    if (cell.next) {\n      cell.next.prev = cell.prev;\n    }\n    cell.queue.size--;\n    cell.queue = null;\n    cell.value = null;\n    cell.next  = null;\n    cell.prev  = null;\n  }\n\n  function drainVar (util, avar) {\n    if (avar.draining) {\n      return;\n    }\n\n    var ps = avar.puts;\n    var ts = avar.takes;\n    var rs = avar.reads;\n    var p, r, t, value, rsize;\n\n    avar.draining = true;\n\n    while (1) { // eslint-disable-line no-constant-condition\n      p = null;\n      r = null;\n      t = null;\n      value = avar.value;\n      rsize = rs.size;\n\n      if (avar.error !== null) {\n        value = util.left(avar.error);\n        while (p = takeHead(ps)) { // eslint-disable-line no-cond-assign\n          runEff(p.cb(value));\n        }\n        while (r = takeHead(rs)) { // eslint-disable-line no-cond-assign\n          runEff(r(value));\n        }\n        while (t = takeHead(ts)) { // eslint-disable-line no-cond-assign\n          runEff(t(value));\n        }\n        break;\n      }\n\n      // Process the next put. We do not immediately invoke the callback\n      // because we want to preserve ordering. If there are takes/reads\n      // we want to run those first.\n      if (value === EMPTY && (p = takeHead(ps))) {\n        avar.value = value = p.value;\n      }\n\n      if (value !== EMPTY) {\n        // We go ahead and queue up the next take for the same reasons as\n        // above. Invoking the read callbacks can affect the mutable queue.\n        t = takeHead(ts);\n        // We only want to process the reads queued up before running these\n        // callbacks so we guard on rsize.\n        while (rsize-- && (r = takeHead(rs))) {\n          runEff(r(util.right(value)));\n        }\n        if (t !== null) {\n          avar.value = EMPTY;\n          runEff(t(util.right(value)));\n        }\n      }\n\n      if (p !== null) {\n        runEff(p.cb(util.right(void 0)));\n      }\n\n      // Callbacks could have queued up more items so we need to guard on the\n      // actual mutable properties.\n      if (avar.value === EMPTY && ps.size === 0 || avar.value !== EMPTY && ts.size === 0) {\n        break;\n      }\n    }\n    avar.draining = false;\n  }\n\n  AVar.EMPTY      = EMPTY;\n  AVar.putLast    = putLast;\n  AVar.takeLast   = takeLast;\n  AVar.takeHead   = takeHead;\n  AVar.deleteCell = deleteCell;\n  AVar.drainVar   = drainVar;\n\n  return AVar;\n}();\n\nexport function empty() {\n  return new AVar(AVar.EMPTY);\n}\n\nexport function _newVar(value) {\n  return function () {\n    return new AVar(value);\n  };\n}\n\nexport function _killVar(util, error, avar) {\n  return function () {\n    if (avar.error === null) {\n      avar.error = error;\n      avar.value = AVar.EMPTY;\n      AVar.drainVar(util, avar);\n    }\n  };\n}\n\nexport function _putVar(util, value, avar, cb) {\n  return function () {\n    var cell = AVar.putLast(avar.puts, { cb: cb, value: value });\n    AVar.drainVar(util, avar);\n    return function () {\n      AVar.deleteCell(cell);\n    };\n  };\n}\n\nexport function _takeVar(util, avar, cb) {\n  return function () {\n    var cell = AVar.putLast(avar.takes, cb);\n    AVar.drainVar(util, avar);\n    return function () {\n      AVar.deleteCell(cell);\n    };\n  };\n}\n\nexport function _readVar(util, avar, cb) {\n  return function () {\n    var cell = AVar.putLast(avar.reads, cb);\n    AVar.drainVar(util, avar);\n    return function () {\n      AVar.deleteCell(cell);\n    };\n  };\n}\n\nexport function _tryPutVar(util, value, avar) {\n  return function () {\n    if (avar.value === AVar.EMPTY && avar.error === null) {\n      avar.value = value;\n      AVar.drainVar(util, avar);\n      return true;\n    } else {\n      return false;\n    }\n  };\n}\n\nexport function _tryTakeVar(util, avar) {\n  return function () {\n    var value = avar.value;\n    if (value === AVar.EMPTY) {\n      return util.nothing;\n    } else {\n      avar.value = AVar.EMPTY;\n      AVar.drainVar(util, avar);\n      return util.just(value);\n    }\n  };\n}\n\nexport function _tryReadVar(util, avar) {\n  return function () {\n    if (avar.value === AVar.EMPTY) {\n      return util.nothing;\n    } else {\n      return util.just(avar.value);\n    }\n  };\n}\n\nexport function _status(util, avar) {\n  return function () {\n    if (avar.error) {\n      return util.killed(avar.error);\n    }\n    if (avar.value === AVar.EMPTY) {\n      return util.empty;\n    }\n    return util.filled(avar.value);\n  };\n}\n\n", "module Effect.AVar\n  ( AVar\n  , AVarCallback\n  , AVarStatus(..)\n  , new\n  , empty\n  , take\n  , tryTake\n  , put\n  , tryPut\n  , read\n  , tryRead\n  , kill\n  , status\n  , isEmpty\n  , isFilled\n  , isKilled\n  ) where\n\nimport Prelude\nimport Data.Either (Either(..))\nimport Data.Function.Uncurried as Fn\nimport Data.Maybe (Maybe(..))\nimport Effect (Effect)\nimport Effect.Exception (Error)\n\ntype AVarCallback a = (Either Error a -> Effect Unit)\n\nforeign import data AVar :: Type -> Type\n\ntype role AVar representational\n\ndata AVarStatus a\n  = Killed Error\n  | Filled a\n  | Empty\n\n-- | Creates a new empty AVar.\nforeign import empty :: forall a. Effect (AVar a)\n\n-- | Creates a fresh AVar with an initial value.\nnew :: forall a. a -> Effect (AVar a)\nnew = _newVar\n\n-- | Kills the AVar with an exception. All pending and future actions will\n-- | resolve immediately with the provided exception.\nkill :: forall a. Error -> AVar a -> Effect Unit\nkill err avar = Fn.runFn3 _killVar ffiUtil err avar\n\n-- | Sets the value of the AVar. If the AVar is already filled, it will be\n-- | queued until the value is emptied. Multiple puts will resolve in order as\n-- | the AVar becomes available. Returns an effect which will remove the\n-- | callback from the pending queue.\nput :: forall a. a -> AVar a -> AVarCallback Unit -> Effect (Effect Unit)\nput value avar cb = Fn.runFn4 _putVar ffiUtil value avar cb\n\n-- | Attempts to synchronously fill an AVar. If the AVar is already filled,\n-- | this will do nothing. Returns true or false depending on if it succeeded.\ntryPut :: forall a. a -> AVar a -> Effect Boolean\ntryPut value avar = Fn.runFn3 _tryPutVar ffiUtil value avar\n\n-- | Takes the AVar value, leaving it empty. If the AVar is already empty,\n-- | the callback will be queued until the AVar is filled. Multiple takes will\n-- | resolve in order as the AVar fills. Returns an effect which will remove\n-- | the callback from the pending queue.\ntake :: forall a. AVar a -> AVarCallback a -> Effect (Effect Unit)\ntake avar cb = Fn.runFn3 _takeVar ffiUtil avar cb\n\n-- | Attempts to synchronously take an AVar value, leaving it empty. If the\n-- | AVar is empty, this will return `Nothing`.\ntryTake :: forall a. AVar a -> Effect (Maybe a)\ntryTake avar = Fn.runFn2 _tryTakeVar ffiUtil avar\n\n-- | Reads the AVar value. Unlike `take`, this will not leave the AVar empty.\n-- | If the AVar is empty, this will queue until it is filled. Multiple reads\n-- | will resolve at the same time, as soon as possible.\nread :: forall a. AVar a -> AVarCallback a -> Effect (Effect Unit)\nread avar cb = Fn.runFn3 _readVar ffiUtil avar cb\n\n-- | Attempts to synchronously read an AVar. If the AVar is empty, this will\n-- | return `Nothing`.\ntryRead :: forall a. AVar a -> Effect (Maybe a)\ntryRead avar = Fn.runFn2 _tryReadVar ffiUtil avar\n\n-- | Synchronously checks the status of an AVar.\nstatus :: forall a. AVar a -> Effect (AVarStatus a)\nstatus avar = Fn.runFn2 _status ffiUtil avar\n\nisEmpty :: forall a. AVarStatus a -> Boolean\nisEmpty = case _ of\n  Empty -> true\n  _ -> false\n\nisFilled :: forall a. AVarStatus a -> Boolean\nisFilled = case _ of\n  Filled _ -> true\n  _ -> false\n\nisKilled :: forall a. AVarStatus a -> Boolean\nisKilled = case _ of\n  Killed _ -> true\n  _ -> false\n\nforeign import _newVar :: forall a. a -> Effect (AVar a)\nforeign import _killVar :: forall a. Fn.Fn3 FFIUtil Error (AVar a) (Effect Unit)\nforeign import _putVar :: forall a. Fn.Fn4 FFIUtil a (AVar a) (AVarCallback Unit) (Effect (Effect Unit))\nforeign import _tryPutVar :: forall a. Fn.Fn3 FFIUtil a (AVar a) (Effect Boolean)\nforeign import _takeVar :: forall a. Fn.Fn3 FFIUtil (AVar a) (AVarCallback a) (Effect (Effect Unit))\nforeign import _tryTakeVar :: forall a. Fn.Fn2 FFIUtil (AVar a) (Effect (Maybe a))\nforeign import _readVar :: forall a. Fn.Fn3 FFIUtil (AVar a) (AVarCallback a) (Effect (Effect Unit))\nforeign import _tryReadVar :: forall a. Fn.Fn2 FFIUtil (AVar a) (Effect (Maybe a))\nforeign import _status :: forall a. Fn.Fn2 FFIUtil (AVar a) (Effect (AVarStatus a))\n\ntype FFIUtil =\n  { left :: forall a b. a -> Either a b\n  , right :: forall a b. b -> Either a b\n  , nothing :: forall a. Maybe a\n  , just :: forall a. a -> Maybe a\n  , killed :: forall a. Error -> AVarStatus a\n  , filled :: forall a. a -> AVarStatus a\n  , empty :: forall a. AVarStatus a\n  }\n\nffiUtil :: FFIUtil\nffiUtil =\n  { left: Left\n  , right: Right\n  , nothing: Nothing\n  , just: Just\n  , killed: Killed\n  , filled: Filled\n  , empty: Empty\n  }\n", "module Effect.Aff.AVar\n  ( module Effect.AVar\n  , new\n  , empty\n  , status\n  , take\n  , tryTake\n  , put\n  , tryPut\n  , read\n  , tryRead\n  , kill\n  ) where\n\nimport Prelude\nimport Data.Maybe (Maybe)\nimport Effect.Aff (Aff, makeAff, effectCanceler)\nimport Effect.AVar (AVar, AVarStatus(..), isEmpty, isFilled, isKilled)\nimport Effect.AVar as AVar\nimport Effect.Class (liftEffect)\nimport Effect.Exception (Error)\n\n-- | Creates a fresh AVar with an initial value.\nnew :: forall a. a -> Aff (AVar a)\nnew = liftEffect <<< AVar.new\n\n-- | Creates a fresh AVar.\nempty :: forall a. Aff (AVar a)\nempty = liftEffect AVar.empty\n\n-- | Synchronously checks the status of an AVar.\nstatus :: forall a. AVar a -> Aff (AVar.AVarStatus a)\nstatus = liftEffect <<< AVar.status\n\n-- | Takes the AVar value, leaving it empty. If the AVar is already empty,\n-- | the callback will be queued until the AVar is filled. Multiple takes will\n-- | resolve in order as the AVar fills.\ntake :: forall a. AVar a -> Aff a\ntake avar = makeAff \\k -> do\n  c <- AVar.take avar k\n  pure (effectCanceler c)\n\n-- | Attempts to synchronously take an AVar value, leaving it empty. If the\n-- | AVar is empty, this will return `Nothing`.\ntryTake :: forall a. AVar a -> Aff (Maybe a)\ntryTake = liftEffect <<< AVar.tryTake\n\n-- | Sets the value of the AVar. If the AVar is already filled, it will be\n-- | queued until the value is emptied. Multiple puts will resolve in order as\n-- | the AVar becomes available.\nput :: forall a. a -> AVar a -> Aff Unit\nput value avar = makeAff \\k -> do\n  c <- AVar.put value avar k\n  pure (effectCanceler c)\n\n-- | Attempts to synchronously fill an AVar. If the AVar is already filled,\n-- | this will do nothing. Returns true or false depending on if it succeeded.\ntryPut :: forall a. a -> AVar a -> Aff Boolean\ntryPut value = liftEffect <<< AVar.tryPut value\n\n-- | Reads the AVar value. Unlike `take`, this will not leave the AVar empty.\n-- | If the AVar is empty, this will queue until it is filled. Multiple reads\n-- | will resolve at the same time, as soon as possible.\nread :: forall a. AVar a -> Aff a\nread avar = makeAff \\k -> do\n  c <- AVar.read avar k\n  pure (effectCanceler c)\n\n-- | Attempts to synchronously read an AVar. If the AVar is empty, this will\n-- | return `Nothing`.\ntryRead :: forall a. AVar a -> Aff (Maybe a)\ntryRead = liftEffect <<< AVar.tryRead\n\n-- | Kills the AVar with an exception. All pending and future actions will\n-- | resolve immediately with the provided exception.\nkill :: forall a. Error -> AVar a -> Aff Unit\nkill error = liftEffect <<< AVar.kill error\n", "-- | This module defines the `State` monad.\n\nmodule Control.Monad.State\n  ( State\n  , runState\n  , evalState\n  , execState\n  , mapState\n  , withState\n  , module Control.Monad.State.Class\n  , module Control.Monad.State.Trans\n  ) where\n\nimport Prelude\n\nimport Control.Monad.State.Class (class MonadState, get, gets, modify, modify_, put, state)\nimport Control.Monad.State.Trans (class MonadTrans, StateT(..), evalStateT, execStateT, lift, mapStateT, runStateT, withStateT)\n\nimport Data.Identity (Identity(..))\nimport Data.Newtype (unwrap)\nimport Data.Tuple (Tuple(Tuple))\n\n-- | The `State` monad is a synonym for the `StateT` monad transformer, applied\n-- | to the `Identity` monad.\ntype State s = StateT s Identity\n\n-- | Run a computation in the `State` monad\nrunState :: forall s a. State s a -> s -> Tuple a s\nrunState (StateT s) = unwrap <<< s\n\n-- | Run a computation in the `State` monad, discarding the final state\nevalState :: forall s a. State s a -> s -> a\nevalState (StateT m) s = case m s of Identity (Tuple a _) -> a\n\n-- | Run a computation in the `State` monad, discarding the result\nexecState :: forall s a. State s a -> s -> s\nexecState (StateT m) s = case m s of Identity (Tuple _ s') -> s'\n\n-- | Change the type of the result in a `State` action\nmapState :: forall s a b. (Tuple a s -> Tuple b s) -> State s a -> State s b\nmapState f = mapStateT (Identity <<< f <<< unwrap)\n\n-- | Modify the state in a `State` action\nwithState :: forall s a. (s -> s) -> State s a -> State s a\nwithState = withStateT\n", "export const foldr1Impl = function (f, xs) {\n  var acc = xs[xs.length - 1];\n  for (var i = xs.length - 2; i >= 0; i--) {\n    acc = f(xs[i])(acc);\n  }\n  return acc;\n};\n\nexport const foldl1Impl = function (f, xs) {\n  var acc = xs[0];\n  var len = xs.length;\n  for (var i = 1; i < len; i++) {\n    acc = f(acc)(xs[i]);\n  }\n  return acc;\n};\n\nexport const traverse1Impl = function () {\n  function Cont(fn) {\n    this.fn = fn;\n  }\n\n  var emptyList = {};\n\n  var ConsCell = function (head, tail) {\n    this.head = head;\n    this.tail = tail;\n  };\n\n  function finalCell(head) {\n    return new ConsCell(head, emptyList);\n  }\n\n  function consList(x) {\n    return function (xs) {\n      return new ConsCell(x, xs);\n    };\n  }\n\n  function listToArray(list) {\n    var arr = [];\n    var xs = list;\n    while (xs !== emptyList) {\n      arr.push(xs.head);\n      xs = xs.tail;\n    }\n    return arr;\n  }\n\n  return function (apply, map, f) {\n    var buildFrom = function (x, ys) {\n      return apply(map(consList)(f(x)))(ys);\n    };\n\n    var go = function (acc, currentLen, xs) {\n      if (currentLen === 0) {\n        return acc;\n      } else {\n        var last = xs[currentLen - 1];\n        return new Cont(function () {\n          var built = go(buildFrom(last, acc), currentLen - 1, xs);\n          return built;\n        });\n      }\n    };\n\n    return function (array) {\n      var acc = map(finalCell)(f(array[array.length - 1]));\n      var result = go(acc, array.length - 1, array);\n      while (result instanceof Cont) {\n        result = result.fn();\n      }\n\n      return map(listToArray)(result);\n    };\n  };\n}();\n", "module Data.Array.NonEmpty\n  ( module Internal\n  , fromArray\n  , fromNonEmpty\n  , toArray\n  , toNonEmpty\n\n  , fromFoldable\n  , fromFoldable1\n  , toUnfoldable\n  , toUnfoldable1\n  , singleton\n  , (..), range\n  , replicate\n  , some\n\n  , length\n\n  , (:), cons\n  , cons'\n  , snoc\n  , snoc'\n  , appendArray\n  , prependArray\n  , insert\n  , insertBy\n\n  , head\n  , last\n  , tail\n  , init\n  , uncons\n  , unsnoc\n\n  , (!!), index\n  , elem\n  , notElem\n  , elemIndex\n  , elemLastIndex\n  , find\n  , findMap\n  , findIndex\n  , findLastIndex\n  , insertAt\n  , deleteAt\n  , updateAt\n  , updateAtIndices\n  , modifyAt\n  , modifyAtIndices\n  , alterAt\n\n  , intersperse\n  , reverse\n  , concat\n  , concatMap\n  , filter\n  , partition\n  , splitAt\n  , filterA\n  , mapMaybe\n  , catMaybes\n  , mapWithIndex\n  , foldl1\n  , foldr1\n  , foldMap1\n  , fold1\n  , intercalate\n  , transpose\n  , transpose'\n  , scanl\n  , scanr\n\n  , sort\n  , sortBy\n  , sortWith\n  , slice\n  , take\n  , takeEnd\n  , takeWhile\n  , drop\n  , dropEnd\n  , dropWhile\n  , span\n  , group\n  , groupAll\n  , groupBy\n  , groupAllBy\n\n  , nub\n  , nubBy\n  , nubEq\n  , nubByEq\n  , union\n  , union'\n  , unionBy\n  , unionBy'\n  , delete\n  , deleteBy\n\n  , (\\\\), difference\n  , difference'\n  , intersect\n  , intersect'\n  , intersectBy\n  , intersectBy'\n\n  , zipWith\n  , zipWithA\n  , zip\n  , unzip\n\n  , any\n  , all\n\n  , foldM\n  , foldRecM\n\n  , unsafeIndex\n  ) where\n\nimport Prelude\n\nimport Control.Alternative (class Alternative)\nimport Control.Lazy (class Lazy)\nimport Control.Monad.Rec.Class (class MonadRec)\nimport Data.Array as A\nimport Data.Array.NonEmpty.Internal (NonEmptyArray(..))\nimport Data.Array.NonEmpty.Internal (NonEmptyArray) as Internal\nimport Data.Bifunctor (bimap)\nimport Data.Foldable (class Foldable)\nimport Data.Maybe (Maybe(..), fromJust)\nimport Data.NonEmpty (NonEmpty, (:|))\nimport Data.Semigroup.Foldable (class Foldable1)\nimport Data.Semigroup.Foldable as F\nimport Data.Tuple (Tuple(..))\nimport Data.Unfoldable (class Unfoldable)\nimport Data.Unfoldable1 (class Unfoldable1, unfoldr1)\nimport Partial.Unsafe (unsafePartial)\nimport Safe.Coerce (coerce)\nimport Unsafe.Coerce (unsafeCoerce)\n\n-- | Internal - adapt an Array transform to NonEmptyArray\n--\n-- Note that this is unsafe: if the transform returns an empty array, this can\n-- explode at runtime.\nunsafeAdapt :: forall a b. (Array a -> Array b) -> NonEmptyArray a -> NonEmptyArray b\nunsafeAdapt f = unsafeFromArray <<< adaptAny f\n\n-- | Internal - adapt an Array transform to NonEmptyArray,\n--   with polymorphic result.\n--\n-- Note that this is unsafe: if the transform returns an empty array, this can\n-- explode at runtime.\nadaptAny :: forall a b. (Array a -> b) -> NonEmptyArray a -> b\nadaptAny f = f <<< toArray\n\n-- | Internal - adapt Array functions returning Maybes to NonEmptyArray\nadaptMaybe :: forall a b. (Array a -> Maybe b) -> NonEmptyArray a -> b\nadaptMaybe f = unsafePartial $ fromJust <<< f <<< toArray\n\nfromArray :: forall a. Array a -> Maybe (NonEmptyArray a)\nfromArray xs\n  | A.length xs > 0 = Just (unsafeFromArray xs)\n  | otherwise = Nothing\n\n-- | INTERNAL\nunsafeFromArray :: forall a. Array a -> NonEmptyArray a\nunsafeFromArray = NonEmptyArray\n\nunsafeFromArrayF :: forall f a. f (Array a) -> f (NonEmptyArray a)\nunsafeFromArrayF = unsafeCoerce\n\nfromNonEmpty :: forall a. NonEmpty Array a -> NonEmptyArray a\nfromNonEmpty (x :| xs) = cons' x xs\n\ntoArray :: forall a. NonEmptyArray a -> Array a\ntoArray (NonEmptyArray xs) = xs\n\ntoNonEmpty :: forall a. NonEmptyArray a -> NonEmpty Array a\ntoNonEmpty = uncons >>> \\{head: x, tail: xs} -> x :| xs\n\nfromFoldable :: forall f a. Foldable f => f a -> Maybe (NonEmptyArray a)\nfromFoldable = fromArray <<< A.fromFoldable\n\nfromFoldable1 :: forall f a. Foldable1 f => f a -> NonEmptyArray a\nfromFoldable1 = unsafeFromArray <<< A.fromFoldable\n\ntoUnfoldable :: forall f a. Unfoldable f => NonEmptyArray a -> f a\ntoUnfoldable = adaptAny A.toUnfoldable\n\ntoUnfoldable1 :: forall f a. Unfoldable1 f => NonEmptyArray a -> f a\ntoUnfoldable1 xs = unfoldr1 f 0\n  where\n  len = length xs\n  f i = Tuple (unsafePartial unsafeIndex xs i) $\n          if i < (len - 1) then Just (i + 1) else Nothing\n\nsingleton :: forall a. a -> NonEmptyArray a\nsingleton = unsafeFromArray <<< A.singleton\n\nrange :: Int -> Int -> NonEmptyArray Int\nrange x y = unsafeFromArray $ A.range x y\n\ninfix 8 range as ..\n\n-- | Replicate an item at least once\nreplicate :: forall a. Int -> a -> NonEmptyArray a\nreplicate i x = unsafeFromArray $ A.replicate (max 1 i) x\n\nsome\n  :: forall f a\n   . Alternative f\n  => Lazy (f (Array a))\n  => f a -> f (NonEmptyArray a)\nsome = unsafeFromArrayF <<< A.some\n\nlength :: forall a. NonEmptyArray a -> Int\nlength = adaptAny A.length\n\ncons :: forall a. a -> NonEmptyArray a -> NonEmptyArray a\ncons x = unsafeAdapt $ A.cons x\n\ninfixr 6 cons as :\n\ncons' :: forall a. a -> Array a -> NonEmptyArray a\ncons' x xs = unsafeFromArray $ A.cons x xs\n\nsnoc :: forall a. NonEmptyArray a -> a -> NonEmptyArray a\nsnoc xs x = unsafeFromArray $ A.snoc (toArray xs) x\n\nsnoc' :: forall a. Array a -> a -> NonEmptyArray a\nsnoc' xs x = unsafeFromArray $ A.snoc xs x\n\nappendArray :: forall a. NonEmptyArray a -> Array a -> NonEmptyArray a\nappendArray xs ys = unsafeFromArray $ toArray xs <> ys\n\nprependArray :: forall a. Array a -> NonEmptyArray a -> NonEmptyArray a\nprependArray xs ys = unsafeFromArray $ xs <> toArray ys\n\ninsert :: forall a. Ord a => a -> NonEmptyArray a -> NonEmptyArray a\ninsert x = unsafeAdapt $ A.insert x\n\ninsertBy :: forall a. (a -> a -> Ordering) -> a -> NonEmptyArray a -> NonEmptyArray a\ninsertBy f x = unsafeAdapt $ A.insertBy f x\n\nhead :: forall a. NonEmptyArray a -> a\nhead = adaptMaybe A.head\n\nlast :: forall a. NonEmptyArray a -> a\nlast = adaptMaybe A.last\n\ntail :: forall a. NonEmptyArray a -> Array a\ntail = adaptMaybe A.tail\n\ninit :: forall a. NonEmptyArray a -> Array a\ninit = adaptMaybe A.init\n\nuncons :: forall a. NonEmptyArray a -> { head :: a, tail :: Array a }\nuncons = adaptMaybe A.uncons\n\nunsnoc :: forall a. NonEmptyArray a -> { init :: Array a, last :: a }\nunsnoc = adaptMaybe A.unsnoc\n\nindex :: forall a. NonEmptyArray a -> Int -> Maybe a\nindex = adaptAny A.index\n\ninfixl 8 index as !!\n\nelem :: forall a. Eq a => a -> NonEmptyArray a -> Boolean\nelem x = adaptAny $ A.elem x\n\nnotElem :: forall a. Eq a => a -> NonEmptyArray a -> Boolean\nnotElem x = adaptAny $ A.notElem x\n\nelemIndex :: forall a. Eq a => a -> NonEmptyArray a -> Maybe Int\nelemIndex x = adaptAny $ A.elemIndex x\n\nelemLastIndex :: forall a. Eq a => a -> NonEmptyArray a -> Maybe Int\nelemLastIndex x = adaptAny $ A.elemLastIndex x\n\nfind :: forall a. (a -> Boolean) -> NonEmptyArray a -> Maybe a\nfind p = adaptAny $ A.find p\n\nfindMap :: forall a b. (a -> Maybe b) -> NonEmptyArray a -> Maybe b\nfindMap p = adaptAny $ A.findMap p\n\nfindIndex :: forall a. (a -> Boolean) -> NonEmptyArray a -> Maybe Int\nfindIndex p = adaptAny $ A.findIndex p\n\nfindLastIndex :: forall a. (a -> Boolean) -> NonEmptyArray a -> Maybe Int\nfindLastIndex x = adaptAny $ A.findLastIndex x\n\ninsertAt :: forall a. Int -> a -> NonEmptyArray a -> Maybe (NonEmptyArray a)\ninsertAt i x = unsafeFromArrayF <<< A.insertAt i x <<< toArray\n\ndeleteAt :: forall a. Int -> NonEmptyArray a -> Maybe (Array a)\ndeleteAt i = adaptAny $ A.deleteAt i\n\nupdateAt :: forall a. Int -> a -> NonEmptyArray a -> Maybe (NonEmptyArray a)\nupdateAt i x = unsafeFromArrayF <<< A.updateAt i x <<< toArray\n\nupdateAtIndices :: forall t a. Foldable t => t (Tuple Int a) -> NonEmptyArray a -> NonEmptyArray a\nupdateAtIndices pairs = unsafeAdapt $ A.updateAtIndices pairs\n\nmodifyAt :: forall a. Int -> (a -> a) -> NonEmptyArray a -> Maybe (NonEmptyArray a)\nmodifyAt i f = unsafeFromArrayF <<< A.modifyAt i f <<< toArray\n\nmodifyAtIndices :: forall t a. Foldable t => t Int -> (a -> a) -> NonEmptyArray a -> NonEmptyArray a\nmodifyAtIndices is f = unsafeAdapt $ A.modifyAtIndices is f\n\nalterAt :: forall a. Int -> (a -> Maybe a) -> NonEmptyArray a -> Maybe (Array a)\nalterAt i f = A.alterAt i f <<< toArray\n\nintersperse :: forall a. a -> NonEmptyArray a -> NonEmptyArray a\nintersperse x = unsafeAdapt $ A.intersperse x\n\nreverse :: forall a. NonEmptyArray a -> NonEmptyArray a\nreverse = unsafeAdapt A.reverse\n\nconcat :: forall a. NonEmptyArray (NonEmptyArray a) -> NonEmptyArray a\nconcat = unsafeFromArray <<< A.concat <<< toArray <<< map toArray\n\nconcatMap :: forall a b. (a -> NonEmptyArray b) -> NonEmptyArray a -> NonEmptyArray b\nconcatMap = flip bind\n\nfilter :: forall a. (a -> Boolean) -> NonEmptyArray a -> Array a\nfilter f = adaptAny $ A.filter f\n\npartition\n  :: forall a\n   . (a -> Boolean)\n  -> NonEmptyArray a\n  -> { yes :: Array a, no :: Array a}\npartition f = adaptAny $ A.partition f\n\nfilterA\n  :: forall a f\n   . Applicative f\n  => (a -> f Boolean)\n  -> NonEmptyArray a\n  -> f (Array a)\nfilterA f = adaptAny $ A.filterA f\n\nsplitAt :: forall a. Int -> NonEmptyArray a -> { before :: Array a, after :: Array a }\nsplitAt i xs = A.splitAt i $ toArray xs\n\nmapMaybe :: forall a b. (a -> Maybe b) -> NonEmptyArray a -> Array b\nmapMaybe f = adaptAny $ A.mapMaybe f\n\ncatMaybes :: forall a. NonEmptyArray (Maybe a) -> Array a\ncatMaybes = adaptAny A.catMaybes\n\nmapWithIndex :: forall a b. (Int -> a -> b) -> NonEmptyArray a -> NonEmptyArray b\nmapWithIndex f = unsafeAdapt $ A.mapWithIndex f\n\nfoldl1 :: forall a. (a -> a -> a) -> NonEmptyArray a -> a\nfoldl1 = F.foldl1\n\nfoldr1 :: forall a. (a -> a -> a) -> NonEmptyArray a -> a\nfoldr1 = F.foldr1\n\nfoldMap1 :: forall a m. Semigroup m => (a -> m) -> NonEmptyArray a -> m\nfoldMap1 = F.foldMap1\n\nfold1 :: forall m. Semigroup m => NonEmptyArray m -> m\nfold1 = F.fold1\n\nintercalate :: forall a. Semigroup a => a -> NonEmptyArray a -> a\nintercalate = F.intercalate\n\n-- | The 'transpose' function transposes the rows and columns of its argument.\n-- | For example,\n-- |\n-- | ```purescript\n-- | transpose \n-- |   (NonEmptyArray [ NonEmptyArray [1, 2, 3]\n-- |                  , NonEmptyArray [4, 5, 6]\n-- |                  ]) == \n-- |   (NonEmptyArray [ NonEmptyArray [1, 4]\n-- |                  , NonEmptyArray [2, 5]\n-- |                  , NonEmptyArray [3, 6]\n-- |                  ])\n-- | ```\n-- |\n-- | If some of the rows are shorter than the following rows, their elements are skipped:\n-- |\n-- | ```purescript\n-- | transpose \n-- |   (NonEmptyArray [ NonEmptyArray [10, 11]\n-- |                  , NonEmptyArray [20]\n-- |                  , NonEmptyArray [30, 31, 32]\n-- |                  ]) == \n-- |   (NomEmptyArray [ NonEmptyArray [10, 20, 30]\n-- |                  , NonEmptyArray [11, 31]\n-- |                  , NonEmptyArray [32]\n-- |                  ])\n-- | ```\ntranspose :: forall a. NonEmptyArray (NonEmptyArray a) -> NonEmptyArray (NonEmptyArray a)\ntranspose = \n  (coerce :: (Array (Array a)) -> (NonEmptyArray (NonEmptyArray a))) \n    <<< A.transpose <<< coerce\n\n-- | `transpose`' is identical to `transpose` other than that the inner arrays are each\n-- | a standard `Array` and not a `NonEmptyArray`. However, the result is wrapped in a \n-- | `Maybe` to cater for the case where the inner `Array` is empty and must return `Nothing`.\ntranspose' :: forall a. NonEmptyArray (Array a) -> Maybe (NonEmptyArray (Array a))\ntranspose' = fromArray <<< A.transpose <<< coerce\n\nscanl :: forall a b. (b -> a -> b) -> b -> NonEmptyArray a -> NonEmptyArray b\nscanl f x = unsafeAdapt $ A.scanl f x\n\nscanr :: forall a b. (a -> b -> b) -> b -> NonEmptyArray a -> NonEmptyArray b\nscanr f x = unsafeAdapt $ A.scanr f x\n\nsort :: forall a. Ord a => NonEmptyArray a -> NonEmptyArray a\nsort = unsafeAdapt A.sort\n\nsortBy :: forall a. (a -> a -> Ordering) -> NonEmptyArray a -> NonEmptyArray a\nsortBy f = unsafeAdapt $ A.sortBy f\n\nsortWith :: forall a b. Ord b => (a -> b) -> NonEmptyArray a -> NonEmptyArray a\nsortWith f = unsafeAdapt $ A.sortWith f\n\nslice :: forall a. Int -> Int -> NonEmptyArray a -> Array a\nslice start end = adaptAny $ A.slice start end\n\ntake :: forall a. Int -> NonEmptyArray a -> Array a\ntake i = adaptAny $ A.take i\n\ntakeEnd :: forall a. Int -> NonEmptyArray a -> Array a\ntakeEnd i = adaptAny $ A.takeEnd i\n\ntakeWhile :: forall a. (a -> Boolean) -> NonEmptyArray a -> Array a\ntakeWhile f = adaptAny $ A.takeWhile f\n\ndrop :: forall a. Int -> NonEmptyArray a -> Array a\ndrop i = adaptAny $ A.drop i\n\ndropEnd :: forall a. Int -> NonEmptyArray a -> Array a\ndropEnd i = adaptAny $ A.dropEnd i\n\ndropWhile :: forall a. (a -> Boolean) -> NonEmptyArray a -> Array a\ndropWhile f = adaptAny $ A.dropWhile f\n\nspan\n  :: forall a\n   . (a -> Boolean)\n  -> NonEmptyArray a\n  -> { init :: Array a, rest :: Array a }\nspan f = adaptAny $ A.span f\n\n-- | Group equal, consecutive elements of an array into arrays.\n-- |\n-- | ```purescript\n-- | group (NonEmptyArray [1, 1, 2, 2, 1]) ==\n-- |   NonEmptyArray [NonEmptyArray [1, 1], NonEmptyArray [2, 2], NonEmptyArray [1]]\n-- | ```\ngroup :: forall a. Eq a => NonEmptyArray a -> NonEmptyArray (NonEmptyArray a)\ngroup = unsafeAdapt $ A.group\n\n-- | Group equal elements of an array into arrays.\n-- |\n-- | ```purescript\n-- | groupAll (NonEmptyArray [1, 1, 2, 2, 1]) ==\n-- |   NonEmptyArray [NonEmptyArray [1, 1, 1], NonEmptyArray [2, 2]]\n-- | `\ngroupAll :: forall a. Ord a => NonEmptyArray a -> NonEmptyArray (NonEmptyArray a)\ngroupAll = groupAllBy compare\n\n-- | Group equal, consecutive elements of an array into arrays, using the\n-- | specified equivalence relation to determine equality.\n-- |\n-- | ```purescript\n-- | groupBy (\\a b -> odd a && odd b) (NonEmptyArray [1, 3, 2, 4, 3, 3])\n-- |    = NonEmptyArray [NonEmptyArray [1, 3], NonEmptyArray [2], NonEmptyArray [4], NonEmptyArray [3, 3]]\n-- | ```\n-- |\ngroupBy :: forall a. (a -> a -> Boolean) -> NonEmptyArray a -> NonEmptyArray (NonEmptyArray a)\ngroupBy op = unsafeAdapt $ A.groupBy op\n\n-- | Group equal elements of an array into arrays, using the specified\n-- | comparison function to determine equality.\n-- |\n-- | ```purescript\n-- | groupAllBy (comparing Down) (NonEmptyArray [1, 3, 2, 4, 3, 3])\n-- |    = NonEmptyArray [NonEmptyArray [4], NonEmptyArray [3, 3, 3], NonEmptyArray [2], NonEmptyArray [1]]\n-- | ```\ngroupAllBy :: forall a. (a -> a -> Ordering) -> NonEmptyArray a -> NonEmptyArray (NonEmptyArray a)\ngroupAllBy op = unsafeAdapt $ A.groupAllBy op\n\nnub :: forall a. Ord a => NonEmptyArray a -> NonEmptyArray a\nnub = unsafeAdapt A.nub\n\nnubEq :: forall a. Eq a => NonEmptyArray a -> NonEmptyArray a\nnubEq = unsafeAdapt A.nubEq\n\nnubBy :: forall a. (a -> a -> Ordering) -> NonEmptyArray a -> NonEmptyArray a\nnubBy f = unsafeAdapt $ A.nubBy f\n\nnubByEq :: forall a. (a -> a -> Boolean) -> NonEmptyArray a -> NonEmptyArray a\nnubByEq f = unsafeAdapt $ A.nubByEq f\n\nunion :: forall a. Eq a => NonEmptyArray a -> NonEmptyArray a -> NonEmptyArray a\nunion = unionBy (==)\n\nunion' :: forall a. Eq a => NonEmptyArray a -> Array a -> NonEmptyArray a\nunion' = unionBy' (==)\n\nunionBy\n  :: forall a\n   . (a -> a -> Boolean)\n  -> NonEmptyArray a\n  -> NonEmptyArray a\n  -> NonEmptyArray a\nunionBy eq xs = unionBy' eq xs <<< toArray\n\nunionBy'\n  :: forall a\n   . (a -> a -> Boolean)\n  -> NonEmptyArray a\n  -> Array a\n  -> NonEmptyArray a\nunionBy' eq xs = unsafeFromArray <<< A.unionBy eq (toArray xs)\n\ndelete :: forall a. Eq a => a -> NonEmptyArray a -> Array a\ndelete x = adaptAny $ A.delete x\n\ndeleteBy :: forall a. (a -> a -> Boolean) -> a -> NonEmptyArray a -> Array a\ndeleteBy f x = adaptAny $ A.deleteBy f x\n\ndifference :: forall a. Eq a => NonEmptyArray a -> NonEmptyArray a -> Array a\ndifference xs = adaptAny $ difference' xs\n\ndifference' :: forall a. Eq a => NonEmptyArray a -> Array a -> Array a\ndifference' xs = A.difference $ toArray xs\n\nintersect :: forall a . Eq a => NonEmptyArray a -> NonEmptyArray a -> Array a\nintersect = intersectBy eq\n\nintersect' :: forall a . Eq a => NonEmptyArray a -> Array a -> Array a\nintersect' = intersectBy' eq\n\nintersectBy\n  :: forall a\n   . (a -> a -> Boolean)\n  -> NonEmptyArray a\n  -> NonEmptyArray a\n  -> Array a\nintersectBy eq xs = intersectBy' eq xs <<< toArray\n\nintersectBy'\n  :: forall a\n   . (a -> a -> Boolean)\n  -> NonEmptyArray a\n  -> Array a\n  -> Array a\nintersectBy' eq xs = A.intersectBy eq (toArray xs)\n\ninfix 5 difference as \\\\\n\nzipWith\n  :: forall a b c\n   . (a -> b -> c)\n  -> NonEmptyArray a\n  -> NonEmptyArray b\n  -> NonEmptyArray c\nzipWith f xs ys = unsafeFromArray $ A.zipWith f (toArray xs) (toArray ys)\n\n\nzipWithA\n  :: forall m a b c\n   . Applicative m\n  => (a -> b -> m c)\n  -> NonEmptyArray a\n  -> NonEmptyArray b\n  -> m (NonEmptyArray c)\nzipWithA f xs ys = unsafeFromArrayF $ A.zipWithA f (toArray xs) (toArray ys)\n\nzip :: forall a b. NonEmptyArray a -> NonEmptyArray b -> NonEmptyArray (Tuple a b)\nzip xs ys = unsafeFromArray $ toArray xs `A.zip` toArray ys\n\nunzip :: forall a b. NonEmptyArray (Tuple a b) -> Tuple (NonEmptyArray a) (NonEmptyArray b)\nunzip = bimap unsafeFromArray unsafeFromArray <<< A.unzip <<< toArray\n\nany :: forall a. (a -> Boolean) -> NonEmptyArray a -> Boolean\nany p = adaptAny $ A.any p\n\nall :: forall a. (a -> Boolean) -> NonEmptyArray a -> Boolean\nall p = adaptAny $ A.all p\n\nfoldM :: forall m a b. Monad m => (b -> a -> m b) -> b -> NonEmptyArray a -> m b\nfoldM f acc = adaptAny $ A.foldM f acc\n\nfoldRecM :: forall m a b. MonadRec m => (b -> a -> m b) -> b -> NonEmptyArray a -> m b\nfoldRecM f acc = adaptAny $ A.foldRecM f acc\n\nunsafeIndex :: forall a. Partial => NonEmptyArray a -> Int -> a\nunsafeIndex = adaptAny A.unsafeIndex\n", "module Test.Spec.Tree\n  ( ActionWith\n  , Item(..)\n  , Path\n  , PathItem(..)\n  , Tree(..)\n  , annotateWithPaths\n  , bimapTreeWithPaths\n  , countTests\n  , discardUnfocused\n  , filterTree\n  , filterTrees\n  , isAllParallelizable\n  , mapTreeAnnotations\n  , modifyAroundAction\n  , parentSuite\n  , parentSuiteName\n  )\n  where\n\nimport Prelude\n\nimport Control.Monad.State (execState)\nimport Control.Monad.State as State\nimport Data.Array (mapMaybe, mapWithIndex, snoc)\nimport Data.Array.NonEmpty (NonEmptyArray)\nimport Data.Array.NonEmpty as NEA\nimport Data.Bifunctor (class Bifunctor, bimap, lmap)\nimport Data.Either (Either, either)\nimport Data.Foldable (class Foldable, all, foldMapDefaultL, foldl, foldr)\nimport Data.Maybe (Maybe(..), maybe)\nimport Data.Newtype (class Newtype, un)\nimport Data.Traversable (for, for_)\nimport Data.Tuple.Nested (type (/\\), (/\\))\n\ndata Tree n c a\n  = Node (Either n c) (Array (Tree n c a))\n  | Leaf n (Maybe a)\n\nderive instance Functor (Tree n c)\n\ninstance (Show c, Show a, Show n) => Show (Tree n c a) where\n  show (Node nc xs) = \"(Node \" <> show nc <> \" \" <> show xs <> \")\"\n  show (Leaf name t) = \"(Leaf \" <> show name <> \" \" <> show t <> \")\"\n\ninstance (Eq c, Eq a, Eq name) => Eq (Tree name c a) where\n  eq (Node nc1 xs1) (Node nc2 xs2) = nc1 == nc2 && xs1 == xs2\n  eq (Leaf n1 t1) (Leaf n2 t2) = n1 == n2 && t1 == t2\n  eq _ _ = false\n\nbimapTreeWithPaths :: \u2200 a b c d n. (Array n -> a -> b) -> (NonEmptyArray n -> c -> d) -> Tree n a c -> Tree n b d\nbimapTreeWithPaths g f = go []\n  where\n  go :: Array n -> Tree n a c -> Tree n b d\n  go namePath spec = case spec of\n    Node d xs ->\n      let\n        namePath' = either (snoc namePath) (const namePath) d\n      in\n        Node (map (g namePath') d) (map (go namePath') xs)\n    Leaf n item -> Leaf n (map (f $ NEA.snoc' namePath n) item)\n\ninstance Bifunctor (Tree n) where\n  bimap g f tree = case tree of\n    Node c cs -> Node (g <$> c) $ bimap g f <$> cs\n    Leaf n a -> Leaf n $ f <$> a\n\ninstance Foldable (Tree n c) where\n  foldr f i (Leaf _ a) = maybe i (\\a' -> f a' i) a\n  foldr f i (Node _ as) = foldr (\\a i' -> foldr f i' a) i as\n  foldl f i (Leaf _ a) = maybe i (\\a' -> f i a') a\n  foldl f i (Node _ as) = foldl (\\i' a -> foldl f i' a) i as\n  foldMap f = foldMapDefaultL f\n\ntype ActionWith m a = a -> m Unit\n\nnewtype Item m a = Item\n  { isFocused :: Boolean\n  , isParallelizable :: Maybe Boolean\n  , example :: (ActionWith m a -> m Unit) -> m Unit\n  }\n\nderive instance itemNewtype :: Newtype (Item m a) _\n\ninstance itemShow :: Show (Item m a) where\n  show (Item { isFocused, isParallelizable }) =\n    \"Item (\" <> show { isFocused, isParallelizable, example: \"Function\" } <> \")\"\n\ninstance itemEq :: Eq (Item m a) where\n  eq (Item a) (Item b) =\n    a.isFocused == b.isFocused && a.isParallelizable == b.isParallelizable\n\nannotateWithPaths :: \u2200 c a. Array (Tree String c a) -> Array (Tree (String /\\ Path) c a)\nannotateWithPaths = mapWithIndex $ go []\n  where\n    go path index = case _ of\n      Node c children ->\n        let name = either Just (const Nothing) c\n            nextPath = path <> [PathItem { index, name }]\n        in\n          Node (c # lmap (_ /\\ path)) (mapWithIndex (go nextPath) children)\n\n      Leaf name item ->\n        Leaf (name /\\ path) item\n\nmapTreeAnnotations :: \u2200 n m c a. (n -> m) -> Tree n c a -> Tree m c a\nmapTreeAnnotations f = case _ of\n  Node c cs -> Node (lmap f c) $ mapTreeAnnotations f <$> cs\n  Leaf n a -> Leaf (f n) a\n\nfilterTrees :: \u2200 n c a. (n -> Maybe a -> Boolean) -> Array (Tree n c a) -> Array (Tree n c a)\nfilterTrees f = mapMaybe $ filterTree f\n\nfilterTree :: \u2200 n c a. (n -> Maybe a -> Boolean) -> Tree n c a -> Maybe (Tree n c a)\nfilterTree f = case _ of\n  Node c children ->\n    case mapMaybe (filterTree f) children of\n      [] -> Nothing\n      cs -> Just $ Node c cs\n\n  Leaf n a\n    | f n a -> Just $ Leaf n a\n    | otherwise -> Nothing\n\n-- | Count the total number of tests in a spec\ncountTests :: \u2200 n c t. Array (Tree n c t) -> Int\ncountTests g = execState (for g go) 0\n  where\n  go (Node _ xs) = for_ xs go\n  go (Leaf _ _) = State.modify_ (_ + 1)\n\n-- | Return true if all items in the tree are parallelizable\nisAllParallelizable :: \u2200 n c m a. Tree n c (Item m a) -> Boolean\nisAllParallelizable = case _ of\n  Node _ xs -> all isAllParallelizable xs\n  Leaf _ x -> x == Nothing || (x >>= un Item >>> _.isParallelizable) == Just true\n\n-- | If there is at least one focused element, all paths which don't\n-- | lead to a focused element will be remove. otherwise input will\n-- | be returned as unchanged.\ndiscardUnfocused :: \u2200 n c m a. Array (Tree n c (Item m a)) -> Array (Tree n c (Item m a))\ndiscardUnfocused ts =\n  case filterTrees isFocused ts of\n    [] -> ts\n    r -> r\n  where\n    isFocused _ (Just (Item i)) = i.isFocused\n    isFocused _ Nothing = false\n\n-- | Modify around action of an Item\nmodifyAroundAction :: \u2200 g a b. (ActionWith g a -> ActionWith g b) -> Item g a -> Item g b\nmodifyAroundAction action (Item item) = Item $ item\n  { example = \\aroundAction -> item.example (aroundAction <<< action)\n  }\n\nnewtype PathItem = PathItem { index :: Int, name :: Maybe String }\n\nderive instance newtypePathItem :: Newtype PathItem _\nderive newtype instance showIdTerm :: Show PathItem\nderive newtype instance pathItemEq :: Eq PathItem\nderive newtype instance pathItemOrd :: Ord PathItem\n\ntype Path = Array PathItem\n\nparentSuiteName :: Path -> Array String\nparentSuiteName = mapMaybe (un PathItem >>> _.name)\n\nparentSuite :: Path -> Maybe { path :: Path, name :: String }\nparentSuite = flip foldr Nothing case _, _ of\n  PathItem { name: Just name }, Nothing -> Just { path: [], name }\n  PathItem { name: Nothing }, Nothing -> Nothing\n  p, Just acc -> Just acc { path = [ p ] <> acc.path }\n", "module Test.Spec\n  ( Spec\n  , SpecT(..)\n  , module Reexport\n  , SpecTree\n  , mapSpecTree\n  , collect\n\n  , ComputationType(..)\n  , hoistSpec\n\n  , class Example\n  , evaluateExample\n\n  , parallel\n  , sequential\n\n  , class FocusWarning\n  , focus\n  , describeOnly\n  , itOnly\n\n  , describe\n  , it\n  , pending\n  , pending'\n\n  , aroundWith\n  , around\n  , around_\n\n  , before\n  , before_\n  , beforeWith\n  , beforeAll\n  , beforeAll_\n\n  , after\n  , after_\n  , afterAll\n  , afterAll_\n  ) where\n\nimport Prelude\n\nimport Control.Alt (class Alt, (<|>))\nimport Control.Alternative (class Alternative)\nimport Control.Monad.Cont (class MonadCont, class MonadTrans)\nimport Control.Monad.Error.Class (class MonadError, class MonadThrow)\nimport Control.Monad.Fork.Class (class MonadBracket, bracket)\nimport Control.Monad.Reader (class MonadAsk, class MonadReader)\nimport Control.Monad.Rec.Class (class MonadRec)\nimport Control.Monad.State (class MonadState)\nimport Control.Monad.Writer (WriterT, execWriterT, mapWriterT, tell)\nimport Control.MonadPlus (class MonadPlus)\nimport Control.Plus (class Plus)\nimport Data.Array.NonEmpty (NonEmptyArray)\nimport Data.Bifunctor (bimap)\nimport Data.Either (Either(..), either)\nimport Data.Foldable (any)\nimport Data.Function (applyFlipped)\nimport Data.Identity (Identity)\nimport Data.Maybe (Maybe(..))\nimport Data.Newtype (class Newtype, over, un)\nimport Effect.AVar (AVar)\nimport Effect.AVar as AVarEff\nimport Effect.Aff (Aff, error, throwError, try)\nimport Effect.Aff.AVar as AVar\nimport Effect.Aff.Class (class MonadAff, liftAff)\nimport Effect.Class (class MonadEffect, liftEffect)\nimport Effect.Exception (Error)\nimport Prim.TypeError (class Warn, Text)\nimport Test.Spec.Tree (ActionWith, Item(..), Tree(..)) as Reexport\nimport Test.Spec.Tree (ActionWith, Item(..), Tree(..), bimapTreeWithPaths, discardUnfocused, modifyAroundAction)\n\n\ntype Spec a = SpecT Aff Unit Identity a\n\nnewtype SpecT g i m a = SpecT (WriterT (Array (SpecTree g i)) m a)\n\nderive instance newtypeSpecT :: Newtype (SpecT g i m a) _\nderive newtype instance functorSpecT :: Functor m => Functor (SpecT g i m)\nderive newtype instance applySpecT :: Apply m => Apply (SpecT g i m)\nderive newtype instance applicativeSpecT :: Applicative m => Applicative (SpecT g i m)\nderive newtype instance altSpecT :: Alt m => Alt (SpecT g i m)\nderive newtype instance plusSpecT :: Plus m => Plus (SpecT g i m)\nderive newtype instance alternativeSpecT :: (Alternative m) => Alternative (SpecT g i m)\nderive newtype instance bindSpecT :: Bind m => Bind (SpecT g i m)\nderive newtype instance monadSpecT :: Monad m => Monad (SpecT g i m)\nderive newtype instance monadRecSpecT :: MonadRec m => MonadRec (SpecT g i m)\nderive newtype instance monadPlusSpecT :: MonadPlus m => MonadPlus (SpecT g i m)\nderive newtype instance monadTransSpecT :: MonadTrans (SpecT g i)\nderive newtype instance monadEffectWriter :: MonadEffect m => MonadEffect (SpecT g i m)\nderive newtype instance monadContSpecT :: MonadCont m => MonadCont (SpecT g i m)\nderive newtype instance monadThrowSpecT :: MonadThrow e m => MonadThrow e (SpecT g i m)\nderive newtype instance monadErrorSpecT :: MonadError e m => MonadError e (SpecT g i m)\nderive newtype instance monadAskSpecT :: MonadAsk r m => MonadAsk r (SpecT g i m)\nderive newtype instance monadReaderSpecT :: MonadReader r m => MonadReader r (SpecT g i m)\nderive newtype instance monadStateSpecT :: MonadState s m => MonadState s (SpecT g i m)\n\n-- | A specialization of `Tree` for the tree of actual tests. While `Tree` is a\n-- | tree of abstract things, `SpecTree` is a tree of tests, each represented by\n-- | `Item`.\ntype SpecTree m a = Tree String (ActionWith m a) (Item m a)\n\nmapSpecTree\n  :: forall m m' g g' i a i'\n   . Functor m'\n   => (m ~> m')\n   -> (SpecTree g i -> SpecTree g' i')\n   -> SpecT g i m a\n   -> SpecT g' i' m' a\nmapSpecTree g f = over SpecT $ mapWriterT $ g >>> map (map $ map f)\n\ndata ComputationType = CleanUpWithContext (Array String) | TestWithName (NonEmptyArray String)\n\nhoistSpec :: forall m' m i a b. Monad m' => (m ~> m') -> (ComputationType -> a ~> b) -> SpecT a i m ~> SpecT b i m'\nhoistSpec onM f = mapSpecTree onM $ bimapTreeWithPaths onCleanUp onTest\n  where\n    onCleanUp :: Array String -> (ActionWith a i) -> ActionWith b i\n    onCleanUp name around' = \\i -> f (CleanUpWithContext name) (around' i)\n    onTest :: NonEmptyArray String -> Item a i -> Item b i\n    onTest name = over Item \\item ->\n      let\n        e :: ((i -> b Unit) -> b Unit) -> b Unit\n        e g = g (f (TestWithName name) <<< item.example <<< applyFlipped)\n      in item { example = e }\n\n\n-- | Collects all tests, if something is focused, all unfocused tests will be discarded\ncollect :: forall m g i a. Functor m => SpecT g i m a -> m (Array (SpecTree g i))\ncollect = un SpecT >>> execWriterT >>> map discardUnfocused\n\nclass Example t arg m | t -> arg, t -> m where\n  evaluateExample :: t -> (ActionWith m arg -> m Unit) -> m Unit\n\ninstance exampleFunc :: Example (arg -> m Unit) arg m where\n  evaluateExample :: (arg -> m Unit) -> (ActionWith m arg -> m Unit) -> m Unit\n  evaluateExample t around' = around' t\n\nelse instance exampleMUnit :: Example (m Unit) Unit m where\n  evaluateExample :: (m Unit) -> (ActionWith m Unit -> m Unit) -> m Unit\n  evaluateExample t around' = around' $ \\_ -> t\n\n\n-- | Nullary class used to raise a custom warning for the focusing functions.\nclass FocusWarning\n\ninstance warn :: Warn (Text \"Test.Spec.focus usage\") => FocusWarning\n\n-- ---------------------\n-- --       DSL       --\n-- ---------------------\n\n-- | `focus` focuses all spec items of the given spec.\n-- |\n-- | Applying `focus` to a spec with focused spec items has no effect.\nfocus :: forall m g i a. FocusWarning => Monad m => SpecT g i m a -> SpecT g i m a\nfocus = over SpecT $ mapWriterT $ map $ map \\xs ->\n  if any (any $ un Item >>> _.isFocused) xs\n    then xs\n    else map (bimap identity (\\(Item r) -> Item r {isFocused = true})) xs\n\n\n-- | Combine a group of specs into a described hierarchy.\ndescribe\n  :: forall m g i a\n   . Monad m\n  => String\n  -> SpecT g i m a\n  -> SpecT g i m a\ndescribe name = over SpecT $ mapWriterT $ map $ map \\group -> [Node (Left name) group]\n\n\n-- | Combine a group of specs into a described hierarchy and mark it as the\n-- | only group to actually be evaluated. (useful for quickly narrowing down\n-- | on a set)\ndescribeOnly\n  :: forall m g i a\n   . FocusWarning\n  => Monad m\n  => String\n  -> SpecT g i m a\n  -> SpecT g i m a\ndescribeOnly = map focus <<< describe\n\n-- | marks all spec items of the given spec to be safe for parallel evaluation.\nparallel\n  :: forall m g i a\n   . Monad m\n  => SpecT g i m a\n  -> SpecT g i m a\nparallel = mapSpecTree identity $ bimap identity (setParallelizable true)\n\n-- | marks all spec items of the given spec to be evaluated sequentially.\nsequential\n  :: forall m g i a\n   . Monad m\n  => SpecT g i m a\n  -> SpecT g i m a\nsequential = mapSpecTree identity $ bimap identity (setParallelizable false)\n\nsetParallelizable :: forall g a. Boolean -> Item g a -> Item g a\nsetParallelizable value = over Item \\i -> i{isParallelizable = i.isParallelizable <|> Just value}\n\n-- | Create a pending spec.\npending\n  :: forall m g i\n   . Monad m\n  => String\n  -> SpecT g i m Unit\npending name = SpecT $ tell [Leaf name Nothing]\n\n-- | Create a pending spec with a body that is ignored by\n-- | the runner. It can be useful for documenting what the\n-- | spec should test when non-pending.\npending'\n  :: forall m g i\n   . Monad m\n  => String\n  -> g Unit\n  -> SpecT g i m Unit\npending' name _ = pending name\n\n-- | Create a spec with a description.\nit\n  :: forall m t arg g\n   . Monad m\n  => Example t arg g\n  => String\n  -> t\n  -> SpecT g arg m Unit\nit name test = SpecT $ tell\n  [ Leaf name $ Just $ Item\n      { isParallelizable: Nothing\n      , isFocused: false\n      , example: evaluateExample test\n      }\n  ]\n\n-- | Create a spec with a description and mark it as the only one to\n-- | be run. (useful for quickly narrowing down on a single test)\nitOnly\n  :: forall m t arg g\n   . FocusWarning\n  => Monad m\n  => Example t arg g\n  => String\n  -> t\n  -> SpecT g arg m Unit\nitOnly = map focus <<< it\n\n\n-- ---------------------\n-- --      HOOKS      --\n-- ---------------------\n\n-- | Run a custom action before and/or after every spec item.\naroundWith\n  :: forall m g i i' a\n   . Monad m\n  => (ActionWith g i -> ActionWith g i')\n  -> SpecT g i m a\n  -> SpecT g i' m a\naroundWith action = mapSpecTree identity $ bimap action (modifyAroundAction action)\n\n-- | Run a custom action before and/or after every spec item.\naround_ :: forall m g i a. Monad m => (g Unit -> g Unit) -> SpecT g i m a -> SpecT g i m a\naround_ action = aroundWith $ \\e a -> action (e a)\n\n-- | Run a custom action after every spec item.\nafter :: forall m g e f i a. Monad m => MonadBracket e f g => ActionWith g i -> SpecT g i m a -> SpecT g i m a\nafter action = aroundWith $ \\e x -> e x `finally` action x\n  where\n  finally :: forall x. g x -> g Unit -> g x\n  finally act fin = bracket (pure unit) (\\_ _ -> fin) (const act)\n\n-- | Run a custom action after every spec item.\nafter_ :: forall m g e f i a. Monad m => MonadBracket e f g => g Unit -> SpecT g i m a -> SpecT g i m a\nafter_ action = after $ \\_ -> action\n\n-- | Run a custom action before and/or after every spec item.\naround :: forall m g i a. Monad m => (ActionWith g i -> g Unit) -> SpecT g i m a -> SpecT g Unit m a\naround action = aroundWith $ \\e _ -> action e\n\n-- | Run a custom action before every spec item.\nbefore :: forall m g i a. Monad m => Monad g => g i -> SpecT g i m a -> SpecT g Unit m a\nbefore action = around (action >>= _)\n\n-- | Run a custom action before every spec item.\nbefore_ :: forall m g i a. Monad m => Monad g => g Unit -> SpecT g i m a -> SpecT g i m a\nbefore_ action = around_ (action *> _)\n\n-- | Run a custom action before every spec item.\nbeforeWith :: forall m g i i' a. Monad m => Monad g => (i' -> g i) -> SpecT g i m a -> SpecT g i' m a\nbeforeWith action = aroundWith $ \\e x -> action x >>= e\n\n-- | Run a custom action before the first spec item.\nbeforeAll :: forall m g i a. MonadEffect m => MonadAff g => MonadError Error g => g i -> SpecT g i m a -> SpecT g Unit m a\nbeforeAll action spec = do\n  var <- liftEffect $ AVarEff.new MEmpty\n  before (memoize var action) spec\n\n-- | Run a custom action before the first spec item.\nbeforeAll_ :: forall m g i a. MonadEffect m => MonadAff g => MonadError Error g => g Unit -> SpecT g i m a -> SpecT g i m a\nbeforeAll_ action spec = do\n  var <- liftEffect $ AVarEff.new MEmpty\n  before_ (memoize var action) spec\n\ndata Memoized a\n  = MEmpty\n  | MMemoized a\n  | MFailed Error\n\nmemoize :: forall a m. MonadAff m => MonadError Error m => AVar (Memoized a) -> m a -> m a\nmemoize var action = do\n  liftAff (AVar.take var) >>= case _ of\n    MFailed _ -> throwError $ error \"exception in beforeAll-hook (see previous failure)\"\n    MMemoized x -> pure x <* (liftAff $ AVar.put (MMemoized x) var)\n    MEmpty -> do\n      res <- try action\n      liftAff $ AVar.put (either MFailed MMemoized res) var\n      either throwError pure res\n\n-- | Run a custom action after the last spec item.\nafterAll :: forall m g i a. Monad m => ActionWith g i -> SpecT g i m a -> SpecT g i m a\nafterAll action = over SpecT $ mapWriterT $ map $ map \\group -> [Node (Right action) group]\n\n-- | Run a custom action after the last spec item.\nafterAll_ :: forall m g i a. Monad m => g Unit -> SpecT g i m a -> SpecT g i m a\nafterAll_ action = afterAll $ const action\n", "module Test.Spec.Assertions\n  ( AnyShow(..)\n  , expectError\n  , fail\n  , shouldContain\n  , shouldEqual\n  , shouldNotContain\n  , shouldNotEqual\n  , shouldNotReturn\n  , shouldNotSatisfy\n  , shouldReturn\n  , shouldSatisfy\n  )\n  where\n\nimport Prelude\n\nimport Control.Monad.Error.Class (class MonadError, class MonadThrow, throwError, try)\nimport Data.Either (Either(..))\nimport Data.Foldable (class Foldable, notElem, elem)\nimport Data.Newtype (class Newtype)\nimport Effect.Exception (Error, error)\n\nfail :: forall m. MonadThrow Error m => String -> m Unit\nfail = throwError <<< error\n\nforeign import unsafeStringify :: forall a. a -> String\n\n-- | A newtype with an unsafe `Show` instance for any type.\n-- | Useful if you want to test a type for which you cannot provide a `Show` instance.\n-- | Usage:\n-- | ```purescript\n-- | (AnyShow $ MyInt 3) `A.shouldEqual` (AnyShow $ MyInt 3)\n-- | ```\nnewtype AnyShow a = AnyShow a\ninstance Newtype (AnyShow a) a\nderive newtype instance (Eq a) => Eq (AnyShow a)\ninstance Show (AnyShow a) where\n  show = unsafeStringify\n\nshouldEqual\n  :: forall m t\n   . MonadThrow Error m\n  => Show t\n  => Eq t\n  => t\n  -> t\n  -> m Unit\nshouldEqual v1 v2 =\n  when (v1 /= v2) $\n    fail $ show v1 <> \" \u2260 \" <> show v2\n\nshouldNotEqual\n  :: forall m t\n   . MonadThrow Error m\n  => Show t\n  => Eq t\n  => t\n  -> t\n  -> m Unit\nshouldNotEqual v1 v2 =\n  when (v1 == v2) $\n    fail $ show v1 <> \" = \" <> show v2\n\nshouldSatisfy\n  :: forall m t\n   . MonadThrow Error m\n  => Show t\n  => t\n  -> (t -> Boolean)\n  -> m Unit\nshouldSatisfy v pred =\n  unless (pred v) $\n    fail $ show v <> \" doesn't satisfy predicate\"\n\nshouldNotSatisfy\n  :: forall m t\n   . MonadThrow Error m\n  => Show t\n  => t\n  -> (t -> Boolean)\n  -> m Unit\nshouldNotSatisfy v pred =\n  when (pred v) $\n    fail $ show v <> \" satisfies predicate, but should not\"\n\nshouldContain\n  :: forall m f a\n   . MonadThrow Error m\n  => Show a\n  => Eq a\n  => Show (f a)\n  => Foldable f\n  => f a\n  -> a\n  -> m Unit\nshouldContain c e =\n  when (e `notElem` c) $\n    fail $ (show e) <> \" \u2209 \" <> (show c)\n\nshouldNotContain\n  :: forall m f a\n   . MonadThrow Error m\n  => Show a\n  => Eq a\n  => Show (f a)\n  => Foldable f\n  => f a\n  -> a\n  -> m Unit\nshouldNotContain c e =\n  when (e `elem` c) $\n    fail $ (show e) <> \" \u2208 \" <> (show c)\n\nexpectError\n  :: forall m t\n   . MonadError Error m\n  => m t\n  -> m Unit\nexpectError a = do\n  e <- try a\n  case e of\n    Left _ -> pure unit\n    Right _ -> throwError $ error \"Expected error\"\n\n-- | Asserts that `m t` returns `t`\nshouldReturn\n  :: forall m t\n   . MonadThrow Error m\n  => Eq t\n  => Show t\n  => m t\n  -> t\n  -> m Unit\nshouldReturn ft t = ft >>= (_ `shouldEqual` t)\n\n-- | Asserts that `m t` does not return `t`\nshouldNotReturn\n  :: forall m t\n   . MonadThrow Error m\n  => Eq t\n  => Show t\n  => m t\n  -> t\n  -> m Unit\nshouldNotReturn ft t = ft >>= (_ `shouldNotEqual` t)\n", "module Test.Node.Stream.Object where\n\nimport Prelude\n\nimport Data.Newtype (wrap)\nimport Effect.Aff (delay)\nimport Effect.Aff.Class (liftAff)\nimport Node.Stream.Object as Stream\nimport Test.Spec (Spec, describe, it)\nimport Test.Spec.Assertions (shouldEqual)\n\nspec :: Spec Unit\nspec =\n  describe \"Node.Stream.Object\" do\n    describe \"ObjectStream\" do\n      describe \"once\" do\n        it \"emits once\" do\n          out <- Stream.run (Stream.once 1)\n          out `shouldEqual` [ 1 ]\n      describe \"never\" do\n        it \"immediately closes\" do\n          out <- Stream.run Stream.never\n          out `shouldEqual` ([] :: Array Int)\n      describe \"chain\" do\n        it \"noops\" do\n          out <- Stream.run $ Stream.chainMany []\n          out `shouldEqual` ([] :: Array Int)\n        it \"works with 1 stream\" do\n          out <- Stream.run $ Stream.chainMany [Stream.once 1]\n          out `shouldEqual` [1]\n        it \"works with 2 streams\" do\n          out <- Stream.run $ Stream.chainMany [Stream.once 1, Stream.once 2]\n          out `shouldEqual` [1, 2]\n        it \"does not emit end until last child stream ends\" do\n          let\n            delayed n a = liftAff do\n              delay $ wrap n\n              pure a\n          out <- Stream.run $ Stream.chainMany [delayed 10.0 1, delayed 20.0 2]\n          out `shouldEqual` [1, 2]\n      describe \"fromFoldable\" do\n        it \"creates an empty readable\" do\n          out <- Stream.run (Stream.fromFoldable [] :: Stream.ObjectStream Unit (Array Int))\n          out `shouldEqual` []\n        it \"creates a readable that emits each element\" do\n          out <- Stream.run (Stream.fromFoldable [ 1, 2, 3 ])\n          out `shouldEqual` [ 1, 2, 3 ]\n        it \"bind maps each number\" do\n          out <- Stream.run do\n            a <- Stream.fromFoldable [ 1, 2, 3 ]\n            pure $ a + 1\n          out `shouldEqual` [ 2, 3, 4 ]\n        it \"bind fans out\" do\n          out <- Stream.run do\n            a <- Stream.fromFoldable [ 1, 2, 3 ]\n            Stream.fromFoldable [a * 10, a * 20]\n          out `shouldEqual` [ 10, 20, 20, 40, 30, 60 ]\n", "module Test.Spec.Config\n  ( Config\n  , TreeFilter(..)\n  , defaultConfig\n  )\n  where\n\nimport Prelude\n\nimport Data.Maybe (Maybe(..))\nimport Data.Time.Duration (Milliseconds(..))\nimport Test.Spec (SpecTree)\n\ntype Config =\n  { slow :: Milliseconds\n  -- ^ Threshold of time beyond which a test is considered \"slow\".\n\n  , timeout :: Maybe Milliseconds\n  -- ^ An optional timeout, applied to each individual test. When omitted, tests\n  -- are allowed to run forever.\n\n  , exit :: Boolean\n  -- ^ When `true`, the runner will exit the Node process after running tests.\n  -- If `false`, the runner will merely return test results.\n\n  , failFast :: Boolean\n  -- ^ When `true`, first failed test stops the whole run.\n\n  , filterTree :: TreeFilter\n  -- ^ The spec tree goes through this function before execution. Can be used to\n  -- filter out test cases, rearrange, annotate, etc.\n  }\n\nnewtype TreeFilter = TreeFilter (\u2200 g i. Array (SpecTree g i) -> Array (SpecTree g i))\n\ndefaultConfig :: Config\ndefaultConfig =\n  { slow: Milliseconds 75.0\n  , timeout: Just $ Milliseconds 2000.0\n  , exit: true\n  , failFast: false\n  , filterTree: TreeFilter identity\n  }\n", "-- | This module defines a type of maps as height-balanced (AVL) binary trees.\n-- | Efficient set operations are implemented in terms of\n-- | <https://www.cs.cmu.edu/~guyb/papers/BFS16.pdf>\n\nmodule Data.Map.Internal\n  ( Map(..)\n  , showTree\n  , empty\n  , isEmpty\n  , singleton\n  , checkValid\n  , insert\n  , insertWith\n  , lookup\n  , lookupLE\n  , lookupLT\n  , lookupGE\n  , lookupGT\n  , findMin\n  , findMax\n  , foldSubmap\n  , submap\n  , fromFoldable\n  , fromFoldableWith\n  , fromFoldableWithIndex\n  , toUnfoldable\n  , toUnfoldableUnordered\n  , delete\n  , pop\n  , member\n  , alter\n  , update\n  , keys\n  , values\n  , union\n  , unionWith\n  , unions\n  , intersection\n  , intersectionWith\n  , difference\n  , isSubmap\n  , size\n  , filterWithKey\n  , filterKeys\n  , filter\n  , mapMaybeWithKey\n  , mapMaybe\n  , catMaybes\n  , any\n  , anyWithKey\n  , MapIter\n  , MapIterStep(..)\n  , toMapIter\n  , stepAsc\n  , stepAscCps\n  , stepDesc\n  , stepDescCps\n  , stepUnordered\n  , stepUnorderedCps\n  , unsafeNode\n  , unsafeBalancedNode\n  , unsafeJoinNodes\n  , unsafeSplit\n  , Split(..)\n  ) where\n\nimport Prelude\n\nimport Control.Alt (class Alt)\nimport Control.Plus (class Plus)\nimport Data.Eq (class Eq1)\nimport Data.Foldable (class Foldable, foldl, foldr)\nimport Data.FoldableWithIndex (class FoldableWithIndex, foldlWithIndex, foldrWithIndex)\nimport Data.Function.Uncurried (Fn2, Fn3, Fn4, Fn7, mkFn2, mkFn3, mkFn4, mkFn7, runFn2, runFn3, runFn4, runFn7)\nimport Data.FunctorWithIndex (class FunctorWithIndex)\nimport Data.List (List(..), (:))\nimport Data.Maybe (Maybe(..))\nimport Data.Ord (class Ord1, abs)\nimport Data.Traversable (traverse, class Traversable)\nimport Data.TraversableWithIndex (class TraversableWithIndex)\nimport Data.Tuple (Tuple(Tuple))\nimport Data.Unfoldable (class Unfoldable, unfoldr)\nimport Prim.TypeError (class Warn, Text)\n\n-- | `Map k v` represents maps from keys of type `k` to values of type `v`.\ndata Map k v = Leaf | Node Int Int k v (Map k v) (Map k v)\n\ntype role Map nominal representational\n\ninstance eq1Map :: Eq k => Eq1 (Map k) where\n  eq1 = eq\n\ninstance eqMap :: (Eq k, Eq v) => Eq (Map k v) where\n  eq xs ys = case xs of\n    Leaf ->\n      case ys of\n        Leaf -> true\n        _ -> false\n    Node _ s1 _ _ _ _ ->\n      case ys of\n        Node _ s2 _ _ _ _\n          | s1 == s2 ->\n              toMapIter xs == toMapIter ys\n        _ ->\n          false\n\ninstance ord1Map :: Ord k => Ord1 (Map k) where\n  compare1 = compare\n\ninstance ordMap :: (Ord k, Ord v) => Ord (Map k v) where\n  compare xs ys = case xs of\n    Leaf ->\n      case ys of\n        Leaf -> EQ\n        _ -> LT\n    _ ->\n      case ys of\n        Leaf -> GT\n        _ -> compare (toMapIter xs) (toMapIter ys)\n\ninstance showMap :: (Show k, Show v) => Show (Map k v) where\n  show as = \"(fromFoldable \" <> show (toUnfoldable as :: Array _) <> \")\"\n\ninstance semigroupMap ::\n  ( Warn (Text \"Data.Map's `Semigroup` instance is now unbiased and differs from the left-biased instance defined in PureScript releases <= 0.13.x.\")\n  , Ord k\n  , Semigroup v\n  ) => Semigroup (Map k v) where\n  append = unionWith append\n\ninstance monoidSemigroupMap ::\n  ( Warn (Text \"Data.Map's `Semigroup` instance is now unbiased and differs from the left-biased instance defined in PureScript releases <= 0.13.x.\")\n  , Ord k\n  , Semigroup v\n  ) => Monoid (Map k v) where\n  mempty = empty\n\ninstance altMap :: Ord k => Alt (Map k) where\n  alt = union\n\ninstance plusMap :: Ord k => Plus (Map k) where\n  empty = empty\n\ninstance functorMap :: Functor (Map k) where\n  map f = go\n    where\n    go = case _ of\n      Leaf -> Leaf\n      Node h s k v l r ->\n        Node h s k (f v) (go l) (go r)\n\ninstance functorWithIndexMap :: FunctorWithIndex k (Map k) where\n  mapWithIndex f = go\n    where\n    go = case _ of\n      Leaf -> Leaf\n      Node h s k v l r ->\n        Node h s k (f k v) (go l) (go r)\n\ninstance applyMap :: Ord k => Apply (Map k) where\n  apply = intersectionWith identity\n\ninstance bindMap :: Ord k => Bind (Map k) where\n  bind m f = mapMaybeWithKey (\\k -> lookup k <<< f) m\n\ninstance foldableMap :: Foldable (Map k) where\n  foldr f z = \\m -> runFn2 go m z\n    where\n    go = mkFn2 \\m' z' -> case m' of\n      Leaf -> z'\n      Node _ _ _ v l r ->\n        runFn2 go l (f v (runFn2 go r z'))\n  foldl f z = \\m -> runFn2 go z m\n    where\n    go = mkFn2 \\z' m' -> case m' of\n      Leaf -> z'\n      Node _ _ _ v l r ->\n        runFn2 go (f (runFn2 go z' l) v) r\n  foldMap f = go\n    where\n    go = case _ of\n      Leaf -> mempty\n      Node _ _ _ v l r ->\n        go l <> f v <> go r\n\ninstance foldableWithIndexMap :: FoldableWithIndex k (Map k) where\n  foldrWithIndex f z = \\m -> runFn2 go m z\n    where\n    go = mkFn2 \\m' z' -> case m' of\n      Leaf -> z'\n      Node _ _ k v l r ->\n        runFn2 go l (f k v (runFn2 go r z'))\n  foldlWithIndex f z = \\m -> runFn2 go z m\n    where\n    go = mkFn2 \\z' m' -> case m' of\n      Leaf -> z'\n      Node _ _ k v l r ->\n        runFn2 go (f k (runFn2 go z' l) v) r\n  foldMapWithIndex f = go\n    where\n    go = case _ of\n      Leaf -> mempty\n      Node _ _ k v l r ->\n        go l <> f k v <> go r\n\ninstance traversableMap :: Traversable (Map k) where\n  traverse f = go\n    where\n    go = case _ of\n      Leaf -> pure Leaf\n      Node h s k v l r ->\n        (\\l' v' r' -> Node h s k v' l' r')\n          <$> go l\n          <*> f v\n          <*> go r\n  sequence = traverse identity\n\ninstance traversableWithIndexMap :: TraversableWithIndex k (Map k) where\n  traverseWithIndex f = go\n    where\n    go = case _ of\n      Leaf -> pure Leaf\n      Node h s k v l r ->\n        (\\l' v' r' -> Node h s k v' l' r')\n          <$> go l\n          <*> f k v\n          <*> go r\n\n-- | Render a `Map` as a `String`\nshowTree :: forall k v. Show k => Show v => Map k v -> String\nshowTree = go \"\"\n  where\n  go ind = case _ of\n    Leaf -> ind <> \"Leaf\"\n    Node h _ k v l r ->\n      (ind <> \"[\" <> show h  <> \"] \" <> show k <> \" => \" <> show v <> \"\\n\")\n        <> (go (ind <> \"    \") l <> \"\\n\")\n        <> (go (ind <> \"    \") r)\n\n-- | An empty map\nempty :: forall k v. Map k v\nempty = Leaf\n\n-- | Test if a map is empty\nisEmpty :: forall k v. Map k v -> Boolean\nisEmpty Leaf = true\nisEmpty _ = false\n\n-- | Create a map with one key/value pair\nsingleton :: forall k v. k -> v -> Map k v\nsingleton k v = Node 1 1 k v Leaf Leaf\n\n-- | Check whether the underlying tree satisfies the height, size, and ordering invariants.\n-- |\n-- | This function is provided for internal use.\ncheckValid :: forall k v. Ord k => Map k v -> Boolean\ncheckValid = go\n  where\n  go = case _ of\n    Leaf -> true\n    Node h s k _ l r ->\n      case l of\n        Leaf ->\n          case r of\n            Leaf ->\n              true\n            Node rh rs rk _ _ _ ->\n              h == 2 && rh == 1 && s > rs && rk > k && go r\n        Node lh ls lk _ _ _ ->\n          case r of\n            Leaf ->\n              h == 2 && lh == 1 && s > ls && lk < k && go l\n            Node rh rs rk _ _ _ ->\n              h > rh && rk > k && h > lh && lk < k && abs (rh - lh) < 2 && rs + ls + 1 == s && go l && go r\n\n-- | Look up a value for the specified key\nlookup :: forall k v. Ord k => k -> Map k v -> Maybe v\nlookup k = go\n  where\n  go = case _ of\n    Leaf -> Nothing\n    Node _ _ mk mv ml mr ->\n      case compare k mk of\n        LT -> go ml\n        GT -> go mr\n        EQ -> Just mv\n\n-- | Look up a value for the specified key, or the greatest one less than it\nlookupLE :: forall k v. Ord k => k -> Map k v -> Maybe { key :: k, value :: v }\nlookupLE k = go\n  where\n  go = case _ of\n    Leaf -> Nothing\n    Node _ _ mk mv ml mr ->\n      case compare k mk of\n        LT -> go ml\n        GT ->\n          case go mr of\n            Nothing -> Just { key: mk, value: mv }\n            other -> other\n        EQ ->\n          Just { key: mk, value: mv }\n\n-- | Look up a value for the greatest key less than the specified key\nlookupLT :: forall k v. Ord k => k -> Map k v -> Maybe { key :: k, value :: v }\nlookupLT k = go\n  where\n  go = case _ of\n    Leaf -> Nothing\n    Node _ _ mk mv ml mr ->\n      case compare k mk of\n        LT -> go ml\n        GT ->\n          case go mr of\n            Nothing -> Just { key: mk, value: mv }\n            other -> other\n        EQ ->\n          findMax ml\n\n-- | Look up a value for the specified key, or the least one greater than it\nlookupGE :: forall k v. Ord k => k -> Map k v -> Maybe { key :: k, value :: v }\nlookupGE k = go\n  where\n  go = case _ of\n    Leaf -> Nothing\n    Node _ _ mk mv ml mr ->\n      case compare k mk of\n        LT ->\n          case go ml of\n            Nothing -> Just { key: mk, value: mv }\n            other -> other\n        GT -> go mr\n        EQ -> Just { key: mk, value: mv }\n\n-- | Look up a value for the least key greater than the specified key\nlookupGT :: forall k v. Ord k => k -> Map k v -> Maybe { key :: k, value :: v }\nlookupGT k = go\n  where\n  go = case _ of\n    Leaf -> Nothing\n    Node _ _ mk mv ml mr ->\n      case compare k mk of\n        LT ->\n          case go ml of\n            Nothing -> Just { key: mk, value: mv }\n            other -> other\n        GT -> go mr\n        EQ -> findMin mr\n\n-- | Returns the pair with the greatest key\nfindMax :: forall k v. Map k v -> Maybe { key :: k, value :: v }\nfindMax = case _ of\n  Leaf -> Nothing\n  Node _ _ k v  _ r ->\n    case r of\n      Leaf -> Just { key: k, value: v }\n      _ -> findMax r\n\n-- | Returns the pair with the least key\nfindMin :: forall k v. Map k v -> Maybe { key :: k, value :: v }\nfindMin = case _ of\n  Leaf -> Nothing\n  Node _ _ k v l _ ->\n    case l of\n      Leaf -> Just { key: k, value: v }\n      _ -> findMin l\n\n-- | Fold over the entries of a given map where the key is between a lower and\n-- | an upper bound. Passing `Nothing` as either the lower or upper bound\n-- | argument means that the fold has no lower or upper bound, i.e. the fold\n-- | starts from (or ends with) the smallest (or largest) key in the map.\n-- |\n-- | ```purescript\n-- | foldSubmap (Just 1) (Just 2) (\\_ v -> [v])\n-- |  (fromFoldable [Tuple 0 \"zero\", Tuple 1 \"one\", Tuple 2 \"two\", Tuple 3 \"three\"])\n-- |  == [\"one\", \"two\"]\n-- |\n-- | foldSubmap Nothing (Just 2) (\\_ v -> [v])\n-- |  (fromFoldable [Tuple 0 \"zero\", Tuple 1 \"one\", Tuple 2 \"two\", Tuple 3 \"three\"])\n-- |  == [\"zero\", \"one\", \"two\"]\n-- | ```\nfoldSubmap :: forall k v m. Ord k => Monoid m => Maybe k -> Maybe k -> (k -> v -> m) -> Map k v -> m\nfoldSubmap = foldSubmapBy (<>) mempty\n\nfoldSubmapBy :: forall k v m. Ord k => (m -> m -> m) -> m -> Maybe k -> Maybe k -> (k -> v -> m) -> Map k v -> m\nfoldSubmapBy appendFn memptyValue kmin kmax f =\n  let\n    tooSmall =\n      case kmin of\n        Just kmin' ->\n          \\k -> k < kmin'\n        Nothing ->\n          const false\n\n    tooLarge =\n      case kmax of\n        Just kmax' ->\n          \\k -> k > kmax'\n        Nothing ->\n          const false\n\n    inBounds =\n      case kmin, kmax of\n        Just kmin', Just kmax' ->\n          \\k -> kmin' <= k && k <= kmax'\n        Just kmin', Nothing ->\n          \\k -> kmin' <= k\n        Nothing, Just kmax' ->\n          \\k -> k <= kmax'\n        Nothing, Nothing ->\n          const true\n\n    go = case _ of\n      Leaf ->\n        memptyValue\n      Node _ _ k v left right ->\n                    (if tooSmall k then memptyValue else go left)\n        `appendFn` (if inBounds k then f k v else memptyValue)\n        `appendFn` (if tooLarge k then memptyValue else go right)\n  in\n    go\n\n-- | Returns a new map containing all entries of the given map which lie\n-- | between a given lower and upper bound, treating `Nothing` as no bound i.e.\n-- | including the smallest (or largest) key in the map, no matter how small\n-- | (or large) it is. For example:\n-- |\n-- | ```purescript\n-- | submap (Just 1) (Just 2)\n-- |   (fromFoldable [Tuple 0 \"zero\", Tuple 1 \"one\", Tuple 2 \"two\", Tuple 3 \"three\"])\n-- |   == fromFoldable [Tuple 1 \"one\", Tuple 2 \"two\"]\n-- |\n-- | submap Nothing (Just 2)\n-- |   (fromFoldable [Tuple 0 \"zero\", Tuple 1 \"one\", Tuple 2 \"two\", Tuple 3 \"three\"])\n-- |   == fromFoldable [Tuple 0 \"zero\", Tuple 1 \"one\", Tuple 2 \"two\"]\n-- | ```\n-- |\n-- | The function is entirely specified by the following\n-- | property:\n-- |\n-- | ```purescript\n-- | Given any m :: Map k v, mmin :: Maybe k, mmax :: Maybe k, key :: k,\n-- |   let m' = submap mmin mmax m in\n-- |     if (maybe true (\\min -> min <= key) mmin &&\n-- |         maybe true (\\max -> max >= key) mmax)\n-- |       then lookup key m == lookup key m'\n-- |       else not (member key m')\n-- | ```\nsubmap :: forall k v. Ord k => Maybe k -> Maybe k -> Map k v -> Map k v\nsubmap kmin kmax = foldSubmapBy union empty kmin kmax singleton\n\n-- | Test if a key is a member of a map\nmember :: forall k v. Ord k => k -> Map k v -> Boolean\nmember k = go\n  where\n  go = case _ of\n    Leaf -> false\n    Node _ _ mk _ ml mr ->\n      case compare k mk of\n        LT -> go ml\n        GT -> go mr\n        EQ -> true\n\n-- | Insert or replace a key/value pair in a map\ninsert :: forall k v. Ord k => k -> v -> Map k v -> Map k v\ninsert k v = go\n  where\n  go = case _ of\n    Leaf -> singleton k v\n    Node mh ms mk mv ml mr ->\n      case compare k mk of\n        LT -> runFn4 unsafeBalancedNode mk mv (go ml) mr\n        GT -> runFn4 unsafeBalancedNode mk mv ml (go mr)\n        EQ -> Node mh ms k v ml mr\n\n-- | Inserts or updates a value with the given function.\n-- |\n-- | The combining function is called with the existing value as the first\n-- | argument and the new value as the second argument.\ninsertWith :: forall k v. Ord k => (v -> v -> v) -> k -> v -> Map k v -> Map k v\ninsertWith app k v = go\n  where\n  go = case _ of\n    Leaf -> singleton k v\n    Node mh ms mk mv ml mr ->\n      case compare k mk of\n        LT -> runFn4 unsafeBalancedNode mk mv (go ml) mr\n        GT -> runFn4 unsafeBalancedNode mk mv ml (go mr)\n        EQ -> Node mh ms k (app mv v) ml mr\n\n-- | Delete a key and its corresponding value from a map.\ndelete :: forall k v. Ord k => k -> Map k v -> Map k v\ndelete k = go\n  where\n  go = case _ of\n    Leaf -> Leaf\n    Node _ _ mk mv ml mr ->\n      case compare k mk of\n        LT -> runFn4 unsafeBalancedNode mk mv (go ml) mr\n        GT -> runFn4 unsafeBalancedNode mk mv ml (go mr)\n        EQ -> runFn2 unsafeJoinNodes ml mr\n\n-- | Delete a key and its corresponding value from a map, returning the value\n-- | as well as the subsequent map.\npop :: forall k v. Ord k => k -> Map k v -> Maybe (Tuple v (Map k v))\npop k m = do\n  let (Split x l r) = runFn3 unsafeSplit compare k m\n  map (\\a -> Tuple a (runFn2 unsafeJoinNodes l r)) x\n\n-- | Insert the value, delete a value, or update a value for a key in a map\nalter :: forall k v. Ord k => (Maybe v -> Maybe v) -> k -> Map k v -> Map k v\nalter f k m = do\n  let Split v l r = runFn3 unsafeSplit compare k m\n  case f v of\n    Nothing ->\n      runFn2 unsafeJoinNodes l r\n    Just v' ->\n      runFn4 unsafeBalancedNode k v' l r\n\n-- | Update or delete the value for a key in a map\nupdate :: forall k v. Ord k => (v -> Maybe v) -> k -> Map k v -> Map k v\nupdate f k = go\n  where\n  go = case _ of\n    Leaf -> Leaf\n    Node mh ms mk mv ml mr ->\n      case compare k mk of\n        LT -> runFn4 unsafeBalancedNode mk mv (go ml) mr\n        GT -> runFn4 unsafeBalancedNode mk mv ml (go mr)\n        EQ ->\n          case f mv of\n            Nothing ->\n              runFn2 unsafeJoinNodes ml mr\n            Just mv' ->\n              Node mh ms mk mv' ml mr\n\n-- | Convert any foldable collection of key/value pairs to a map.\n-- | On key collision, later values take precedence over earlier ones.\nfromFoldable :: forall f k v. Ord k => Foldable f => f (Tuple k v) -> Map k v\nfromFoldable = foldl (\\m (Tuple k v) -> insert k v m) empty\n\n-- | Convert any foldable collection of key/value pairs to a map.\n-- | On key collision, the values are configurably combined.\nfromFoldableWith :: forall f k v. Ord k => Foldable f => (v -> v -> v) -> f (Tuple k v) -> Map k v\nfromFoldableWith f = foldl (\\m (Tuple k v) -> f' k v m) empty\n  where\n  f' = insertWith (flip f)\n\n-- | Convert any indexed foldable collection into a map.\nfromFoldableWithIndex :: forall f k v. Ord k => FoldableWithIndex k f => f v -> Map k v\nfromFoldableWithIndex = foldlWithIndex (\\k m v -> insert k v m) empty\n\n-- | Convert a map to an unfoldable structure of key/value pairs where the keys are in ascending order\ntoUnfoldable :: forall f k v. Unfoldable f => Map k v -> f (Tuple k v)\ntoUnfoldable = unfoldr stepUnfoldr <<< toMapIter\n\n-- | Convert a map to an unfoldable structure of key/value pairs\n-- |\n-- | While this traversal is up to 10% faster in benchmarks than `toUnfoldable`,\n-- | it leaks the underlying map stucture, making it only suitable for applications\n-- | where order is irrelevant.\n-- |\n-- | If you are unsure, use `toUnfoldable`\ntoUnfoldableUnordered :: forall f k v. Unfoldable f => Map k v -> f (Tuple k v)\ntoUnfoldableUnordered = unfoldr stepUnfoldrUnordered <<< toMapIter\n\n-- | Get a list of the keys contained in a map\nkeys :: forall k v. Map k v -> List k\nkeys = foldrWithIndex (\\k _ acc -> k : acc) Nil\n\n-- | Get a list of the values contained in a map\nvalues :: forall k v. Map k v -> List v\nvalues = foldr Cons Nil\n\n-- | Compute the union of two maps, using the specified function\n-- | to combine values for duplicate keys.\nunionWith :: forall k v. Ord k => (v -> v -> v) -> Map k v -> Map k v -> Map k v\nunionWith app m1 m2 = runFn4 unsafeUnionWith compare app m1 m2\n\n-- | Compute the union of two maps, preferring values from the first map in the case\n-- | of duplicate keys\nunion :: forall k v. Ord k => Map k v -> Map k v -> Map k v\nunion = unionWith const\n\n-- | Compute the union of a collection of maps\nunions :: forall k v f. Ord k => Foldable f => f (Map k v) -> Map k v\nunions = foldl union empty\n\n-- | Compute the intersection of two maps, using the specified function\n-- | to combine values for duplicate keys.\nintersectionWith :: forall k a b c. Ord k => (a -> b -> c) -> Map k a -> Map k b -> Map k c\nintersectionWith app m1 m2 = runFn4 unsafeIntersectionWith compare app m1 m2\n\n-- | Compute the intersection of two maps, preferring values from the first map in the case\n-- | of duplicate keys.\nintersection :: forall k a b. Ord k => Map k a -> Map k b -> Map k a\nintersection = intersectionWith const\n\n-- | Difference of two maps. Return elements of the first map where\n-- | the keys do not exist in the second map.\ndifference :: forall k v w. Ord k => Map k v -> Map k w -> Map k v\ndifference m1 m2 = runFn3 unsafeDifference compare m1 m2\n\n-- | Test whether one map contains all of the keys and values contained in another map\nisSubmap :: forall k v. Ord k => Eq v => Map k v -> Map k v -> Boolean\nisSubmap = go\n  where\n  go m1 m2 = case m1 of\n    Leaf -> true\n    Node _ _ k v l r ->\n      case lookup k m2 of\n        Nothing -> false\n        Just v' ->\n          v == v' && go l m2 && go r m2\n\n-- | Calculate the number of key/value pairs in a map\nsize :: forall k v. Map k v -> Int\nsize = case _ of\n  Leaf -> 0\n  Node _ s _ _ _ _ -> s\n\n-- | Filter out those key/value pairs of a map for which a predicate\n-- | fails to hold.\nfilterWithKey :: forall k v. Ord k => (k -> v -> Boolean) -> Map k v -> Map k v\nfilterWithKey f = go\n  where\n  go = case _ of\n    Leaf -> Leaf\n    Node _ _ k v l r\n      | f k v ->\n          runFn4 unsafeBalancedNode k v (go l) (go r)\n      | otherwise ->\n          runFn2 unsafeJoinNodes (go l) (go r)\n\n-- | Filter out those key/value pairs of a map for which a predicate\n-- | on the key fails to hold.\nfilterKeys :: forall k. Ord k => (k -> Boolean) -> Map k ~> Map k\nfilterKeys f = go\n  where\n  go = case _ of\n    Leaf -> Leaf\n    Node _ _ k v l r\n      | f k ->\n          runFn4 unsafeBalancedNode k v (go l) (go r)\n      | otherwise ->\n          runFn2 unsafeJoinNodes (go l) (go r)\n\n-- | Filter out those key/value pairs of a map for which a predicate\n-- | on the value fails to hold.\nfilter :: forall k v. Ord k => (v -> Boolean) -> Map k v -> Map k v\nfilter = filterWithKey <<< const\n\n-- | Applies a function to each key/value pair in a map, discarding entries\n-- | where the function returns `Nothing`.\nmapMaybeWithKey :: forall k a b. Ord k => (k -> a -> Maybe b) -> Map k a -> Map k b\nmapMaybeWithKey f = go\n  where\n  go = case _ of\n    Leaf -> Leaf\n    Node _ _ k v l r ->\n      case f k v of\n        Just v' ->\n          runFn4 unsafeBalancedNode k v' (go l) (go r)\n        Nothing ->\n          runFn2 unsafeJoinNodes (go l) (go r)\n\n-- | Applies a function to each value in a map, discarding entries where the\n-- | function returns `Nothing`.\nmapMaybe :: forall k a b. Ord k => (a -> Maybe b) -> Map k a -> Map k b\nmapMaybe = mapMaybeWithKey <<< const\n\n-- | Filter a map of optional values, keeping only the key/value pairs which\n-- | contain a value, creating a new map.\ncatMaybes :: forall k v. Ord k => Map k (Maybe v) -> Map k v\ncatMaybes = mapMaybe identity\n\n-- | Returns true if at least one map element satisfies the given predicateon the value,\n-- | iterating the map only as necessary and stopping as soon as the predicate\n-- | yields true.\nany :: forall k v. (v -> Boolean) -> Map k v -> Boolean\nany predicate = go\n  where\n  go = case _ of\n    Leaf                -> false\n    Node _ _ _ mv ml mr -> predicate mv || go ml || go mr\n\n-- | Returns true if at least one map element satisfies the given predicate,\n-- | iterating the map only as necessary and stopping as soon as the predicate\n-- | yields true.\nanyWithKey :: forall k v. (k -> v -> Boolean) -> Map k v -> Boolean\nanyWithKey predicate = go\n  where\n  go = case _ of\n    Leaf                -> false\n    Node _ _ mk mv ml mr -> predicate mk mv || go ml || go mr\n\n-- | Low-level Node constructor which maintains the height and size invariants\n-- | This is unsafe because it assumes the child Maps are ordered and balanced.\nunsafeNode :: forall k v. Fn4 k v (Map k v) (Map k v) (Map k v)\nunsafeNode = mkFn4 \\k v l r -> case l of\n  Leaf ->\n    case r of\n      Leaf ->\n        Node 1 1 k v l r\n      Node h2 s2 _ _ _ _ ->\n        Node (1 + h2) (1 + s2) k v l r\n  Node h1 s1 _ _ _ _ ->\n    case r of\n      Leaf ->\n        Node (1 + h1) (1 + s1) k v l r\n      Node h2 s2 _ _ _ _ ->\n        Node (1 + if h1 > h2 then h1 else h2) (1 + s1 + s2) k v l r\n\n-- | Low-level Node constructor which maintains the balance invariants.\n-- | This is unsafe because it assumes the child Maps are ordered.\nunsafeBalancedNode :: forall k v. Fn4 k v (Map k v) (Map k v) (Map k v)\nunsafeBalancedNode = mkFn4 \\k v l r -> case l of\n  Leaf ->\n    case r of\n      Leaf ->\n        singleton k v\n      Node rh _ rk rv rl rr\n        | rh > 1 ->\n            runFn7 rotateLeft k v l rk rv rl rr\n      _ ->\n        runFn4 unsafeNode k v l r\n  Node lh _ lk lv ll lr ->\n    case r of\n      Node rh _ rk rv rl rr\n        | rh > lh + 1 ->\n            runFn7 rotateLeft k v l rk rv rl rr\n        | lh > rh + 1 ->\n            runFn7 rotateRight k v lk lv ll lr r\n      Leaf\n        | lh > 1 ->\n            runFn7 rotateRight k v lk lv ll lr r\n      _ ->\n        runFn4 unsafeNode k v l r\n  where\n  rotateLeft :: Fn7 k v (Map k v) k v (Map k v) (Map k v) (Map k v)\n  rotateLeft = mkFn7 \\k v l rk rv rl rr -> case rl of\n    Node lh _ lk lv ll lr\n      | lh > height rr ->\n          runFn4 unsafeNode lk lv (runFn4 unsafeNode k v l ll) (runFn4 unsafeNode rk rv lr rr)\n    _ ->\n      runFn4 unsafeNode rk rv (runFn4 unsafeNode k v l rl) rr\n\n  rotateRight :: Fn7 k v k v (Map k v) (Map k v) (Map k v) (Map k v)\n  rotateRight = mkFn7 \\k v lk lv ll lr r -> case lr of\n    Node rh _ rk rv rl rr\n      | height ll <= rh ->\n          runFn4 unsafeNode rk rv (runFn4 unsafeNode lk lv ll rl) (runFn4 unsafeNode k v rr r)\n    _ ->\n      runFn4 unsafeNode lk lv ll (runFn4 unsafeNode k v lr r)\n\n  height :: Map k v -> Int\n  height = case _ of\n    Leaf -> 0\n    Node h _ _ _ _ _ -> h\n\n-- | Low-level Node constructor from two Maps.\n-- | This is unsafe because it assumes the child Maps are ordered.\nunsafeJoinNodes :: forall k v. Fn2 (Map k v) (Map k v) (Map k v)\nunsafeJoinNodes = mkFn2 case _, _ of\n  Leaf, b -> b\n  Node _ _ lk lv ll lr, r -> do\n    let (SplitLast k v l) = runFn4 unsafeSplitLast lk lv ll lr\n    runFn4 unsafeBalancedNode k v l r\n\ndata SplitLast k v = SplitLast k v (Map k v)\n\n-- | Reassociates a node by moving the last node to the top.\n-- | This is unsafe because it assumes the key and child Maps are from\n-- | a balanced node.\nunsafeSplitLast :: forall k v. Fn4 k v (Map k v) (Map k v) (SplitLast k v)\nunsafeSplitLast = mkFn4 \\k v l r -> case r of\n  Leaf -> SplitLast k v l\n  Node _ _ rk rv rl rr -> do\n    let (SplitLast k' v' t') = runFn4 unsafeSplitLast rk rv rl rr\n    SplitLast k' v' (runFn4 unsafeBalancedNode k v l t')\n\ndata Split k v = Split (Maybe v) (Map k v) (Map k v)\n\n-- | Reassocates a Map so the given key is at the top.\n-- | This is unsafe because it assumes the ordering function is appropriate.\nunsafeSplit :: forall k v. Fn3 (k -> k -> Ordering) k (Map k v) (Split k v)\nunsafeSplit = mkFn3 \\comp k m -> case m of\n  Leaf ->\n    Split Nothing Leaf Leaf\n  Node _ _ mk mv ml mr ->\n    case comp k mk of\n      LT -> do\n        let (Split b ll lr) = runFn3 unsafeSplit comp k ml\n        Split b ll (runFn4 unsafeBalancedNode mk mv lr mr)\n      GT -> do\n        let (Split b rl rr) = runFn3 unsafeSplit comp k mr\n        Split b (runFn4 unsafeBalancedNode mk mv ml rl) rr\n      EQ ->\n        Split (Just mv) ml mr\n\n-- | Low-level unionWith implementation.\n-- | This is unsafe because it assumes the ordering function is appropriate.\nunsafeUnionWith :: forall k v. Fn4 (k -> k -> Ordering) (v -> v -> v) (Map k v) (Map k v) (Map k v)\nunsafeUnionWith = mkFn4 \\comp app l r -> case l, r of\n  Leaf, _ -> r\n  _, Leaf -> l\n  _, Node _ _ rk rv rl rr -> do\n    let (Split lv ll lr) = runFn3 unsafeSplit comp rk l\n    let l' = runFn4 unsafeUnionWith comp app ll rl\n    let r' = runFn4 unsafeUnionWith comp app lr rr\n    case lv of\n      Just lv' ->\n        runFn4 unsafeBalancedNode rk (app lv' rv) l' r'\n      Nothing ->\n        runFn4 unsafeBalancedNode rk rv l' r'\n\n-- | Low-level intersectionWith implementation.\n-- | This is unsafe because it assumes the ordering function is appropriate.\nunsafeIntersectionWith :: forall k a b c. Fn4 (k -> k -> Ordering) (a -> b -> c) (Map k a) (Map k b) (Map k c)\nunsafeIntersectionWith = mkFn4 \\comp app l r -> case l, r of\n  Leaf, _ -> Leaf\n  _, Leaf -> Leaf\n  _, Node _ _ rk rv rl rr -> do\n    let (Split lv ll lr) = runFn3 unsafeSplit comp rk l\n    let l' = runFn4 unsafeIntersectionWith comp app ll rl\n    let r' = runFn4 unsafeIntersectionWith comp app lr rr\n    case lv of\n      Just lv' ->\n        runFn4 unsafeBalancedNode rk (app lv' rv) l' r'\n      Nothing ->\n        runFn2 unsafeJoinNodes l' r'\n\n-- | Low-level difference implementation.\n-- | This is unsafe because it assumes the ordering function is appropriate.\nunsafeDifference :: forall k v w. Fn3 (k -> k -> Ordering) (Map k v) (Map k w) (Map k v)\nunsafeDifference = mkFn3 \\comp l r -> case l, r of\n  Leaf, _ -> Leaf\n  _, Leaf -> l\n  _, Node _ _ rk _ rl rr -> do\n    let (Split _ ll lr) = runFn3 unsafeSplit comp rk l\n    let l' = runFn3 unsafeDifference comp ll rl\n    let r' = runFn3 unsafeDifference comp lr rr\n    runFn2 unsafeJoinNodes l' r'\n\ndata MapIterStep k v\n  = IterDone\n  | IterNext k v (MapIter k v)\n\n-- | Low-level iteration state for a `Map`. Must be consumed using\n-- | an appropriate stepper.\ndata MapIter k v\n  = IterLeaf\n  | IterEmit k v (MapIter k v)\n  | IterNode (Map k v) (MapIter k v)\n\ninstance (Eq k, Eq v) => Eq (MapIter k v) where\n  eq = go\n    where\n    go a b = case stepAsc a of\n      IterNext k1 v1 a' ->\n        case stepAsc b of\n          IterNext k2 v2 b'\n            | k1 == k2 && v1 == v2 ->\n                go a' b'\n          _ ->\n            false\n      IterDone ->\n        true\n\ninstance (Ord k, Ord v) => Ord (MapIter k v) where\n  compare = go\n    where\n    go a b = case stepAsc a, stepAsc b of\n      IterNext k1 v1 a', IterNext k2 v2 b' ->\n        case compare k1 k2 of\n          EQ ->\n            case compare v1 v2 of\n              EQ ->\n                go a' b'\n              other ->\n                other\n          other ->\n            other\n      IterDone, b'->\n        case b' of\n          IterDone ->\n            EQ\n          _ ->\n            LT\n      _, IterDone ->\n        GT\n\n-- | Converts a Map to a MapIter for iteration using a MapStepper.\ntoMapIter :: forall k v. Map k v -> MapIter k v\ntoMapIter = flip IterNode IterLeaf\n\ntype MapStepper k v = MapIter k v -> MapIterStep k v\n\ntype MapStepperCps k v = forall r. (Fn3 k v (MapIter k v) r) -> (Unit -> r) -> MapIter k v -> r\n\n-- | Steps a `MapIter` in ascending order.\nstepAsc :: forall k v. MapStepper k v\nstepAsc = stepAscCps (mkFn3 \\k v next -> IterNext k v next) (const IterDone)\n\n-- | Steps a `MapIter` in descending order.\nstepDesc :: forall k v. MapStepper k v\nstepDesc = stepDescCps (mkFn3 \\k v next -> IterNext k v next) (const IterDone)\n\n-- | Steps a `MapIter` in arbitrary order.\nstepUnordered :: forall k v. MapStepper k v\nstepUnordered = stepUnorderedCps (mkFn3 \\k v next -> IterNext k v next) (const IterDone)\n\n-- | Steps a `MapIter` in ascending order with a CPS encoding.\nstepAscCps :: forall k v. MapStepperCps k v\nstepAscCps = stepWith iterMapL\n\n-- | Steps a `MapIter` in descending order with a CPS encoding.\nstepDescCps :: forall k v. MapStepperCps k v\nstepDescCps = stepWith iterMapR\n\n-- | Steps a `MapIter` in arbitrary order with a CPS encoding.\nstepUnorderedCps :: forall k v. MapStepperCps k v\nstepUnorderedCps = stepWith iterMapU\n\nstepUnfoldr :: forall k v. MapIter k v -> Maybe (Tuple (Tuple k v) (MapIter k v))\nstepUnfoldr = stepAscCps step (\\_ -> Nothing)\n  where\n  step = mkFn3 \\k v next ->\n    Just (Tuple (Tuple k v) next)\n\nstepUnfoldrUnordered :: forall k v. MapIter k v -> Maybe (Tuple (Tuple k v) (MapIter k v))\nstepUnfoldrUnordered = stepUnorderedCps step (\\_ -> Nothing)\n  where\n  step = mkFn3 \\k v next ->\n    Just (Tuple (Tuple k v) next)\n\nstepWith :: forall k v r. (MapIter k v -> Map k v -> MapIter k v) -> (Fn3 k v (MapIter k v) r) -> (Unit -> r) -> MapIter k v -> r\nstepWith f next done = go\n  where\n  go = case _ of\n    IterLeaf ->\n      done unit\n    IterEmit k v iter ->\n      runFn3 next k v iter\n    IterNode m iter ->\n      go (f iter m)\n\niterMapL :: forall k v. MapIter k v -> Map k v -> MapIter k v\niterMapL = go\n  where\n  go iter = case _ of\n    Leaf -> iter\n    Node _ _ k v l r ->\n      case r of\n        Leaf ->\n          go (IterEmit k v iter) l\n        _ ->\n          go (IterEmit k v (IterNode r iter)) l\n\niterMapR :: forall k v. MapIter k v -> Map k v -> MapIter k v\niterMapR = go\n  where\n  go iter = case _ of\n    Leaf -> iter\n    Node _ _ k v l r ->\n      case r of\n        Leaf ->\n          go (IterEmit k v iter) l\n        _ ->\n          go (IterEmit k v (IterNode l iter)) r\n\niterMapU :: forall k v. MapIter k v -> Map k v -> MapIter k v\niterMapU iter = case _ of\n  Leaf -> iter\n  Node _ _ k v l r ->\n    case l of\n      Leaf ->\n        case r of\n          Leaf ->\n            IterEmit k v iter\n          _ ->\n            IterEmit k v (IterNode r iter)\n      _ ->\n        case r of\n          Leaf ->\n            IterEmit k v (IterNode l iter)\n          _ ->\n            IterEmit k v (IterNode l (IterNode r iter))\n", "/* global exports */\n\"use strict\";\n\n// module Test.Spec.Console\n\nexport function write(s) {\n  return function () {\n    try {\n      process.stdout.write(s);\n    }\n    catch (e) {}\n  };\n}\n", "module Test.Spec.Console\n  ( tellLn\n  , tellLns\n  , write\n  , logWriter\n  ) where\n\nimport Prelude\n\nimport Control.Monad.Writer (class MonadWriter, WriterT, execWriterT, tell)\nimport Data.Foldable (for_)\nimport Effect (Effect)\nimport Effect.Class (class MonadEffect, liftEffect)\n\nforeign import write :: String -> Effect Unit\n\nlogWriter :: forall m. MonadEffect m => WriterT String m Unit -> m Unit\nlogWriter = execWriterT >=> write >>> liftEffect\n\ntellLn\n  :: forall m\n   . MonadWriter String m\n  => String\n  -> m Unit\ntellLn l = tell $ l <> \"\\n\"\n\ntellLns\n  :: forall m\n   . MonadWriter String m\n  => Array String\n  -> m Unit\ntellLns l = for_ l $ (_<> \"\\n\") >>> tell\n", "-- | This module defines the `Writer` monad.\n\nmodule Control.Monad.Writer\n  ( Writer\n  , writer\n  , runWriter\n  , execWriter\n  , mapWriter\n  , module Control.Monad.Writer.Class\n  , module Control.Monad.Writer.Trans\n  ) where\n\nimport Prelude\n\nimport Control.Monad.Writer.Class (class MonadTell, tell, class MonadWriter, censor, listen, listens, pass)\nimport Control.Monad.Writer.Trans (class MonadTrans, WriterT(..), execWriterT, lift, mapWriterT, runWriterT)\n\nimport Data.Identity (Identity(..))\nimport Data.Newtype (unwrap)\nimport Data.Tuple (Tuple, snd)\n\n-- | The `Writer` monad is a synonym for the `WriterT` monad transformer, applied\n-- | to the `Identity` monad.\ntype Writer w = WriterT w Identity\n\n-- | Creates a `Writer` from a result and output pair.\nwriter :: forall w a. Tuple a w -> Writer w a\nwriter = WriterT <<< pure\n\n-- | Run a computation in the `Writer` monad\nrunWriter :: forall w a. Writer w a -> Tuple a w\nrunWriter = unwrap <<< runWriterT\n\n-- | Run a computation in the `Writer` monad, discarding the result\nexecWriter :: forall w a. Writer w a -> w\nexecWriter m = snd (runWriter m)\n\n-- | Change the result and accumulator types in a `Writer` monad action\nmapWriter :: forall w1 w2 a b. (Tuple a w1 -> Tuple b w2) -> Writer w1 a -> Writer w2 b\nmapWriter f = mapWriterT (Identity <<< f <<< unwrap)\n", "module Pipes.Internal where\n\nimport Prelude\n\nimport Control.Alt (class Alt, (<|>))\nimport Control.Alternative (class Alternative)\nimport Control.Monad.Except.Trans (class MonadError, catchError, class MonadThrow, throwError)\nimport Control.Monad.Morph (class MFunctor, class MMonad)\nimport Control.Monad.Reader.Class (class MonadAsk, class MonadReader, local, ask)\nimport Control.Monad.Rec.Class (class MonadRec, Step(Done, Loop))\nimport Control.Monad.State.Class (class MonadState, state)\nimport Control.Monad.Trans.Class (class MonadTrans, lift)\nimport Control.Monad.Writer.Class (class MonadWriter, class MonadTell, listen, pass, tell)\nimport Control.MonadPlus (class MonadPlus)\nimport Control.Plus (class Plus, empty)\nimport Data.Tuple (Tuple(Tuple))\nimport Effect.Aff.Class (class MonadAff, liftAff)\nimport Effect.Class (class MonadEffect, liftEffect)\n\ndata Proxy a' a b' b m r\n  = Request a' (a  -> Proxy a' a b' b m r)\n  | Respond b  (b' -> Proxy a' a b' b m r)\n  | M          (m    (Proxy a' a b' b m r))\n  | Pure       r\n\ninstance functorProxy :: (Monad m) => Functor (Proxy a' a b' b m) where\n  map f p0 = go p0 where\n    go p = case p of\n      Request a' fa  -> Request a' \\x -> go (fa x)\n      Respond b  fb' -> Respond b  \\x -> go (fb' x)\n      M           m  -> M          (m >>= \\v -> pure (go v))\n      Pure        r  -> Pure       (f r)\n\ninstance applyProxy :: (Monad m) => Apply (Proxy a' a b' b m) where\n  apply pf0 px = go pf0 where\n    go pf = case pf of\n      Request a' fa  -> Request a' \\x -> go (fa x)\n      Respond b  fb' -> Respond b  \\x -> go (fb' x)\n      M           m  -> M          (m >>= \\v -> pure (go v))\n      Pure        f  -> f <$> px\n\ninstance applicativeProxy :: (Monad m) => Applicative (Proxy a' a b' b m) where\n  pure = Pure\n\ninstance bindProxy :: (Monad m) => Bind (Proxy a' a b' b m) where\n  bind p0 f = go p0 where\n    go p = case p of\n      Request a' fa  -> Request a' \\x -> go (fa x)\n      Respond b  fb' -> Respond b  \\x -> go (fb' x)\n      M           m  -> M          (m >>= \\v -> pure (go v))\n      Pure        r  -> f r\n\ninstance monadProxy :: (Monad m) => Monad (Proxy a' a b' b m)\n\ninstance monoidProxy :: (Monad m, Monoid r) => Monoid (Proxy a' a b' b m r) where\n  mempty = Pure mempty\n\ninstance semigroupProxy :: (Monad m, Semigroup r) => Semigroup (Proxy a' a b' b m r) where\n  append p1 p2 = go p1 where\n    go p = case p of\n      Request a' fa  -> Request a' \\x -> go (fa x)\n      Respond b  fb' -> Respond b  \\x -> go (fb' x)\n      M           m  -> M          (m >>= \\v -> pure (go v))\n      Pure       r1  -> (r1 <> _) <$> p2\n\ninstance monadTransProxy :: MonadTrans (Proxy a' a b' b) where\n  lift m = M (Pure <$> m)\n\ninstance proxyMFunctor :: MFunctor (Proxy a' a b' b) where\n    hoist nat p0 = go (observe p0)\n      where\n        go p = case p of\n            Request a' fa  -> Request a' \\x -> go (fa  x)\n            Respond b  fb' -> Respond b  \\x -> go (fb' x)\n            M          m   -> M (nat (m >>= \\p' -> pure (go p')))\n            Pure    r      -> Pure r\n\ninstance proxyMMonad :: MMonad (Proxy a' a b' b) where\n    embed f = go\n      where\n        go p = case p of\n            Request a' fa  -> Request a' \\x -> go (fa  x)\n            Respond b  fb' -> Respond b  \\x -> go (fb' x)\n            M          m   -> f m >>= go\n            Pure    r      -> Pure r\n\ninstance proxyMonadEffect :: MonadEffect m => MonadEffect (Proxy a' a b' b m) where\n    liftEffect m = M (liftEffect (m >>= \\r -> pure (Pure r)))\n\ninstance proxyMonadAff :: MonadAff m => MonadAff (Proxy a' a b' b m) where\n    liftAff m = M (liftAff (m >>= \\r -> pure (Pure r)))\n\ninstance proxyMonadAsk :: MonadAsk r m => MonadAsk r (Proxy a' a b' b m) where\n    ask = lift ask\n\ninstance proxyMonadReader :: MonadReader r m => MonadReader r (Proxy a' a b' b m) where\n    local f = go\n        where\n          go p = case p of\n              Request a' fa  -> Request a' (\\a  -> go (fa  a ))\n              Respond b  fb' -> Respond b  (\\b' -> go (fb' b'))\n              Pure    r      -> Pure r\n              M       m      -> M (local f m >>= \\r -> pure (go r))\n\ninstance proxyMonadState :: MonadState s m => MonadState s (Proxy a' a b' b m) where\n    state = lift <<< state\n\ninstance proxyMonadTell :: (Monoid w, MonadTell w m) => MonadTell w (Proxy a' a b' b m) where\n    tell = lift <<< tell\n\ninstance proxyMonadWriter :: (Monoid w, MonadWriter w m) => MonadWriter w (Proxy a' a b' b m) where\n    listen p0 = go p0 mempty\n        where\n        go p w = case p of\n            Request a' fa -> Request a' (\\a  -> go (fa  a ) w)\n            Respond b fb' -> Respond b  (\\b' -> go (fb' b') w)\n            Pure r        -> Pure (Tuple r w)\n            M m           -> M (do\n                                Tuple p' w' <- listen m\n                                pure (go p' (append w w')))\n\n    pass p0 = go p0 mempty\n        where\n        go p w = case p of\n            Request a' fa    -> Request a' (\\a  -> go (fa  a ) w)\n            Respond b fb'    -> Respond b  (\\b' -> go (fb' b') w)\n            Pure (Tuple r f) -> M (pass (pure (Tuple (Pure r) \\_ -> f w)))\n            M m              -> M (do\n                                    Tuple p' w' <- listen m\n                                    pure (go p' (append w w')))\n\ninstance proxyAlt :: (MonadPlus m) => Alt (Proxy a' a b' b m) where\n    alt (Request a' fa) p = Request a' (\\a  -> (fa a) <|> p)\n    alt (Respond b fb') p = Respond b  (\\b' -> (fb' b') <|> p)\n    alt (Pure r)        _ = Pure r\n    alt (M m)           p = M ((do\n                                  p' <- m\n                                  pure (p' <|> p)) <|> pure p)\n\ninstance proxyPlus :: (MonadPlus m) => Plus (Proxy a' a b' b m) where\n    empty = lift empty\n\ninstance proxyAlternative :: (MonadPlus m) => Alternative (Proxy a' a b' b m)\n\n-- XXX: these won't compile\n-- instance proxyMonadPlus :: (MonadPlus m) => MonadPlus (Proxy a' a b' b m)\n-- instance proxyMonadZero :: (MonadZero m) => MonadZero (Proxy a' a b' b m)\n\ninstance proxyMonadThrow :: (MonadThrow e m) => MonadThrow e (Proxy a' a b' b m) where\n    throwError = lift <<< throwError\n\ninstance proxyMonadError :: (MonadError e m) => MonadError e (Proxy a' a b' b m) where\n    catchError (Request a' fa) f = Request a' (\\a  -> catchError (fa  a ) f)\n    catchError (Respond b fb') f = Respond b  (\\b' -> catchError (fb' b') f)\n    catchError (Pure r)        _ = Pure r\n    catchError (M m)           f = M ((do\n                                          p' <- m\n                                          pure (catchError p' f)) `catchError` (pure <<< f))\n\ninstance monadRecProxy :: Monad m => MonadRec (Proxy a' a b' b m) where\n  tailRecM f a0 = go (f a0)\n    where\n    go = case _ of\n      Pure (Loop a)  -> go (f a)\n      Pure (Done b)  -> Pure b\n      M m            -> M $ m >>= \\v -> pure (go v)\n      Request a' fa  -> Request a' \\x -> go (fa x)\n      Respond b  fb' -> Respond b  \\x -> go (fb' x)\n\nobserve :: forall m a' a b' b r\n        .  Monad m => Proxy a' a b' b m r -> Proxy a' a b' b m r\nobserve p0 = M (go p0) where\n    go p = case p of\n        Request a' fa  -> pure (Request a' (observe <<< fa))\n        Respond b  fb' -> pure (Respond b  (observe <<< fb'))\n        M           m  -> m >>= go\n        Pure        r  -> pure (Pure r)\n\nnewtype X = X X\n\nclosed :: forall a. X -> a\nclosed (X x) = closed x\n", "module Pipes.Core (\n  -- * Proxy Monad Transformer\n    runEffect\n  , runEffectRec\n\n  -- * Categories\n\n  -- ** Respond\n  , respond\n  , composeResponse'\n  , (/>/)\n  , composeResponse\n  , (//>)\n\n  -- ** Request\n  , request\n  , composeRequest'\n  , (\\>\\)\n  , composeRequest\n  , (>\\\\)\n\n  -- ** Push\n  , push\n  , composePush\n  , (>~>)\n  , composePush'\n  , (>>~)\n\n  -- ** Pull\n  , pull\n  , composePull\n  , (>+>)\n  , composePull'\n  , (+>>)\n\n  -- ** Reflect\n  , reflect\n\n  -- * Concrete Type Synonyms\n  , Effect\n  , Producer\n  , Pipe\n  , Consumer\n  , Client\n  , Server\n  , Effect_\n  , Producer_\n  , Consumer_\n  , Client_\n  , Server_\n\n  -- * Flipped operators\n  , flippedComposeResponse'\n  , (\\<\\)\n  , flippedComposeRequest'\n  , (/</)\n  , flippedComposePush\n  , (<~<)\n  , flippedComposePush'\n  , (~<<)\n  , flippedComposePull\n  , (<+<)\n  , flippedComposePull'\n  , (<<+)\n  , flippedComposeResponse\n  , (<\\\\)\n  , flippedComposeRequest\n  , (//<)\n\n  -- * Re-exports\n  , module I\n  ) where\n\nimport Prelude (class Monad, Unit, pure, (<$>), (<<<), (>>=))\nimport Pipes.Internal (Proxy(..), X, closed)\nimport Pipes.Internal (Proxy (), X(), closed) as I\nimport Control.Monad.Rec.Class (class MonadRec, tailRecM, Step(Loop, Done))\n\ntype Effect      = Proxy X Unit Unit X\ntype Producer b  = Proxy X Unit Unit b\ntype Pipe a b    = Proxy Unit a Unit b\ntype Consumer a  = Proxy Unit a Unit X\ntype Client a' a = Proxy a' a Unit X\ntype Server b' b = Proxy X Unit b' b\n\ntype Effect_        m r = forall x' x y' y. Proxy x'   x y'   y m r\ntype Producer_ b    m r = forall x' x.      Proxy x'   x Unit b m r\ntype Consumer_ a    m r = forall y' y.      Proxy Unit a y'   y m r\ntype Server_   b' b m r = forall x' x.      Proxy x'   x b'   b m r\ntype Client_   a' a m r = forall y' y.      Proxy a'   a y'   y m r\n\nrunEffect :: forall m r. Monad m => Effect m r -> m r\nrunEffect = go\n  where\n    go p = case p of\n        Request v _ -> closed v\n        Respond v _ -> closed v\n        M       m   -> m >>= go\n        Pure    r   -> pure r\n\nrunEffectRec :: forall m r. (MonadRec m) => Effect m r -> m r\nrunEffectRec = tailRecM go\n  where\n  go (Request v _) = Done <$> closed v\n  go (Respond v _) = Done <$> closed v\n  go (Pure r)      = pure (Done r)\n  go (M mr)        = Loop <$> mr\n\nrespond :: forall m a a' x x'. Monad m => a -> Proxy x' x a' a m a'\nrespond a = Respond a Pure\n\ninfixl 4 composeResponse         as //>\ninfixr 4 composeResponse'        as />/\ninfixl 5 composeRequest          as >\\\\\ninfixr 4 composeRequest'         as \\>\\\ninfixr 6 composePull'            as +>>\ninfixl 7 composePull             as >+>\ninfixl 7 composePush'            as >>~\ninfixr 8 composePush             as >~>\ninfixl 4 flippedComposeResponse' as \\<\\\ninfixr 4 flippedComposeRequest'  as /</\ninfixl 8 flippedComposePush      as <~<\ninfixr 7 flippedComposePull      as <+<\ninfixr 3 flippedComposeResponse  as <\\\\\ninfixl 4 flippedComposeRequest   as //<\ninfixr 7 flippedComposePush'     as ~<<\ninfixl 6 flippedComposePull'     as <<+\n\ncomposeResponse\n    :: forall m x x' a' b b' c c'\n     . Monad m\n    =>       Proxy x' x b' b m a'\n    -> (b -> Proxy x' x c' c m b')\n    ->       Proxy x' x c' c m a'\ncomposeResponse p0 fb = go p0\n  where\n    go p = case p of\n        Request x' fx  -> Request x' (go <<< fx)\n        Respond b  fb' -> fb b >>= go <<< fb'\n        M          m   -> M (go <$> m)\n        Pure       a   -> Pure a\n\ncomposeResponse'\n    :: forall m x x' a a' b b' c c'\n     . Monad m\n    => (a -> Proxy x' x b' b m a')\n    -> (b -> Proxy x' x c' c m b')\n    -> (a -> Proxy x' x c' c m a')\ncomposeResponse' fa fb a = fa a //> fb\n\nrequest :: forall a a' y y' m. Monad m => a' -> Proxy a' a y' y m a\nrequest a' = Request a' Pure\n\n-- (>\\\\)\ncomposeRequest\n  :: forall a a' b b' c y y' m\n   . Monad m\n  => (b' -> Proxy a' a y' y m b)\n  ->        Proxy b' b y' y m c\n  ->        Proxy a' a y' y m c\ncomposeRequest fb' p0 = go p0\n  where\n    go p = case p of\n        Request b' fb  -> fb' b' >>= go <<< fb\n        Respond x  fx' -> Respond x (go <<< fx')\n        M          m   -> M (go <$> m)\n        Pure       a   -> Pure a\n\n-- (\\>\\)\ncomposeRequest'\n  :: forall a a' b b' c c' y y' m\n   . Monad m\n  => (b' -> Proxy a' a y' y m b)\n  -> (c' -> Proxy b' b y' y m c)\n  -> (c' -> Proxy a' a y' y m c)\ncomposeRequest' fb' fc' c' = fb' `composeRequest` fc' c'\n\npull :: forall a a' m r. Monad m => a' -> Proxy a' a a' a m r\npull = go\n  where\n    go a' = Request a' (\\a -> Respond a go)\n\ncomposePull\n    :: forall a a' b b' c c' _c' m r\n     . Monad m\n    => ( b' -> Proxy a' a b' b m r)\n    -> (_c' -> Proxy b' b c' c m r)\n    -> (_c' -> Proxy a' a c' c m r)\ncomposePull fb' fc' c' = fb' +>> fc' c'\n\ncomposePull'\n    :: forall a a' b b' c c' m r\n     . Monad m\n    => (b' -> Proxy a' a b' b m r)\n    ->        Proxy b' b c' c m r\n    ->        Proxy a' a c' c m r\ncomposePull' fb' p = case p of\n    Request b' fb  -> fb' b' >>~ fb\n    Respond c  fc' -> Respond c ((fb' +>> _) <<< fc')\n    M          m   -> M ((fb' +>> _) <$> m)\n    Pure       r   -> Pure r\n\npush :: forall a a' m r. Monad m => a -> Proxy a' a a' a m r\npush = go\n  where\n    go a = Respond a (\\a' -> Request a' go)\n\ncomposePush\n    :: forall _a a a' b b' c c' m r\n     . Monad m\n    => (_a -> Proxy a' a b' b m r)\n    -> ( b -> Proxy b' b c' c m r)\n    -> (_a -> Proxy a' a c' c m r)\ncomposePush fa fb a = fa a >>~ fb\n\ncomposePush'\n    :: forall a a' b b' c c' m r\n     . Monad m\n    =>       Proxy a' a b' b m r\n    -> (b -> Proxy b' b c' c m r)\n    ->       Proxy a' a c' c m r\ncomposePush' p fb = case p of\n    Request a' fa  -> Request a' (\\a -> fa a >>~ fb)\n    Respond b  fb' -> fb' +>> fb b\n    M          m   -> M (m >>= \\p' -> pure (p' >>~ fb))\n    Pure       r   -> Pure r\n\nreflect\n  :: forall a a' b b' m r\n   . Monad m\n  => Proxy a' a b' b m r -> Proxy b b' a a' m r\nreflect = go\n  where\n    go p = case p of\n        Request a' fa  -> Respond a' (go <<< fa)\n        Respond b  fb' -> Request b  (go <<< fb')\n        M          m   -> M (go <$> m)\n        Pure    r      -> Pure r\n\n-- | Equivalent to ('/>/') with the arguments flipped\nflippedComposeResponse'\n    :: forall m x x' a a' b b' c c'\n     . Monad m\n    => (b -> Proxy x' x c' c m b')\n    -> (a -> Proxy x' x b' b m a')\n    -> (a -> Proxy x' x c' c m a')\nflippedComposeResponse' p1 p2 = p2 />/ p1\n\n-- | Equivalent to ('\\>\\') with the arguments flipped\nflippedComposeRequest'\n  :: forall a a' b b' c c' y y' m\n   . Monad m\n    => (c' -> Proxy b' b y' y m c)\n    -> (b' -> Proxy a' a y' y m b)\n    -> (c' -> Proxy a' a y' y m c)\nflippedComposeRequest' p1 p2 = p2 \\>\\ p1\n\n-- | Equivalent to ('>~>') with the arguments flipped\nflippedComposePush\n    :: forall a a' b b' c c' m r\n     . Monad m\n    => (b -> Proxy b' b c' c m r)\n    -> (a -> Proxy a' a b' b m r)\n    -> (a -> Proxy a' a c' c m r)\nflippedComposePush p1 p2 = p2 >~> p1\n\n-- | Equivalent to ('>+>') with the arguments flipped\nflippedComposePull\n    :: forall a a' b b' c c' m r\n     . Monad m\n    => (c' -> Proxy b' b c' c m r)\n    -> (b' -> Proxy a' a b' b m r)\n    -> (c' -> Proxy a' a c' c m r)\nflippedComposePull p1 p2 = p2 >+> p1\n\n-- | Equivalent to ('//>') with the arguments flipped\nflippedComposeResponse\n    :: forall m x x' a' b b' c c'\n     . Monad m\n    => (b -> Proxy x' x c' c m b')\n    ->       Proxy x' x b' b m a'\n    ->       Proxy x' x c' c m a'\nflippedComposeResponse f p = p //> f\n\n-- | Equivalent to ('>\\\\') with the arguments flipped\nflippedComposeRequest\n  :: forall a a' b b' c y y' m\n   . Monad m\n    =>        Proxy b' b y' y m c\n    -> (b' -> Proxy a' a y' y m b)\n    ->        Proxy a' a y' y m c\nflippedComposeRequest p f = f >\\\\ p\n\n-- | Equivalent to ('>>~') with the arguments flipped\nflippedComposePush'\n    :: forall a a' b b' c c' m r\n     . Monad m\n    => (b  -> Proxy b' b c' c m r)\n    ->        Proxy a' a b' b m r\n    ->        Proxy a' a c' c m r\nflippedComposePush' k p = p >>~ k\n\n-- | Equivalent to ('+>>') with the arguments flipped\nflippedComposePull'\n    :: forall a a' b b' c c' m r\n     . Monad m\n    =>         Proxy b' b c' c m r\n    -> (b'  -> Proxy a' a b' b m r)\n    ->         Proxy a' a c' c m r\nflippedComposePull' k p = p +>> k\n", "module Pipes where\n\nimport Prelude (class Monad, Unit, const, flip, pure, unit, (*>), (>>=))\nimport Pipes.Core (Consumer_, Pipe, Producer, Producer_, closed, pull, request, respond, (+>>), (//>), (/>/), (>\\\\))\nimport Pipes.Internal (Proxy(..))\nimport Data.Foldable (class Foldable)\nimport Data.Tuple (Tuple(..))\nimport Data.Either (Either(..))\nimport Data.Foldable as F\n\ninfixl 4 composeLoopBodies' as <~\ninfixr 4 composeLoopBodies  as ~>\ninfixr 5 replaceAwait       as >~\ninfixl 5 replaceAwait'      as ~<\ninfixl 7 composePipes       as >->\ninfixr 7 composePipes'      as <-<\n\nfor\n  :: forall a b b' c c' x x' m\n   . Monad m\n  =>       Proxy x' x b' b m a\n  -> (b -> Proxy x' x c' c m b')\n  ->       Proxy x' x c' c m a\nfor = (//>)\n\n-- (~>)\ncomposeLoopBodies\n  :: forall a a' b b' c c' x x' m\n   . Monad m\n  => (a -> Proxy x' x b' b m a')\n  -> (b -> Proxy x' x c' c m b')\n  -> (a -> Proxy x' x c' c m a')\ncomposeLoopBodies = (/>/)\n\n-- (<~)\ncomposeLoopBodies'\n  :: forall a a' b b' c c' x x' m\n   . Monad m\n  => (b -> Proxy x' x c' c m b')\n  -> (a -> Proxy x' x b' b m a')\n  -> (a -> Proxy x' x c' c m a')\ncomposeLoopBodies' = flip composeLoopBodies\n\nawait :: forall a m. Monad m => Consumer_ a m a\nawait = request unit\n\n-- (~<)\nreplaceAwait\n  :: forall a a' b y y' c m\n   . Monad m\n  => Proxy a'   a y' y m b\n  -> Proxy Unit b y' y m c\n  -> Proxy a'   a y' y m c\nreplaceAwait p1 p2 = const p1 >\\\\ p2\n\n-- (>~)\nreplaceAwait'\n  :: forall a a' b y y' c m\n   . Monad m\n  => Proxy Unit b y' y m c\n  -> Proxy a'   a y' y m b\n  -> Proxy a'   a y' y m c\nreplaceAwait' = flip replaceAwait\n\ncat :: forall a m r. Monad m => Pipe a a m r\ncat = pull unit\n\n-- (>->)\ncomposePipes\n  :: forall a a' b c c' m r\n   . Monad m\n  => Proxy a'   a Unit b m r\n  -> Proxy Unit b c'   c m r\n  -> Proxy a'   a c'   c m r\ncomposePipes p1 p2 = const p1 +>> p2\n\n-- (<-<)\ncomposePipes'\n  :: forall a a' b c c' m r\n   . Monad m\n  => Proxy Unit b c'   c m r\n  -> Proxy a'   a Unit b m r\n  -> Proxy a'   a c'   c m r\ncomposePipes' = flip composePipes\n\nyield :: forall m a. Monad m => a -> Producer_ a m Unit\nyield = respond\n\n{-| Consume the first value from a `Producer`\n    `next` either fails with a `Left` if the `Producer` terminates or succeeds\n    with a `Right` providing the next value and the remainder of the `Producer`.\n-}\nnext :: forall a m r. Monad m => Producer a m r -> m (Either r (Tuple a (Producer a m r)))\nnext = go\n  where\n    go p = case p of\n        Request v _  -> closed v\n        Respond a fu -> pure (Right (Tuple a (fu unit)))\n        M         m  -> m >>= go\n        Pure    r    -> pure (Left r)\n\n-- | Convert a `F.Foldable` to a `Producer`\neach :: forall a f m. Monad m => Foldable f => f a -> Producer_ a m Unit\neach xs = F.foldr (\\a p -> yield a *> p) (pure unit) xs\n\n-- | Discards a value\ndiscard :: forall a m. Monad m => a -> m Unit\ndiscard _ = pure unit\n", "-- | This module defines a data type representing ANSI escape codes, as well as\n-- | functions for serialising them as Strings.\nmodule Ansi.Codes where\n\nimport Prelude\n\nimport Data.Foldable (intercalate)\nimport Data.Generic.Rep (class Generic)\nimport Data.List.NonEmpty (NonEmptyList)\nimport Data.Show.Generic (genericShow)\n\n-- | The prefix for all escape codes.\nprefix :: String\nprefix = \"\\x1b[\"\n\n-- | The suffix for escape codes; note that this is only required for colors.\ncolorSuffix :: String\ncolorSuffix = \"m\"\n\n-- | An ANSI escape code. Not all sequences are implemented.\n-- | See: <https://en.wikipedia.org/wiki/ANSI_escape_code>.\ndata EscapeCode\n  = Up Int\n  | Down Int\n  | Forward Int\n  | Back Int\n  | NextLine Int\n  | PreviousLine Int\n  | HorizontalAbsolute Int\n  | Position Int Int\n  | EraseData EraseParam\n  | EraseLine EraseParam\n  | ScrollUp Int\n  | ScrollDown Int\n  | Graphics (NonEmptyList GraphicsParam)\n  | SavePosition\n  | RestorePosition\n  | QueryPosition\n  | HideCursor\n  | ShowCursor\n\nderive instance genericEscapeCode :: Generic EscapeCode _\nderive instance eqEscapeCode :: Eq EscapeCode\nderive instance ordEscapeCode :: Ord EscapeCode\ninstance showEscapeCode :: Show EscapeCode where\n  show = genericShow\n\n-- | Convert an escape code to the form recognised by terminals.\nescapeCodeToString :: EscapeCode -> String\nescapeCodeToString = (prefix <> _) <<< go\n  where\n  go c =\n    case c of\n      Up n                 -> show n <> \"A\"\n      Down n               -> show n <> \"B\"\n      Forward n            -> show n <> \"C\"\n      Back n               -> show n <> \"D\"\n      NextLine n           -> show n <> \"E\"\n      PreviousLine n       -> show n <> \"F\"\n      HorizontalAbsolute n -> show n <> \"G\"\n      Position x y         -> show x <> \";\" <> show y <> \"H\"\n      EraseData p          -> ep p <> \"J\"\n      EraseLine p          -> ep p <> \"K\"\n      ScrollUp n           -> show n <> \"S\"\n      ScrollDown n         -> show n <> \"T\"\n      Graphics ps          -> intercalate \";\" (map gp ps) <> colorSuffix\n      SavePosition         -> \"s\"\n      RestorePosition      -> \"u\"\n      QueryPosition        -> \"6n\"\n      HideCursor           -> \"?25l\"\n      ShowCursor           -> \"?25h\"\n\n  ep = eraseParamToString\n  gp = graphicsParamToString\n\n-- | Specifies how much text to erase.\n-- |\n-- | * ToEnd: erase from the cursor to the end of the line or screen.\n-- | * FromBeginning: erase to the cursor from the beginning of the line or\n-- |    screen.\n-- | * Entire: erase the entire line or screen.\ndata EraseParam\n  = ToEnd\n  | FromBeginning\n  | Entire\n\nderive instance genericEraseParam :: Generic EraseParam _\nderive instance eqEraseParam :: Eq EraseParam\nderive instance ordEraseParam :: Ord EraseParam\ninstance showEraseParam :: Show EraseParam where\n  show = genericShow\n\neraseParamToString :: EraseParam -> String\neraseParamToString ep =\n  case ep of\n    ToEnd         -> \"0\"\n    FromBeginning -> \"1\"\n    Entire        -> \"2\"\n\n-- | A graphics parameter, controls how text appears; for example, bold,\n-- | underlined, foreground color, background color.\ndata GraphicsParam\n  = Reset\n  | PMode RenderingMode\n  | PForeground Color\n  | PBackground Color\n\nderive instance genericGraphicsParam :: Generic GraphicsParam _\nderive instance eqGraphicsParam :: Eq GraphicsParam\nderive instance ordGraphicsParam :: Ord GraphicsParam\ninstance showGraphicsParam :: Show GraphicsParam where\n  show = genericShow\n\ngraphicsParamToString :: GraphicsParam -> String\ngraphicsParamToString gp =\n  case gp of\n    Reset         -> \"0\"\n    PMode m       -> show (codeForRenderingMode m)\n    PForeground c -> show (colorCode c)\n    PBackground c -> show (colorCode c + 10)\n\ndata RenderingMode\n  = Bold\n  | Dim\n  | Italic\n  | Underline\n  | Inverse\n  | Strikethrough\n\nderive instance genericRenderingMode :: Generic RenderingMode _\nderive instance eqRenderingMode :: Eq RenderingMode\nderive instance ordRenderingMode :: Ord RenderingMode\ninstance showRenderingMode :: Show RenderingMode where\n  show = genericShow\n\ncodeForRenderingMode :: RenderingMode -> Int\ncodeForRenderingMode m =\n  case m of\n    Bold -> 1\n    Dim -> 2\n    Italic -> 3\n    Underline -> 4\n    Inverse -> 7\n    Strikethrough -> 9\n\n-- | The standard set of 16 ANSI colors.\ndata Color\n  = Black\n  | Red\n  | Green\n  | Yellow\n  | Blue\n  | Magenta\n  | Cyan\n  | White\n  | BrightBlack\n  | BrightRed\n  | BrightGreen\n  | BrightYellow\n  | BrightBlue\n  | BrightMagenta\n  | BrightCyan\n  | BrightWhite\n\nderive instance genericColor :: Generic Color _\nderive instance eqColor :: Eq Color\nderive instance ordColor :: Ord Color\ninstance showColor :: Show Color where\n  show = genericShow\n\ncolorCode :: Color -> Int\ncolorCode c =\n  case c of\n    Black -> 30\n    Red -> 31\n    Green -> 32\n    Yellow -> 33\n    Blue -> 34\n    Magenta -> 35\n    Cyan -> 36\n    White -> 37\n    BrightBlack -> 90\n    BrightRed -> 91\n    BrightGreen -> 92\n    BrightYellow -> 93\n    BrightBlue -> 94\n    BrightMagenta -> 95\n    BrightCyan -> 96\n    BrightWhite -> 97\n", "module Test.Spec.Style where\n\nimport Prelude\n\nimport Ansi.Codes (GraphicsParam, escapeCodeToString)\nimport Ansi.Codes as AnsiCode\nimport Data.Array as Array\nimport Data.List.NonEmpty as NEL\nimport Data.Maybe (Maybe(..))\nimport Data.String.CodeUnits as CodeUnits\n\ntype Style = Array GraphicsParam\n\nstyled :: Style -> String -> String\nstyled as str = do\n  case NEL.fromFoldable as of\n    Nothing -> do\n      str\n    Just as' -> do\n      escapeCodeToString (AnsiCode.Graphics as')\n       <> str\n       <> escapeCodeToString (AnsiCode.Graphics $ NEL.singleton AnsiCode.Reset)\n\nred :: Style\nred = [AnsiCode.PForeground AnsiCode.Red]\n\ngreen :: Style\ngreen = [AnsiCode.PForeground AnsiCode.Green]\n\nyellow :: Style\nyellow = [AnsiCode.PForeground AnsiCode.Yellow]\n\ncyan :: Style\ncyan = [AnsiCode.PForeground AnsiCode.Cyan]\n\ndim :: Style\ndim = [AnsiCode.PMode AnsiCode.Dim]\n\nbold :: Style\nbold = [AnsiCode.PMode AnsiCode.Bold]\n\nmagenta :: Style\nmagenta = [AnsiCode.PForeground AnsiCode.Magenta]\n\nindent :: Int -> String\nindent i = CodeUnits.fromCharArray $ Array.replicate i ' '\n", "module Test.Spec.Speed where\n\nimport Prelude\n\nimport Data.Eq.Generic (genericEq)\nimport Data.Generic.Rep (class Generic)\nimport Data.Show.Generic (genericShow)\nimport Data.Time.Duration (Milliseconds(..))\nimport Test.Spec.Style (Style)\nimport Test.Spec.Style as Style\n\ndata Speed = Fast | Medium | Slow\n\nderive instance genericSpeed :: Generic Speed _\ninstance showSpeed :: Show Speed where show = genericShow\ninstance showEq :: Eq Speed where eq = genericEq\n\nspeedOf :: Milliseconds -> Milliseconds -> Speed\nspeedOf thresh ms | ms > thresh = Slow\nspeedOf (Milliseconds thresh) (Milliseconds ms) | ms > thresh / 2.0 = Medium\nspeedOf _ _ = Fast\n\ntoStyle :: Speed -> Style\ntoStyle Fast   = Style.dim\ntoStyle Medium = Style.yellow\ntoStyle Slow   = Style.red\n", "module Test.Spec.Result where\n\nimport Prelude\n\nimport Data.Function (on)\nimport Data.Time.Duration (Milliseconds)\nimport Effect.Exception (Error)\nimport Effect.Exception as Error\nimport Test.Spec.Speed (Speed)\n\ndata Result\n  = Success Speed Milliseconds\n  | Failure Error\n\ninstance showResult :: Show Result where\n  show (Success speed duration ) = \"Success (\" <> show speed <> \" \" <> show duration <> \")\"\n  show (Failure err) = \"Failure (Error \" <> Error.message err <> \")\"\n\ninstance eqResult :: Eq Result where\n  eq (Success s1 d1) (Success s2 d2) = s1 == s2 && d1 == d2\n  eq (Failure err1) (Failure err2) = on (==) Error.message err1 err2 && on (==) Error.stack err1 err2\n  eq _ _ = false\n", "module Test.Spec.Runner.Event where\n\nimport Prelude\n\nimport Test.Spec (Tree)\nimport Test.Spec.Result (Result)\nimport Test.Spec.Tree (Path)\n\ntype Name = String\ntype NumberOfTests = Int\n\ndata Execution = Parallel | Sequential\ninstance showExecution :: Show Execution where\n  show = case _ of\n    Parallel -> \"Parallel\"\n    Sequential -> \"Sequential\"\n\ndata Event\n  = Start NumberOfTests\n  | Suite Execution Path Name\n  | SuiteEnd Path\n  | Test Execution Path Name\n  | TestEnd Path Name Result\n  | Pending Path Name\n  | End (Array (Tree String Void Result))\n\ninstance showEvent :: Show Event where\n  show = case _ of\n    Start n -> \"Start \" <> show n\n    Suite e path name -> \"Suite \" <> show e <> show path <> \": \" <> name\n    SuiteEnd path -> \"SuiteEnd \" <> show path\n    Test e path name -> \"Test \" <> show e <> show path <> \" \" <> name\n    TestEnd path name res -> \"TestEnd \" <> show path <> \" \" <> name <> \": \" <> show res\n    Pending path name -> \"Pending \" <> show path <> \" \" <> name\n    End results -> \"End \" <> show results\n", "module Test.Spec.Summary (\n  Summary(..),\n  summarize,\n  successful\n  ) where\n\nimport Prelude\n\nimport Data.Foldable (foldMap)\nimport Data.Maybe (Maybe(..))\nimport Data.Newtype (class Newtype, un)\nimport Test.Spec.Result (Result(..))\nimport Test.Spec.Tree (Tree(..))\n\nnewtype Summary = Count { passed :: Int, failed :: Int, pending :: Int }\nderive instance newtypeSummary :: Newtype Summary _\n\ninstance semigroupCount :: Semigroup Summary where\n  append (Count c1) (Count c2) = Count $ c1 + c2\n\ninstance monoidCount :: Monoid Summary where\n  mempty = Count zero\n\nsummarize :: \u2200 n a. Array (Tree n a Result) -> Summary\nsummarize = foldMap case _ of\n  (Leaf _ (Just (Success _ _))) -> Count { passed: 1, failed: 0, pending: 0 }\n  (Leaf _ (Just (Failure _))) -> Count { passed: 0, failed: 1, pending: 0 }\n  (Leaf _ Nothing) -> Count { passed: 0, failed: 0, pending: 1 }\n  (Node _ dgs) -> summarize dgs\n\nsuccessful :: \u2200 n a. Array (Tree n a Result) -> Boolean\nsuccessful groups = (un Count $ summarize groups).failed == 0\n", "module Test.Spec.Reporter.Base\n  ( defaultSummary\n  , defaultReporter\n  , defaultUpdate\n  , RunningItem(..)\n  ) where\n\nimport Prelude\n\nimport Control.Monad.State (StateT, evalStateT, execStateT, get, gets, put)\nimport Control.Monad.State as State\nimport Control.Monad.Trans.Class (lift)\nimport Control.Monad.Writer (class MonadWriter, Writer, runWriter)\nimport Data.Either (Either(..))\nimport Data.Foldable (all, for_, intercalate, traverse_)\nimport Data.Generic.Rep (class Generic)\nimport Data.Map (Map)\nimport Data.Map as Map\nimport Data.Maybe (Maybe(..), isJust)\nimport Data.Show.Generic (genericShow)\nimport Data.Tuple (Tuple(..), uncurry)\nimport Data.Tuple.Nested (type (/\\), (/\\))\nimport Effect.Class (liftEffect)\nimport Effect.Exception as Error\nimport Pipes (await, yield)\nimport Pipes.Core (Pipe)\nimport Test.Spec (Tree)\nimport Test.Spec as S\nimport Test.Spec.Console (tellLn)\nimport Test.Spec.Console as Console\nimport Test.Spec.Result (Result(..))\nimport Test.Spec.Runner (Reporter)\nimport Test.Spec.Runner.Event (Event)\nimport Test.Spec.Runner.Event as Event\nimport Test.Spec.Style (styled)\nimport Test.Spec.Style as Style\nimport Test.Spec.Summary (Summary(..))\nimport Test.Spec.Summary as Summary\nimport Test.Spec.Tree (Path, annotateWithPaths, parentSuiteName)\n\n\ndefaultSummary :: forall m\n   . MonadWriter String m\n  => Array (Tree String Void Result)\n  -> m Unit\ndefaultSummary xs = do\n  case Summary.summarize xs of\n    (Count {passed, failed, pending}) -> do\n      when (passed  > 0) $ tellLn $ styled Style.green $ show passed  <> \" passing\"\n      when (pending > 0) $ tellLn $ styled Style.cyan $ show pending <> \" pending\"\n      when (failed  > 0) $ tellLn $ styled Style.red $ show failed  <> \" failed\"\n  tellLn \"\"\n  printFailures xs\n\nprintFailures\n  :: forall m\n   . MonadWriter String m\n  => Array (Tree String Void Result)\n  -> m Unit\nprintFailures xs' = evalStateT (go $ annotateWithPaths xs') 0\n  where\n    go :: Array (Tree (String /\\ Path) Void Result) -> StateT Int m Unit\n    go = traverse_ case _ of\n      S.Node (Left _) xs -> go xs\n      S.Node (Right v) _ -> absurd v\n      S.Leaf (n /\\ path) (Just (Failure err)) -> do\n        i <- State.modify $ add 1\n        let label = intercalate \" \" (parentSuiteName path <> [n])\n        tellLn $ show i <> \") \" <> label\n        tellLn $ styled Style.red $ Style.indent 2 <> Error.message err\n      S.Leaf _ _ -> pure unit\n\n-- | Monadic left scan with state.\n-- | TODO: Is this already included in purescript-pipes somehow, or should be?\nscanWithStateM\n  :: forall a x m r\n   . Monad m\n  => (x -> a -> m x) -> m x -> Pipe a a m r\nscanWithStateM step begin = do\n  x <- lift begin\n  go x\n  where\n    go x = do\n        a <- await\n        yield a\n        x' <- lift (step x a)\n        go $ x'\n\n-- | A default reporter implementation that can be used as a base to build\n-- | other reporters on top of.\ndefaultReporter\n  :: forall s\n   . s\n  -> (Event -> StateT s (Writer String) Unit)\n  -> Reporter\ndefaultReporter initialState onEvent = pure initialState # scanWithStateM \\s e ->\n  let Tuple res log = runWriter $ execStateT (onEvent e) s\n  in liftEffect $ Console.write log $> res\n\n\ndata RunningItem\n  = RunningTest String (Maybe Result)\n  | RunningPending String\n  | RunningSuite String Boolean\n\nderive instance runningItemGeneric :: Generic RunningItem _\ninstance runningItemShow :: Show RunningItem where show = genericShow\n\ndefaultUpdate\n  :: forall s\n  . { getRunningItems :: s -> Map Path RunningItem\n    , putRunningItems :: Map Path RunningItem -> s -> s\n    , printFinishedItem :: Path -> RunningItem -> StateT s (Writer String) Unit\n    , update :: Event -> StateT s (Writer String) Unit\n    }\n  -> (Event -> StateT s (Writer String) Unit)\ndefaultUpdate opts e = do\n  baseUpdate e\n  opts.update e\n  where\n    baseUpdate = case _ of\n      Event.Suite Event.Sequential _ _ ->\n        pure unit\n      Event.Suite Event.Parallel path name -> do\n        modifyRunningItems $ Map.insert path $ RunningSuite name false\n      Event.SuiteEnd path -> do\n        modifyRunningItems $ flip Map.update path case _ of\n          RunningSuite n _ -> Just $ RunningSuite n true\n          _ -> Nothing\n      Event.Test Event.Sequential _ _ -> do\n        pure unit\n      Event.Test Event.Parallel path name -> do\n        modifyRunningItems $ Map.insert path $ RunningTest name Nothing\n      Event.TestEnd path _ res -> do\n        runningItem <- gets opts.getRunningItems\n        case Map.lookup path runningItem of\n          Just (RunningTest n _) ->\n            modifyRunningItems $ Map.insert path $ RunningTest n $ Just res\n          _ ->\n            pure unit\n      Event.Pending path name -> do\n        runningItem <- gets opts.getRunningItems\n        unless (Map.isEmpty runningItem) do\n          modifyRunningItems $ Map.insert path $ RunningPending name\n      Event.End _ -> pure unit\n      Event.Start _ -> pure unit\n    modifyRunningItems f = do\n      s <- get\n      let\n        nextRunningItems = f $ opts.getRunningItems s\n        allFinished = all runningItemIsFinished nextRunningItems\n      put $ opts.putRunningItems (if allFinished then Map.empty else nextRunningItems) s\n\n      when allFinished do\n        for_ (asArray $ Map.toUnfoldable nextRunningItems) $ uncurry opts.printFinishedItem\n      where\n        asArray = identity :: Array ~> Array\n        runningItemIsFinished = case _ of\n          RunningPending _ -> true\n          RunningTest _ res -> isJust res\n          RunningSuite _ finished -> finished\n", "module Test.Spec.Reporter.Console (consoleReporter) where\n\nimport Prelude\n\nimport Control.Monad.State (class MonadState, get, put)\nimport Control.Monad.Writer (class MonadWriter)\nimport Data.Foldable (intercalate)\nimport Data.Generic.Rep (class Generic)\nimport Data.Map (Map)\nimport Data.Map as Map\nimport Data.Maybe (Maybe(..), isNothing)\nimport Data.Show.Generic (genericShow)\nimport Effect.Exception as Error\nimport Test.Spec.Console (tellLn)\nimport Test.Spec.Reporter.Base (RunningItem(..), defaultReporter, defaultUpdate)\nimport Test.Spec.Result (Result(..))\nimport Test.Spec.Runner (Reporter)\nimport Test.Spec.Runner.Event as Event\nimport Test.Spec.Style (styled)\nimport Test.Spec.Style as Style\nimport Test.Spec.Summary (Summary(..))\nimport Test.Spec.Summary as Summary\nimport Test.Spec.Tree (Path, Tree, parentSuiteName)\n\ntype State = { runningItems :: Map Path RunningItem, lastPrintedSuitePath :: Maybe Path}\n\ninitialState :: State\ninitialState = { runningItems: Map.empty, lastPrintedSuitePath: Nothing }\n\nconsoleReporter :: Reporter\nconsoleReporter = defaultReporter initialState $ defaultUpdate\n  { getRunningItems: _.runningItems\n  , putRunningItems: flip _{runningItems = _}\n  , printFinishedItem: \\path -> case _ of\n      RunningTest name (Just res) -> print path $ PrintTest name res\n      RunningPending name -> print path $ PrintPending name\n      _ -> pure unit\n  , update: case _ of\n      Event.TestEnd path name res -> do\n        {runningItems} <- get\n        when (isNothing $ Map.lookup path runningItems) do\n          print path $ PrintTest name res\n      Event.Pending path name -> do\n        {runningItems} <- get\n        when (Map.isEmpty runningItems) do\n          print path $ PrintPending name\n      Event.End results -> printSummary results\n      _ -> pure unit\n  }\n\nprintSummary :: \u2200 n m. MonadWriter String m => Array (Tree n Void Result) -> m Unit\nprintSummary = Summary.summarize >>> \\(Count {passed, failed, pending}) -> do\n  tellLn \"\"\n  tellLn $ styled Style.bold \"Summary\"\n  printPassedFailed passed failed\n  printPending pending\n  tellLn \"\"\n  where\n    printPassedFailed :: Int -> Int -> m Unit\n    printPassedFailed p f = do\n      let total = p + f\n          testStr = pluralize \"test\" total\n          amount = show p <> \"/\" <> (show total) <> \" \" <> testStr <> \" passed\"\n          color = if f > 0 then Style.red else Style.dim\n      tellLn $ styled color amount\n\n    printPending :: Int -> m Unit\n    printPending p\n      | p > 0     = tellLn $ styled Style.yellow $ show p <> \" \" <> pluralize \"test\" p <> \" pending\"\n      | otherwise = pure unit\n\n    pluralize :: String -> Int -> String\n    pluralize s 1 = s\n    pluralize s _ = s <> \"s\"\n\ndata PrintAction\n  = PrintTest String Result\n  | PrintPending String\n\nderive instance printActionGeneric :: Generic PrintAction _\ninstance printActionShow :: Show PrintAction where show = genericShow\n\nprint\n  :: forall s m\n   . MonadState { lastPrintedSuitePath :: Maybe Path | s} m\n  => MonadWriter String m\n  => Path\n  -> PrintAction\n  -> m Unit\nprint path a = do\n  s <- get\n  case s.lastPrintedSuitePath of\n    Just p | p == path -> pure unit\n    _ -> do\n      tellLn $ styled (Style.bold <> Style.magenta)\n        $ intercalate \" \u00BB \" (parentSuiteName path)\n      put s { lastPrintedSuitePath = Just path }\n  case a of\n    PrintTest name (Success _ _) -> do\n      tellLn $ \"  \" <> styled Style.green \"\u2713\uFE0E \" <> styled Style.dim name\n    PrintTest name (Failure err) -> do\n      tellLn $ \"  \" <> styled Style.red (\"\u2717 \" <> name <> \":\")\n      tellLn $ \"\"\n      tellLn $ \"  \" <> styled Style.red (Error.message err)\n    PrintPending name -> do\n      tellLn $ \"  \" <> styled Style.cyan (\"~ \" <> name)\n", "/* global exports */\n\"use strict\";\n\n// module Test.Spec.Runner\n\nexport function exit(code) {\n  return function() {\n    try {\n      if (process && typeof process.exit === 'function') {\n        process.exit(code);\n      }\n    } catch(e) {}\n\n    try {\n      if (phantom && typeof phantom.exit === 'function') {\n        phantom.exit(code);\n      }\n    } catch(e) {}\n  };\n}\n", "module Data.DateTime.Instant\n  ( Instant\n  , instant\n  , unInstant\n  , fromDateTime\n  , fromDate\n  , toDateTime\n  , diff\n  ) where\n\nimport Prelude\n\nimport Data.DateTime (Millisecond, Second, Minute, Hour, Day, Year, DateTime(..), Date, Time(..), canonicalDate, millisecond, second, minute, hour, day, month, year)\nimport Data.Enum (fromEnum, toEnum)\nimport Data.Function.Uncurried (Fn7, runFn7)\nimport Data.Maybe (Maybe(..), fromJust)\nimport Data.Time.Duration (class Duration, Milliseconds(..), negateDuration, toDuration)\nimport Partial.Unsafe (unsafePartial)\n\n-- | An instant is a duration in milliseconds relative to the Unix epoch\n-- | (1970-01-01 00:00:00 UTC).\n-- |\n-- | The constructor is private as the `Instant` range matches that of the\n-- | `DateTime` type.\nnewtype Instant = Instant Milliseconds\n\nderive newtype instance eqDateTime :: Eq Instant\nderive newtype instance ordDateTime :: Ord Instant\n\ninstance boundedInstant :: Bounded Instant where\n  bottom = Instant (Milliseconds (-8639977881600000.0))\n  top = Instant (Milliseconds 8639977881599999.0)\n\ninstance showInstant :: Show Instant where\n  show (Instant ms) = \"(Instant \" <> show ms <> \")\"\n\n-- Unfortunately Instant cannot be made a `BoundedEnum` as it \"should\" be,\n-- unless enum cardinality and from/to range is extended to use a numeric type\n-- bigger than Int32\n\n-- | Attempts to create an `Instant` from a `Milliseconds` duration. The\n-- | minimum acceptable value equates to the `bottom` `DateTime` and the maximum\n-- | acceptable value equates to the `top` `DateTime`.\ninstant :: Milliseconds -> Maybe Instant\ninstant ms@(Milliseconds n)\n  | n >= -8639977881600000.0 && n <= 8639977881599999.0 = Just (Instant ms)\n  | otherwise = Nothing\n\n-- | Lowers an `Instant` to a `Milliseconds` duration.\nunInstant :: Instant -> Milliseconds\nunInstant (Instant ms) = ms\n\n-- | Creates an `Instant` from a `DateTime` value.\nfromDateTime :: DateTime -> Instant\nfromDateTime (DateTime d t) =\n  runFn7 fromDateTimeImpl\n    (year d) (fromEnum (month d)) (day d)\n    (hour t) (minute t) (second t) (millisecond t)\n\n-- | Creates an `Instant` from a `Date` value, using the assumed time 00:00:00.\nfromDate :: Date -> Instant\nfromDate d =\n  runFn7 fromDateTimeImpl\n    (year d) (fromEnum (month d)) (day d)\n    bottom bottom bottom bottom\n\n-- | Creates a `DateTime` value from an `Instant`.\ntoDateTime :: Instant -> DateTime\ntoDateTime = toDateTimeImpl mkDateTime\n  where\n  mkDateTime = unsafePartial \\y mo d h mi s ms ->\n    DateTime (canonicalDate y (fromJust (toEnum mo)) d) (Time h mi s ms)\n\n-- TODO: these could (and probably should) be implemented in PS\nforeign import fromDateTimeImpl :: Fn7 Year Int Day Hour Minute Second Millisecond Instant\nforeign import toDateTimeImpl :: (Year -> Int -> Day -> Hour -> Minute -> Second -> Millisecond -> DateTime) -> Instant -> DateTime\n\n-- | Calculates the difference between two instants, returning the result as a duration.\n-- | For example:\n-- | ```\n-- | do\n-- |   start <- liftEffect Now.now\n-- |   aLongRunningAff\n-- |   end <- liftEffect Now.now\n-- |   let\n-- |     hours :: Duration.Hours\n-- |     hours = Instant.diff end start\n-- |   log (\"A long running Aff took \" <> show hours)\n-- | ```\ndiff :: forall d. Duration d => Instant \u2192 Instant \u2192 d\ndiff dt1 dt2 = toDuration (unInstant dt1 <> negateDuration (unInstant dt2))\n", "export function now() {\n  return Date.now();\n}\n\nexport function getTimezoneOffset() {\n  var n = new Date(Date.now());\n  return n.getTimezoneOffset();\n}\n", "module Test.Spec.Runner\n  ( Reporter\n  , TestEvents\n  , module Test.Spec.Config\n  , run\n  , runSpec\n  , runSpec'\n  , runSpecT\n  )\n  where\n\nimport Prelude\n\nimport Control.Alternative ((<|>))\nimport Control.Monad.Trans.Class (lift)\nimport Control.Parallel (parTraverse, parallel, sequential)\nimport Data.Array (concat, groupBy)\nimport Data.Array.NonEmpty as NEA\nimport Data.DateTime.Instant (diff)\nimport Data.Either (Either(..), either)\nimport Data.Foldable (foldl)\nimport Data.Identity (Identity(..))\nimport Data.Int as Int\nimport Data.Maybe (Maybe(..), maybe)\nimport Data.Newtype (un)\nimport Data.Time.Duration (Milliseconds(..))\nimport Data.Traversable (class Traversable, for)\nimport Data.Tuple.Nested ((/\\))\nimport Effect (Effect)\nimport Effect.Aff (Aff, attempt, delay, forkAff, joinFiber, makeAff, throwError, try)\nimport Effect.Aff.AVar as AV\nimport Effect.Class (liftEffect)\nimport Effect.Exception (error)\nimport Effect.Now (now)\nimport Effect.Ref as Ref\nimport Pipes (yield, (>->))\nimport Pipes.Core (Producer, Pipe, (//>))\nimport Pipes.Core (runEffect, runEffectRec) as P\nimport Prim.TypeError (class Warn, Text)\nimport Test.Spec (Item(..), Spec, SpecT, SpecTree, Tree(..), collect)\nimport Test.Spec.Config (Config, TreeFilter(..), defaultConfig)\nimport Test.Spec.Console as Console\nimport Test.Spec.Result (Result(..))\nimport Test.Spec.Runner.Event (Event, Execution(..))\nimport Test.Spec.Runner.Event as Event\nimport Test.Spec.Speed (speedOf)\nimport Test.Spec.Style (styled)\nimport Test.Spec.Style as Style\nimport Test.Spec.Summary (successful)\nimport Test.Spec.Tree (Path, annotateWithPaths, countTests, isAllParallelizable)\n\nforeign import exit :: Int -> Effect Unit\n\nmakeTimeout\n  :: Milliseconds\n  -> Aff Unit\nmakeTimeout ms@(Milliseconds ms') = do\n  delay ms\n  makeAff \\cb -> mempty <$ do\n    cb <<< Left $ error $ \"test timed out after \" <> show (Int.round ms') <> \"ms\"\n\ntimeout\n  :: Milliseconds\n  -> Aff Unit\n  -> Aff Unit\ntimeout time t = do\n  sequential (parallel (try (makeTimeout time)) <|> parallel (try t))\n    >>= either throwError pure\n\ntype TestWithPath r = {test :: SpecTree Aff Unit, path :: Path | r}\n\n-- Run the given spec as `Producer` in the underlying `Aff` monad.\n-- This producer has two responsibilities:\n--      1) emit events for key moments in the runner's lifecycle\n--      2) collect the tst output into an array of results\n-- This allows downstream consumers to report about the tests even before the\n-- prodocer has completed and still benefit from the array of results the way\n-- the runner sees it.\n_run\n  :: forall m\n   . Functor m\n  => Config\n  -> SpecT Aff Unit m Unit\n  -> m TestEvents\n_run config = collect >>> map \\tests -> do\n  yield (Event.Start (countTests tests))\n  keepRunningVar <- liftEffect $ Ref.new true\n  r <- loop keepRunningVar $ annotateWithPaths $ filteredTests tests\n  yield (Event.End r)\n  pure r\n  where\n    filteredTests tests = case config.filterTree of\n      TreeFilter f -> f tests\n\n    loop :: _ -> Array _ -> TestEvents\n    loop keepRunningVar tests = do\n      let groups =\n            tests\n            <#> (\\test -> { isParallelizable: isAllParallelizable test, test })\n            # groupBy \\a b -> a.isParallelizable == b.isParallelizable\n\n      concat <$>\n        for groups \\g ->\n          if (NEA.head g).isParallelizable\n            then concat <$> mergeProducers (runItem keepRunningVar <$> NEA.toArray g)\n            else concat <$> for (NEA.toArray g) (runItem keepRunningVar)\n\n    runItem :: _ -> { isParallelizable :: Boolean, test :: _ } -> TestEvents\n    runItem keepRunningVar { test, isParallelizable } = do\n      keepRunning <- liftEffect $ Ref.read keepRunningVar\n\n      case test of\n        Leaf (name /\\ path) (Just (Item item)) -> do\n          if keepRunning then do\n            yield $ Event.Test (if isParallelizable then Parallel else Sequential) path name\n            res <- executeExample item.example\n            case res of\n              Failure _ | config.failFast -> liftEffect $ Ref.write false keepRunningVar\n              _ -> pure unit\n            yield $ Event.TestEnd path name res\n            pure [ Leaf name $ Just res ]\n          else\n            pure [ Leaf name Nothing ]\n\n        Leaf (name /\\ path) Nothing -> do\n          when keepRunning $\n            yield $ Event.Pending path name\n          pure [ Leaf name Nothing ]\n\n        Node (Right cleanup) xs ->\n          loop keepRunningVar xs <* lift (cleanup unit)\n\n        Node (Left (name /\\ path)) xs -> do\n          when keepRunning $\n            yield $ Event.Suite (if isParallelizable then Parallel else Sequential) path name\n          res <- loop keepRunningVar xs\n          when keepRunning $\n            yield $ Event.SuiteEnd path\n          pure [ Node (Left name) res ]\n\n    executeExample f = lift do\n      start <- liftEffect now\n      let wrap = maybe identity timeout config.timeout\n      e <- attempt $ wrap $ f \\a -> a unit\n      end <- liftEffect now\n      let duration = end `diff` start\n      pure $ either Failure (const $ Success (speedOf config.slow duration) duration) e\n\n\n-- https://github.com/felixSchl/purescript-pipes/issues/16\nmergeProducers :: forall t o a. Traversable t => t (Producer o Aff a) -> Producer o Aff (t a)\nmergeProducers ps = do\n  var <- lift AV.empty\n\n  fib <- lift $ forkAff do\n    let consumer i = lift (AV.put i var) *> pure unit\n    x <- parTraverse (\\p -> P.runEffectRec $ p //> consumer) ps\n    AV.kill (error \"finished\") var\n    pure x\n\n  let\n    loop = do\n      res <- lift $ try (AV.take var)\n      case res of\n        Left _ -> lift $ joinFiber fib\n        Right e -> do\n          yield e\n          loop\n  loop\n\ntype TestEvents = Producer Event Aff (Array (Tree String Void Result))\n\ntype Reporter = Pipe Event Event Aff (Array (Tree String Void Result))\n\n-- | Run the spec with `config`, returning the results, which\n-- | are also reported using specified Reporters, if any.\n-- | If configured as such, `exit` the program upon completion\n-- | with appropriate exit code.\nrunSpecT\n  :: forall m\n   . Functor m\n  => Config\n  -> Array Reporter\n  -> SpecT Aff Unit m Unit\n  -> m (Aff (Array (Tree String Void Result)))\nrunSpecT config reporters spec = _run config spec <#> \\runner -> do\n  let\n    events = foldl (>->) runner reporters\n    reportedEvents = P.runEffect $ events //> \\_ -> pure unit\n  if config.exit\n    then try reportedEvents >>= case _ of\n      Left err -> do\n        liftEffect $ Console.write $ styled Style.red (show err <> \"\\n\")\n        liftEffect $ exit 1\n        throwError err\n      Right results -> liftEffect do\n        let code = if successful results then 0 else 1\n        exit code\n        pure results\n    else reportedEvents\n\n-- | Run the spec with the default config\nrun\n  :: Warn (Text \"`Test.Spec.Runner.run` is Deprecated use runSpec instead\")\n  => Array Reporter\n  -> Spec Unit\n  -> Aff Unit\nrun = runSpec' defaultConfig\n\n-- | Run the spec with the default config\nrunSpec\n  :: Array Reporter\n  -> Spec Unit\n  -> Aff Unit\nrunSpec reporters spec = runSpec' defaultConfig reporters spec\n\nrunSpec'\n  :: Config\n  -> Array Reporter\n  -> Spec Unit\n  -> Aff Unit\nrunSpec' config reporters spec = void $ un Identity $ runSpecT config reporters spec\n", "module Test.Main where\n\nimport Prelude\n\nimport Data.Maybe (Maybe(..))\nimport Effect (Effect)\nimport Effect.Aff (launchAff_)\nimport Test.Node.Stream.Object as Test.Node.Stream.Object\nimport Test.Spec.Reporter (consoleReporter, specReporter)\nimport Test.Spec.Runner (defaultConfig, runSpec')\n\nmain :: Effect Unit\nmain = launchAff_ $ runSpec' (defaultConfig { timeout = Nothing }) [ consoleReporter ] do\n  Test.Node.Stream.Object.spec\n", "#!/usr/bin/env node\n\nimport { main } from './output/Test.Main/index.js'; main();"],
  "mappings": "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",
  "names": ["pure1", "eq", "tail", "reflectSymbol", "get", "tail", "reflectSymbol", "insert", "get", "reflectSymbol", "identity", "map", "Aff", "nonCanceler", "error", "kill", "k", "status", "fail", "run", "attempt", "result", "sequential", "join", "par", "cb", "head", "tail", "kills", "kid", "identity", "unsafeCoerce", "unsafeCoerce", "read", "modifyImpl", "write", "modifyImpl", "map", "append", "bind", "mempty", "bind", "pure", "init", "identity", "conj", "append", "apply", "map", "pure", "top", "traverse", "over", "negate", "liftEffect", "$$try", "bindFlipped", "map", "lift", "bind", "listen", "pure", "Compose", "_", "Compose", "error", "isNothing", "fromJust", "fst", "snd", "maybe", "isNothing", "fromJust", "fst", "snd", "maybe", "singleton", "empty", "append1", "foldMap1", "foldl", "foldr", "top", "bottom", "round", "singleton", "fromFoldable", "succ", "Cons", "head", "tail", "foldr", "compare", "from", "sortByImpl", "compare", "from", "runSTFn1", "runSTFn2", "__do", "$$void", "write", "__do", "singleton", "mapWithIndex", "index", "index", "groupBy", "index", "__do", "fromFoldable", "mapMaybe", "singleton", "mkEffectFn1", "wrap", "join", "apply", "pure", "bind", "wrap", "identity", "run", "bind1", "liftEffect", "untilJust", "wrap", "__do", "fromFoldable", "AVar", "error", "empty", "error", "ffiUtil", "put", "take", "ffiUtil", "take", "put", "kill", "error", "empty", "liftEffect", "head", "tail", "apply", "map", "last", "head", "mapMaybe", "un", "eq1", "all", "eq2", "bind", "un", "mapMaybe", "v", "for_", "modify_", "index", "name", "append1", "name", "name", "map3", "map", "group", "collect", "un", "show", "describe", "discard1", "it", "bind", "run", "chainMany", "fromFoldable", "bind1", "Leaf", "Node", "Leaf", "Node", "next", "singleton", "Leaf", "Node", "Leaf", "Node", "Leaf", "Node", "compare", "Leaf", "Node", "compare", "Leaf", "Node", "next", "toUnfoldable", "isEmpty", "Leaf", "insert", "Leaf", "singleton", "Node", "compare", "Leaf", "Node", "append1", "empty", "write", "functorProxy", "bind2", "applyProxy", "bind2", "map", "bindProxy", "applicativeProxy", "map", "pure", "bind", "bind", "map", "bind", "map", "show", "intercalate", "map", "fromFoldable", "singleton", "greaterThan", "add", "all", "for_", "toUnfoldable", "pure", "insert", "update", "bind", "gets", "lookup", "initialState", "execStateT", "liftEffect", "voidLeft", "write", "show", "discard1", "tellLn", "monadWriterStateT", "eq", "discard1", "tellLn", "append1", "intercalate", "monadStateStateT", "monadWriterStateT", "pure", "bind", "get", "when", "lookup", "isEmpty", "negateDuration", "pure", "lift", "discard2", "$$yield", "discard1", "show", "round", "time", "parallel", "$$try", "throwError", "pure1", "wrap", "identity", "diff", "bind", "applyFirst", "when", "groupBy", "map", "$$for", "map2", "collect", "spec", "foldl", "composePipes", "runEffect", "composeResponse", "liftEffect", "write"]
}
